<?xml version="1.0" encoding="utf-8n"?>
<!--  -*- Mode: xmldoc -*-  -->
<!DOCTYPE book [
<!ELEMENT book (chapter*)>
<!ELEMENT chapter (title,type,arguments?,package?,description,seealso*,link*,section,file?)>
<!ELEMENT title (#PCDATA)>
<!ELEMENT type (#PCDATA)>
<!ELEMENT arguments (#PCDATA)>
<!ELEMENT package (#PCDATA)>
<!ELEMENT description (#PCDATA)>
<!ELEMENT seealso (#PCDATA)>
<!ELEMENT link (#PCDATA)>
<!ELEMENT section (#PCDATA)>
<!ELEMENT file (#PCDATA)>
]>
<!-- DOCTYPEなんて書いたことないんで、全然自信なし
　　あってる？
-->
<!--
book
  └ chapter
      ├ title
      ├ type           Function, Special Form, Macro
      │                Misc, Tips, Variable, BufferLocal
      │                Keyword, Accessor
      ├ arguments      VariableやTipsはなし
      ├ package        Tipsはなし
      ├ description
      ├ seealso        0～n個
      ├ link           0～n個
      ├ section        データ型 変数と定数 制御構造
      │                パッケージ 関数 マクロ シンボル
      │                数値 文字 文字列 シーケンス
      │                リスト ハッシュ 配列 チャンク
      │                評価 入出力 ファイルシステム
      │                エラー ウィンドウ バッファ
      │                ミニバッファ リージョン モード
      │                シンタックス キーマップ テキスト
      │                検索・正規表現 ダイアログ 日付・時間
      │                メニュー ファイラー ポジション
      │                プロセス システム その他
      └ file            0 or 1
-->
<!--
<!ELEMENT (a, b)>     順番に出現
<!ELEMENT (a|b|c)>    どれか１つが出現
<!ELEMENT x (a?)>     0または1出現
<!ELEMENT x (a+)>     1回以上出現
<!ELEMENT x (a*)>     0回以上出現
-->
<!--
制作著作：xyzzy reference.xml(気が向いたら)作成プロジェクト・メンバー
        逸見雅人        henmi@synform.co.jp
        服部昌司        gyo@he.mirai.ne.jp
        サイトウ        HiroshiSaito@pob.org
        山本泰三        ymtz@pop02.odn.ne.jp
        花井達          変換ツール作成協力
        s.oowada
        OHKUBO KOHEI    kuboon@mbe.nifty.com
        HIE Masahiro    madoinu@ybb.ne.jp
        SANO Masatoshi  t01450ms@sfc.keio.ac.jp
        Nobuaki Arima   narima1109@hotmail.com
        広井誠          m_hiroi@yahoo.co.jp
        ※敬称略
-->
<!--
記述上の注意

*type           下記を注意して書く
                 - BufferLocal: バッファローカル変数を記述する
                 - Variable     大域変数もしくは定数
                 - KeyWord      :testとかのコロンで始まるヤツ
                 - Misc         specialとかlambdaとかsimple-stringとか、
                                意味はあるけど変数でもマクロでも関数でもないシンボル
*arguments      VariableやTipsはなし
*package        Tipsはなし
*description    ドキュメントがまだ、作成されていない場合は、「先頭に？？？
                なマークを入れる」などして、抽出できるようにしたい。
                意味が不明な場合は「詳細不明」と書いておきたい。
*seealso        0～n個
*link           ハイパーリンクがあれば、ここに記述する。
*section        服部さんの各種perlで目次を作成するときに利用される
*file           ソースがLispで提供されている場合は、ここにファイル名を入
                れておく。タグジャンプできるようにしたいところだが、将来
                の課題とする。

*Emacsにあってxyzzyにない関数は最初type=Miscにしていたが、type=Functionにした。
 descriptionには、xyzzyにないことを記述し、seealsoにxyzzyの相当機能を記述する。
-->
<!--
TODO：
□シンボル名と前後の文章を半角空白で分離する。
□seealsoに存在しないものが入っているのを消す。
□英文をできるかぎり訳す。
□argumentsの書式を統一する。
□キー入力を書く。
■戻り値・戻り値を統一する。→戻り値に統一する。
-->
<book>

<chapter>
<title>reduce</title>
<type>Function</type>
<arguments>reduce FUNCTION SEQUENCE &amp;key :FROM-END :START :END :INITIAL-VALUE</arguments>
<package>lisp</package>
<description>
2項演算子であるFUNCTIONで、SEQUENCEに対して畳み込みを行います。
  
  FUNCTION : 2項演算子。
  FROM-END : nil なら先頭から、non-nil なら最後の要素から畳み込みを行います。
  START    : 畳み込みを行うSEQUENCEの開始インデックスです。デフォルトは 0 です。 FROM-ENDがnon-nilなら終了インデックスになります。
  END      : 畳み込みを行うSEQUENCEの終了インデックスです。デフォルトは nil です。FROM-ENDがnon-nilなら開始インデックスになります。
  INITIAL-VALUE : non-nilならばこの値を初期値として使用します。


 (reduce #'- '(1 2 3)) = (- (- 1 2) 3)
 (reduce #'- '(1 2 3) :initial-value 10) = (- (- (- 10 1) 2) 3)
 (reduce #'- '(1 2 3) :from-end t :initial-value 10) = (- 1 (- 2 (- 3 10)))
</description>
<seealso></seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>count</title>
<type>Function</type>
<arguments>count ITEM SEQUENCE &amp;key :FROM-END :TEST :TEST-NOT :START :END :KEY</arguments>
<package>lisp</package>
<description>
ITEMとのテストを満足するSEQUENCE中の要素数を返します。結果は非負の整数です。

  FROM-END : 他の関数との互換性のために用意されたもので、結果に影響しません。
  TEST     : テストを行う2項演算子
  START    : テストする開始位置
  END      : テストの終了位置

</description>
<seealso>count-if</seealso>
<seealso>count-if-not</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>count-if</title>
<type>Function</type>
<arguments>count-if TEST SEQUENCE &amp;key :FROM-END :START :END :KEY</arguments>
<package>lisp</package>
<description>
TESTを満足するSEQUENCE中の要素数を返します。結果は非負の整数です。

  FROM-END : 他の関数との互換性のために用意されたもので、結果に影響しません。
  TEST     : テストを行う2項演算子
  START    : テストする開始位置
  END      : テストの終了位置

</description>
<seealso>count</seealso>
<seealso>count-if-not</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>count-if-not</title>
<type>Function</type>
<arguments>count-if-not TEST SEQUENCE &amp;key :FROM-END :START :END :KEY</arguments>
<package>lisp</package>
<description>
TESTを満足しないSEQUENCE中の要素数を返します。結果は非負の整数です。

  FROM-END : 他の関数との互換性のために用意されたもので、結果に影響しません。
  TEST     : テストを行う2項演算子
  START    : テストする開始位置
  END      : テストの終了位置

</description>
<seealso>count</seealso>
<seealso>count-if</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>substitute</title>
<type>Function</type>
<arguments>substitute NEWITEM OLDITEM SEQUENCE &amp;key :FROM-END :TEST :TEST-NOT :START :END :COUNT :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEに対してOLDITEMとのTESTを満足する要素をNEWITEMに置き換えた列を返します。
元のSEQUENCEは変更されませんが、返り値と一部を共有するかもしれません。

  TEST     : テストを行う2項演算子
  START    : 開始位置。デフォルトは0で非負の整数
  END      : 終了位置。デフォルトはnilで、nilの場合は列の長さを指定した場合と等しい動作。
  COUNT    : 置き換える最大の回数。
  FROM-END : nilならば先頭から、non-nil で末尾から置換を行う。COUNTが与えられた時のみ意味を持つ。

</description>
<seealso>substitute-if</seealso>
<seealso>substitute-if-not</seealso>
<seealso>nsubstitute</seealso>
<seealso>subst</seealso>
<seealso>substitute-string</seealso>
<seealso>sublis</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>substitute-if</title>
<type>Function</type>
<arguments>substitute-if NEWITEM TEST SEQUENCE &amp;key :FROM-END :START :END :COUNT :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEに対してTESTを満足する要素をNEWITEMに置き換えた列を返します。
元のSEQUENCEは変更されませんが、返り値と一部を共有するかもしれません。

  TEST     : テストを行う単項演算子
  START    : 開始位置。デフォルトは0で非負の整数
  END      : 終了位置。デフォルトはnilで、nilの場合は列の長さを指定した場合と等しい動作。
  COUNT    : 置き換える最大の回数。
  FROM-END : nilならば先頭から、non-nil で末尾から置換を行う。COUNTが与えられた時のみ意味を持つ。

</description>
<seealso>subst-if</seealso>
<seealso>substitute</seealso>
<seealso>substitute-if-not</seealso>
<seealso>nsubstitute-if</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>substitute-if-not</title>
<type>Function</type>
<arguments>substitute-if-not NEWITEM TEST SEQUENCE &amp;key :FROM-END :START :END :COUNT :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEに対してTESTを満足しない要素をNEWITEMに置き換えた列を返します。
元のSEQUENCEは変更されませんが、返り値と一部を共有するかもしれません。

  TEST     : テストを行う単項演算子
  START    : 開始位置。デフォルトは0で非負の整数
  END      : 終了位置。デフォルトはnilで、nilの場合は列の長さを指定した場合と等しい動作。
  COUNT    : 置き換える最大の回数。
  FROM-END : nilならば先頭から、non-nil で末尾から置換を行う。COUNTが与えられた時のみ意味を持つ。

</description>
<seealso>subst-if-not</seealso>
<seealso>substitute</seealso>
<seealso>substitute-if</seealso>
<seealso>nsubstitute-if-not</seealso>
<link></link>
<section>リスト</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>nsubstitute</title>
<type>Function</type>
<arguments>nsubstitute NEWITEM OLDITEM SEQUENCE &amp;key :FROM-END :TEST :TEST-NOT :START :END :COUNT :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEに対してOLDITEMとのTESTを満足する要素をNEWITEMに置き換えた列を返します。
元のSEQUENCEは変更されます。

  TEST     : テストを行う2項演算子
  START    : 開始位置。デフォルトは0で非負の整数
  END      : 終了位置。デフォルトはnilで、nilの場合は列の長さを指定した場合と等しい動作。
  COUNT    : 置き換える最大の回数。
  FROM-END : nilならば先頭から、non-nil で末尾から置換を行う。COUNTが与えられた時のみ意味を持つ。

</description>
<seealso>nsubst</seealso>
<seealso>nsubstitute</seealso>
<seealso>nsubstitute-if</seealso>
<seealso>nsubstitute-if-not</seealso>
<seealso>substitute</seealso>
<seealso>nsbulis</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>nsubstitute-if</title>
<type>Function</type>
<arguments>nsubstitute-if NEWITEM TEST SEQUENCE &amp;key :FROM-END :START :END :COUNT :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEに対してTESTを満足する要素をNEWITEMに置き換えた列を返します。
元のSEQUENCEは変更されます。

  TEST     : テストを行う単項演算子
  START    : 開始位置。デフォルトは0で非負の整数
  END      : 終了位置。デフォルトはnilで、nilの場合は列の長さを指定した場合と等しい動作。
  COUNT    : 置き換える最大の回数。
  FROM-END : nilならば先頭から、non-nil で末尾から置換を行う。COUNTが与えられた時のみ意味を持つ。

</description>
<seealso>nsubst-if</seealso>
<seealso>nsubstitute</seealso>
<seealso>nsubstitute-if-not</seealso>
<seealso>substitute-if</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>nsubstitute-if-not</title>
<type>Function</type>
<arguments>nsubstitute-if-not NEWITEM TEST SEQUENCE &amp;key :FROM-END :START :END :COUNT :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEに対してTESTを満足しない要素をNEWITEMに置き換えた列を返します。
元のSEQUENCEは変更されます。

  TEST     : テストを行う単項演算子
  START    : 開始位置。デフォルトは0で非負の整数
  END      : 終了位置。デフォルトはnilで、nilの場合は列の長さを指定した場合と等しい動作。
  COUNT    : 置き換える最大の回数。
  FROM-END : nilならば先頭から、non-nil で末尾から置換を行う。COUNTが与えられた時のみ意味を持つ。

</description>
<seealso>nsubst-if-not</seealso>
<seealso>nsubstitute</seealso>
<seealso>nsubstitute-if</seealso>
<seealso>substitute-if-not</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>psetq</title>
<type>Macro</type>
<arguments>psetq &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
変数に値を設定します。

  (psetq 変数1 値1 変数2 値2 ... 変数N 値N)

上記の様に変数と値の組を任意の数だけ並べることができます。 

setqと似ていますがsetqが頭から順に変数に束縛していくのに対し、psetqは値を全て評価した上で束縛します。
使用例：
  ; psetq の場合
  (let ((from 1)
        (to 100))
    (psetq from to to from)
    (values from to))
  =&gt;100
  =&gt;1

  ; setq の場合
  (let ((from 1)
        (to 100))
    (setq from to to from)
    (values from to))
  =&gt;100
  =&gt;100
</description>
<seealso>setq</seealso>
<link></link>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>atan</title>
<type>Function</type>
<arguments>atan Y &amp;optional X</arguments>
<package>lisp</package>
<description>
逆正接関数の値を返します。
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>asin</title>
<type>Function</type>
<arguments>asin NUMBER</arguments>
<package>lisp</package>
<description>
逆正弦関数の値を返します。
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>acos</title>
<type>Function</type>
<arguments>acos NUMBER</arguments>
<package>lisp</package>
<description>
逆余弦関数の値を返します。
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>acosh</title>
<type>Function</type>
<arguments>acosh Z</arguments>
<package>lisp</package>
<description>
逆双曲線余弦関数を計算します。
</description>
<seealso>acos</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>atanh</title>
<type>Function</type>
<arguments>atanh Z</arguments>
<package>lisp</package>
<description>
逆双曲線正接関数を計算します。
</description>
<seealso>atan</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>asinh</title>
<type>Function</type>
<arguments>asinh Z</arguments>
<package>lisp</package>
<description>
逆双曲線正弦関数を計算します。
</description>
<seealso>asin</seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>denominator</title>
<type>Function</type>
<arguments>denominator RATIONAL</arguments>
<package>lisp</package>
<description>
分数の分母を返します。
</description>
<seealso>numerator</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>numerator</title>
<type>Function</type>
<arguments>numerator RATIONAL</arguments>
<package>lisp</package>
<description>
分数の分子を返します。
</description>
<seealso>denominator</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>conjugate</title>
<type>Function</type>
<arguments>conjugate NUMBER</arguments>
<package>lisp</package>
<description>
共役複素数を返します。
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>cis</title>
<type>Function</type>
<arguments>cis Z</arguments>
<package>lisp</package>
<description>
偏角が Z で絶対値が 1 の複素数を返します。

  (cis Z) == (complex (cos Z) (sin Z))
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>phase</title>
<type>Function</type>
<arguments>phase Z</arguments>
<package>lisp</package>
<description>
複素数の偏角を求めます。
返り値はラジアン単位です。

  (phase -1)
  =&gt;3.141593
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>number.l</file>
</chapter>

<chapter>
<title>*history-file-name*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ヒストリを保存するファイル名です。
nil の場合は関数 history-file-name において
適当に決定されます。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>*save-history*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
保存するヒストリの個数です。
[共通設定] - [いろいろ] - [保存するヒストリの個数(S)] で値を指定することができます。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>unregister-history-variable</title>
<type>Function</type>
<arguments>unregister-history-variable VAR</arguments>
<package>editor</package>
<description>
変数をヒストリ変数の登録から削除します。
</description>
<seealso>define-history-variable</seealso>
<seealso>register-history-variable</seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>register-history-variable</title>
<type>Function</type>
<arguments>register-history-variable VAR</arguments>
<package>editor</package>
<description>
すでに定義された変数 VAR をヒストリ変数に登録します。
ファイルに書き込まれるため、変数の内容は readable である必要があります。
readable であるとは、具体的に言うと「文字、文字列、数値、シンボルと
それらのリストで構成されるデータ」のことです。<!-- 抜けがあったらごめんなさい -->

  VAR : ヒストリ変数に登録する変数のシンボル、もしくはそれらのリスト
</description>
<seealso>define-history-variable</seealso>
<seealso>unregister-history-variable</seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>*save-resume-info*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nil ならば終了時の状態を保存します。
[共通設定] - [さまざま] - [終了時の状態を保存する(U)] で値を指定することができます。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>some</title>
<type>Function</type>
<arguments>some PREDICATE SEQUENCE &amp;rest MORE-SEQUENCES</arguments>
<package>lisp</package>
<description>
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
非nilな値を返すと、その値をSOMEの返り値としてすぐに終了します。
PREDICATEを満たす要素が見つからない時は nil を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。
</description>
<seealso>every</seealso>
<seealso>notany</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>every</title>
<type>Function</type>
<arguments>every PREDICATE SEQUENCE &amp;rest MORE-SEQUENCES</arguments>
<package>lisp</package>
<description>
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
nil を返すと、nilをすぐに返します。
全ての要素がPREDICATEを満たす場合、 t を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。

</description>
<seealso>some</seealso>
<seealso>notevery</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>notany</title>
<type>Function</type>
<arguments>not-any PREDICATE SEQUENCE &amp;rest MORE-SEQUENCES</arguments>
<package>lisp</package>
<description>
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
非nilな値を返すと、 nil をすぐに返します。
PREDICATEを満たす要素が見つからない時は t を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。
</description>
<seealso>notevery</seealso>
<seealso>some</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>notevery</title>
<type>Function</type>
<arguments>notevery PREDICATE SEQUENCE &amp;rest MORE-SEQUENCES</arguments>
<package>lisp</package>
<description>
SEQUENCEの先頭の要素から順番にPREDICATEを適用していき、PREDICATEが
nil を返すと、t をすぐに返します。
全ての要素がPREDICATEを満たす場合、 nil を返します。

MORE-SEQUNCESが与えられた時、SEQUENCEの中で最も短いものの終わりまで実行されます。
</description>
<seealso>notany</seealso>
<seealso>every</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>merge</title>
<type>Function</type>
<arguments>merge RESULT-TYPE SEQUENCE1 SEQUENCE2 PREDICATE &amp;key KEY</arguments>
<package>lisp</package>
<description>
SEQUENCE1とSEQUENCE2を併合します。SEQUENCE1とSEQUENCE2は破壊されません。
PREDICATEによりSEQUENCE1とSEQUENCE2の値を比較し、非nilならば SEQUENCE1の値を 
nil ならば SEQUENCE2の値を順にマージしていきます。

RESULT-TYPE : 結果となるシーケンスの型を指定します。
PREDICATE   : シーケンス同士を比較する関数を指定します。
KEY         : 比較対照を取得する関数を指定します。

例
  (merge 'list '(1 2 3 5 8) '(2 4 6) #'&lt;) =&gt; (1 2 2 3 4 5 6 8)
  (merge 'string "AbCF" "aBcd" #'char-lessp) =&gt; "AabBCcdF"
</description>
<seealso>stable-sort</seealso>
<link></link>
<section>シーケンス</section>
<file>sequence.l</file>
</chapter>

<chapter>
<title>self-insert-command</title>
<type>Function</type>
<arguments>self-insert-command &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
最後に入力されたキー*last-command-char*を挿入モードの如何によりinsert/overwrite-charします。
括弧が入力された時に強調表示がなされるのもこの中での作用です。
</description>
<seealso>*auto-fill-hook</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>make-marker</title>
<type>Function</type>
<arguments>make-marker &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
空のマーカーを作って返します。

  BUFFER : マーカーを作るバッファを指定します。
</description>
<seealso>set-marker</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-marker</title>
<type>Function</type>
<arguments>set-marker MARKER &amp;optional POINT</arguments>
<package>editor</package>
<description>
マーカーにポジションを設定します。
POINT が nil の場合は現在の位置を設定します。

  POINT : マーカーに設定する位置

使用例：
  (setq m (make-marker))
  =&gt; #&lt;marker: *scratch*: -&gt;
  (set-marker m)
  =&gt; #&lt;marker: *scratch*: 62&gt;
  (marker-point m)
  =&gt; 62
</description>
<seealso>make-marker</seealso>
<seealso>unset-marker</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unset-marker</title>
<type>Function</type>
<arguments>unset-marker MARKER</arguments>
<package>editor</package>
<description>
マーカーのポジションを解除します。
オブジェクトはマーカーとして残ります。

使用例：
  (unset-marker m)
  =&gt; t
  m
  =&gt; #&lt;marker: *scratch*: -&gt;
</description>
<seealso>set-marker</seealso>
<seealso>delete-marker</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-marker</title>
<type>Function</type>
<arguments>goto-marker MARKER</arguments>
<package>editor</package>
<description>
マーカーのポジションへポイントを移動します。
goto-char と違い、ポイント（数字）を引数として受け取ることはできません。
</description>
<seealso>set-marker</seealso>
<seealso>goto-char</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-marker</title>
<type>Function</type>
<arguments>delete-marker MARKER</arguments>
<package>editor</package>
<description>
マーカーを削除します。
オブジェクトはマーカーとして使えなくなります。
成功した場合 t、すでに削除されていた場合は nil を返します。

使用例：
  (delete-marker m)
  =&gt; t
  m
  =&gt; #&lt;deleted-marker 128914348&gt;
</description>
<seealso>unset-marker</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>marker-point</title>
<type>Function</type>
<arguments>marker-point MARKER</arguments>
<package>editor</package>
<description>
マーカーの位置を数値で返します。
マーカーの位置が設定されていなかったり削除されていたりした場合は nil を返します。

使用例：
  (marker-point m)
  =&gt; 62
</description>
<seealso>set-marker</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>marker-buffer</title>
<type>Function</type>
<arguments>marker-buffer MARKER</arguments>
<package>editor</package>
<description>
マーカーが設定されているバッファを返します。

使用例：
  (marker-buffer m)
  =&gt; #&lt;buffer: *scratch*&gt;
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>switch-to-buffer-other-window</title>
<type>Function</type>
<arguments>switch-to-buffer-other-window BUFFER &amp;optional NOWARN</arguments>
<package>editor</package>
<description>
他のウィンドウに移ってからバッファを切り替えます。
ウィンドウ数が1の時は、ウィンドウを分割します。

BUFFER : このバッファにカレントウィンドウを切り替えます。
NOWARN : non-nilならば、指定したバッファが他のアプリケーションにより更新されているかのチェックを行いません。
</description>
<seealso>switch-to-buffer</seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>*filer-click-toggle-marks-always*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
nilなら、ファイラーで左クリックしたとき、その位置にカーソルがある場合の
みマークを反転します。
non-nil なら、カーソルの移動とマークの反転の両方を同時に行います。
デフォルトは t です。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-eat-esc*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
nilなら、モードレスファイラーでESCを押しても閉じません。
デフォルトは t です。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>filer-context-menu</title>
<type>Function</type>
<arguments>filer-context-menu</arguments>
<package>editor</package>
<description>
ファイラーにてコンテキストメニューを表示します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-format-comma*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nilなら、ファイルサイズをカンマ区切りで表示します。
[共通設定] - [ファイラ] - [ファイルサイズをカンマ区切りで表示(C)] で値を指定することができます。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-chdir-primary-p*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
（詳細不明）
<!-- ファイラーにてアクティブなウィンドウのディレクトリを変更したかどうか。 -->
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-drag-and-drop-helper</title>
<type>Function</type>
<arguments>*filer-drag-and-drop-helper EFFECT FILES SRC DEST</arguments>
<package>editor</package>
<description>
（詳細不明）
<!-- ファイラーへドラッグアンドドロップした時の動作です。 -->
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*filer-retrieve-icon*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nil のとき、ファイラーでファイルタイプに応じたアイコンを表示します。
[共通設定] - [ファイラ] - [アイコンをファイルから取ってくる(I)] で値を指定することができます。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*filer-last-file-mask*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
一画面ファイラーの初期のファイルマスクをリストで設定します。
</description>
<seealso>*filer-primary-file-mask*</seealso>
<seealso>*filer-secondary-file-mask*</seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-left-window-p*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
二画面ファイラーを閉じたとき、どちらのウィンドウがアクティブだったかが保存
されます。ファイラー未起動時の値は t です。

  nil     : 右側のウィンドウ
  non-nil : 左側のウィンドウ

<!--
  使用例：
  ; [xyzzy:07026]
  ; ファイラーの起動時に表示するディレクトリを前回の終了時と同じに
  (register-history-variable '*filer-primary-directory*)
  (register-history-variable '*filer-secondary-directory*)
  (register-history-variable '*filer-left-window-p*) 
-->
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-secondary-directory*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
二画面ファイラーのアクティブでない方のディレクトリを示します。
右側か左側かは *filer-left-window-p* の値によって決まります。
ファイラー未起動時は右側のディレクトリを指定できます。
</description>
<seealso>*filer-primary-directory*</seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-primary-directory*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
二画面ファイラーのアクティブな方のディレクトリを示します。
右側か左側かは *filer-left-window-p* の値によって決まります。
ファイラー未起動時は左側のディレクトリを指定できます。

使用例：
  ; [xyzzy:07218]
  ; 常にカレントディレクトリからファイラーを起動する。
  (defun foo ()
    (interactive)
    (let ((*filer-primary-directory* nil)
          (*filer-secondary-directory* nil))
      (open-filer)))
</description>
<seealso>*filer-secondary-directory*</seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-dual-window*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファなどでディレクトリを入力した時に立ち上がるファイラーを選択します。<!-- もうちょっとしっくりくる説明はないだろうか -->
nil なら一画面ファイラー、non-nil なら二画面ファイラーが起動します。
デフォルトは nil です。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-last-command-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラーにてコマンドを実行した時に最後に入力された文字を示します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>filer-read-char</title>
<type>Function</type>
<arguments>filer-read-char</arguments>
<package>editor</package>
<description>
ファイラーにてキーボードからの入力を読み込み、文字を返します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-swap-windows</title>
<type>Function</type>
<arguments>filer-swap-windows</arguments>
<package>editor</package>
<description>
二画面ファイラーにてもう一方のウィンドウへフォーカスが移ります。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-modify-column-width</title>
<type>Function</type>
<arguments>filer-modify-column-width N D &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにおけるそれぞれのカラムの幅を変えます。

  N                  : 変更するカラム
             0           ファイル名
             1           サイズ
             2           更新日時
             3           属性
  D                  : 変更量
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-modal-p</title>
<type>Function</type>
<arguments>filer-modal-p</arguments>
<package>editor</package>
<description>
ファイラーがモーダルか判別します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-viewer</title>
<type>Function</type>
<arguments>filer-viewer</arguments>
<package>editor</package>
<description>
ファイラーにてカーソル位置のファイルの最初の方を見ることができます。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-calc-directory-byte-size</title>
<type>Function</type>
<arguments>filer-calc-directory-byte-size</arguments>
<package>editor</package>
<description>
ファイラーにて選択したディレクトリのファイルサイズの合計を計算します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-calc-directory-size</title>
<type>Function</type>
<arguments>filer-calc-directory-size</arguments>
<package>editor</package>
<description>
ファイラーにて選択したディレクトリのディスク使用量を計算します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-left-window-p</title>
<type>Function</type>
<arguments>filer-left-window-p</arguments>
<package>editor</package>
<description>
二画面ファイラーにて現在アクティブなウィンドウが左側のウィンドウか判別します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-right-window</title>
<type>Function</type>
<arguments>filer-right-window</arguments>
<package>editor</package>
<description>
二画面ファイラーにて右側のウィンドウをアクティブにします。
</description>
<seealso>filer-left-window</seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-left-window</title>
<type>Function</type>
<arguments>filer-left-window</arguments>
<package>editor</package>
<description>
二画面ファイラーにて左側のウィンドウをアクティブにします。
</description>
<seealso>filer-right-window</seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-dual-window-p</title>
<type>Function</type>
<arguments>filer-dual-window-p</arguments>
<package>editor</package>
<description>
ファイラーが二画面ファイラーかどうかを判別します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-sort-order</title>
<type>Function</type>
<arguments>filer-get-sort-order &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにおけるファイルの表示順を返します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-sort</title>
<type>Function</type>
<arguments>filer-sort ARG &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにおけるファイルの表示順を変更します。

  ARG                : 表示順を指定します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-count-marks</title>
<type>Function</type>
<arguments>filer-count-marks &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてマークされたファイルの数を返します。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します。
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-clear-all-marks</title>
<type>Function</type>
<arguments>filer-clear-all-marks &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてマークを全て解除します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-set-file-mask</title>
<type>Function</type>
<arguments>filer-set-file-mask MASK &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにて表示する条件を指定します。

  MASK               : 表示する条件
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-goto-file</title>
<type>Function</type>
<arguments>filer-goto-file STRING &amp;optional START REVERSE WILD-P</arguments>
<package>editor</package>
<description>
ファイラーにてファイル名が STRING の位置にカーソルを移動します。

  STRING             : 検索するファイル名
  START              : （詳細不明）<!-- 検索を開始する位置？ -->
             nil         （詳細不明）<!-- 最初から？ -->
             non-nil     （詳細不明）<!-- カーソル位置から？ -->
  REVERSE            : 探す方向
             nil         前方向
             non-nil     後方向
  WILD-P             : （詳細不明）<!-- ワイルドカードを有効にするか？ -->
             nil         （詳細不明）<!-- 無効？ -->
             non-nil     （詳細不明）<!-- 有効？ -->
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-isearch</title>
<type>Function</type>
<arguments>filer-isearch &amp;optional CHAR NO-WRAP SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてインクリメンタルサーチによるカーソル移動を行います。

  CHAR               : 検索する文字。nil の時は入力されたキーを検索します。
  NO-WRAP            : 最後までいったら、最初に戻るかどうか
             nil         戻らない
             non-nil     戻る
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-set-text</title>
<type>Function</type>
<arguments>filer-set-text STRING</arguments>
<package>editor</package>
<description>
一画面ファイラーのファイル名の欄に STRING をセットします。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-text</title>
<type>Function</type>
<arguments>filer-get-text</arguments>
<package>editor</package>
<description>
一画面ファイラーにて上部のファイル名の欄に書いてあるテキストを返します。
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-current-file-directory-p</title>
<type>Function</type>
<arguments>filer-current-file-directory-p &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてカーソル位置のファイルがディレクトリかどうかを判定します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-current-file-dot-dot-p</title>
<type>Function</type>
<arguments>filer-current-file-dot-dot-p &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてカーソル位置のファイルが親ディレクトリを示す &quot;..&quot; 
であるかどうかを判定します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-current-file</title>
<type>Function</type>
<arguments>filer-get-current-file &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてカーソル位置のファイルのパスを返します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-mark-files</title>
<type>Function</type>
<arguments>filer-get-mark-files &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてマークされたファイルのパスをリストの形で返します。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-close</title>
<type>Function</type>
<arguments>filer-close RESULT</arguments>
<package>editor</package>
<description>
ファイラーを閉じます。

  RESULT : （詳細不明）
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-toggle-all-marks</title>
<type>Function</type>
<arguments>filer-toggle-all-marks &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにて現在のディレクトリの全てのファイルについてマークされた状態と
されていない状態を反転させます。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-toggle-mark</title>
<type>Function</type>
<arguments>filer-toggle-mark &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてカーソル位置のファイルについてマークされた状態とされていない
状態を反転させます。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-mark-match-files</title>
<type>Function</type>
<arguments>filer-mark-match-files MASK &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
MASK の示す条件を満たすファイルを全てマークします。

  MASK               : マークするファイル名の条件
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-mark-all</title>
<type>Function</type>
<arguments>filer-mark-all &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにて現在表示しているディレクトリにあるファイル全てをマークします。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-mark</title>
<type>Function</type>
<arguments>filer-mark &amp;optional FILE-ONLY-P SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてカーソル位置のファイルをマークします。

  FILE-ONLY-P        : ディレクトリも対象にするか
             nil         ディレクトリも対象にします
             non-nil     ファイルだけを対象にします
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-drive</title>
<type>Function</type>
<arguments>filer-get-drive &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにて現在表示しているドライブを取得します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-get-directory</title>
<type>Function</type>
<arguments>filer-get-directory &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにて現在表示しているディレクトリのフルパスを取得します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-set-directory</title>
<type>Function</type>
<arguments>filer-set-directory DIRECTORY &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにて表示するディレクトリを DIRECTORY に変更します。

  DIRECTORY          : ディレクトリを指定します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-subscribe-to-reload</title>
<type>Function</type>
<arguments>filer-subscribe-to-reload PATH &amp;optional SUB-DIRECTORY-P</arguments>
<package>editor</package>
<description>
ファイラーにて PATH を表示しているウィンドウを更新し、
最新の状態にします。

  PATH            : パスを指定します
  SUB-DIRECTORY-P : PATH のサブディレクトリを更新対象にするか否か
          nil         更新しない
          non-nil     更新する
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-demand-reload</title>
<type>Function</type>
<arguments>filer-demand-reload</arguments>
<package>editor</package>
<description>
（詳細不明）
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-reload</title>
<type>Function</type>
<arguments>filer-reload &amp;optional MASK SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーの画面を更新し、最新の状態にします。

  MASK               : 表示するファイルの条件を指定します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-scroll-right</title>
<type>Function</type>
<arguments>filer-scroll-right &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにて右方向にスクロールします。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso>filer-scroll-left</seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-scroll-left</title>
<type>Function</type>
<arguments>filer-scroll-left &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにて左方向にスクロールします。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso>filer-scroll-right</seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-goto-eof</title>
<type>Function</type>
<arguments>filer-goto-eof &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてカーソルのウィンドウの最後に移動します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso>filer-goto-bof</seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-goto-bof</title>
<type>Function</type>
<arguments>filer-goto-bof &amp;optional SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてカーソルをウィンドウの先頭に移動します。

  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso>filer-goto-eof</seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-forward-page</title>
<type>Function</type>
<arguments>filer-forward-page &amp;optional ARG SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてカーソルを次のページに移動します。

  ARG                : 指定ページ数移動します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>filer-forward-line</title>
<type>Function</type>
<arguments>filer-forward-line &amp;optional ARG SECONDARY-WINDOW-P</arguments>
<package>editor</package>
<description>
ファイラーにてカーソルを次の行に移動します。

  ARG                : 指定行数移動します
  SECONDARY-WINDOW-P : 対象とするウィンドウを指定します
             nil         現在アクティブなウィンドウ
             non-nil     現在アクティブでないウィンドウ
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>macroexpand-1</title>
<type>Function</type>
<arguments>macroexpand-1 FORM &amp;optional ENV</arguments>
<package>lisp</package>
<description>
macroexpandに似ていますが、展開されるレベルが1レベルで終わるところが違います。
自作のマクロなどがどう展開されるのか調べるときに便利です。

使用例:
  (defmacro my-macro ()
    `(dotimes (x 10)))
  というマクロがあるとき
  
  (macroexpand '(my-macro))
  =&gt; (block nil (let* ((x 0) (#1=#:count 10)) (lisp::*loop (if (&gt;= x #1#) (return (progn 'nil))) (tagbody) (setq x (+ x 1)))))   
  とmy-macro展開後のdotimesまで(実際はdotimesを展開後さらにdo*を展開)が再帰的に展開されますが、

  (macroexpand-1 '(my-macro))
  =&gt; (dotimes (x 10))
  と、my-macroだけが展開されます。
</description>
<seealso>macroexpand</seealso>
<link></link>
<section>マクロ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tailp</title>
<type>Function</type>
<arguments>tailp SUBLIST LIST</arguments>
<package>lisp</package>
<description>
SUBLISTがLISTを構成しているconsであるかを返す。

具体的にはLISTを順にcdrしていった結果とSUBLISTが
eqならtそうでないならnilを返す。
</description>
<seealso></seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>*buffer-bar-context-menu*</title>
<type>Variable</type>
<description>
バッファ・バー上で右クリックしたときに出てくるコンテキストメニューです。define-popup-menu で作成されています。（作成は app-menu.l）
</description>
<package>editor</package>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>*buffer-bar-context-menu-buffer*</title>
<type>Variable</type>
<description>
バッファ・バー上で選択されているバッファです。ただし、バッファ・バー上のコンテキストメニューで取得専用くらいしか使用できません。
</description>
<package>editor</package>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>*buffer-bar-context-menu-handler*</title>
<type>Variable</type>
<description>
デフォルトのバッファ・バー用コンテキストメニューハンドラです。setq-default によって定義されている標準の動作は、 *buffer-bar-context-menu-buffer* を定義し、*buffer-bar-context-menu* を返します。
</description>
<package>editor</package>
<section>バッファ</section>
<seealso>*buffer-bar-context-menu*</seealso>
<file>buffer.l</file>
</chapter>

<chapter>
<title>*buffer-bar-selected-buffer-to-first*</title>
<type>Variable</type>
<description>
non-nilなら、選択されたバッファがバッファ・バー上で一番先頭になる。キーでタブを移動した場合は移動されない。デフォルトは nil。
(setq *buffer-bar-selected-buffer-to-first* t)とやって、バッファ・バーをクリックすれば分かると思います。
</description>
<package>editor</package>
<section>バッファ</section>
</chapter>

<chapter>
<title>find-text-attribute-point</title>
<type>Function</type>
<arguments>find-text-attribute-point POINT</arguments>
<package>editor</package>
<description>
POINT の位置のテキストの属性を多値で返します。

  FROM          属性を付加された開始位置
  TO            属性を付加された終了位置
  TAG           個々の属性を区別するタグ
  FOREGROUND    文字色
  BACKGROUND    背景色
  BOLD          ボールド
  UNDERLINE     下線付き
  STRIKE-OUT    取り消し線
  PREFIX        不明
  EXTEND        不明

使用例：
  ;;; my-tagというタグ名で領域を緑色に設定
  (set-text-attribute (point-min) (point-max) 'my-tag :foreground 2)
  =&gt; t
  ;;; カーソル位置にタグがあれば赤色かつボールドに変更
  (multiple-value-bind (from to tag foreground background bold underline strike-out prefix extend)
      (find-text-attribute-point 1)
    (when tag
      (modify-text-attributes tag ; foregroundとbold以外はそのまま設定する。
       :foreground 1              ; 赤色に設定
       :background background
       :bold t                    ; ボールドに設定
       :underline underline
       :strike-out strike-out
       :prefix prefix
       :extend extend)))
  =&gt; t
</description>
<seealso>modify-text-attributes</seealso>
<seealso>find-text-attribute</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:dump-image-path</title>
<type>Function</type>
<arguments>dump-image-path</arguments>
<package>system</package>
<description>
読み込んだダンプファイルのパスを返します。

使用例：
  (si:dump-image-path)
  =&gt; "C:/Program Files/xyzzy/xyzzy.w2k"
</description>
<seealso>dump-xyzzy</seealso>
<link></link>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>signum</title>
<type>Function</type>
<arguments>signum NUMBER</arguments>
<package>lisp</package>
<description>
数値の符号を返します。
引数が複素数の場合は偏角が等しく絶対値が 1 の複素数を返します

使用例：
  (signum 12)
  =&gt; 1
  (signum 0)
  =&gt; 0
  (signum -5.0)
  =&gt;-1.0
  (signum (complex 1 1))
  =gt;#C(0.7071068 0.7071068)
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>expt</title>
<type>Function</type>
<arguments>expt BASE-NUMBER POWER-NUMBER</arguments>
<package>lisp</package>
<description>
べき乗します。

使用例：  
  (expt 2 10 )
  =&gt; 1024
  (expt 10 3)
  =&gt; 1000
</description>
<seealso></seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>count-xyzzy-instance</title>
<type>Function</type>
<arguments>count-xyzzy-instance</arguments>
<package>editor</package>
<description>
現在起動中のxyzzyの数を返します。
</description>
<seealso></seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>cwd</title>
<type>Function</type>
<arguments>cwd</arguments>
<package>editor</package>
<description>
xyzzy.exeの作業ディレクトリを返します。プロパティの作業フォルダ(S)の
ディレクトリが返されるのだと思います。

使用例： 
  (cwd)
  =&gt;"D:/WINNT/"
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-fold-width</title>
<type>Function</type>
<arguments>buffer-fold-width &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
折り返しの状態を返します。

  BUFFER : 状態を取得するバッファ

返り値は以下のとおりです。

  t    ウィンドウ幅で折り返す
  nil  折り返しをしない
  数値 その幅で折り返しをします。

多値で帰ってきているtの意味は不明です。
</description>
<seealso>set-buffer-fold-width</seealso>
<link></link>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-window-update</title>
<type>Function</type>
<arguments>set-buffer-fold-type-window-update</arguments>
<package>editor</package>
<description>
カレントバッファがウィンドウ幅で折り返しになっているかどうかを返します

返り値は以下のとおりです。
  :check  なっている
  nil     なっていない
</description>
<seealso>set-buffer-fold-type-window</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-column-update</title>
<type>Function</type>
<arguments>set-buffer-fold-type-column-update</arguments>
<package>editor</package>
<description>
カレントバッファが指定位置で折り返しになっているかどうかを返します

返り値は以下のとおりです。
  :check  なっている
  nil     なっていない
</description>
<seealso>set-buffer-fold-type-column</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-none-update</title>
<type>Function</type>
<arguments>set-buffer-fold-type-none-update</arguments>
<package>editor</package>
<description>
カレントバッファが折り返し無しになっているかどうかを返します

返り値は以下のとおりです。
  :check  なっている
  nil     なっていない
</description>
<seealso>set-buffer-fold-type-none</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>mode-specific-indent-command</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
indent-regionを参照のこと

使用例：
  ;;; 適当なモードで以下をevalしてみると、
  ;;; "ラベル:" のような行は行頭からになり、それ以外の行は8桁目からになる。
  (progn
    (make-local-variable 'mode-specific-indent-command)
    (setq mode-specific-indent-command
        #'(lambda () (save-excursion
                       (goto-bol)
                       (delete-horizontal-spaces)
                       (or (looking-at "^\\w+:") (indent-to 8))))))
</description>
<seealso>indent-region</seealso>
<link></link>
<section>モード</section>
<file></file>
</chapter>

<chapter>
<title>smart-indentation</title>
<type>Function</type>
<arguments>smart-indentation COLUMN</arguments>
<package>editor</package>
<description>
行頭からcolumn文字インデントします。
*smart-indentation*がtの時は適度にサボったりするみたいです。
</description>
<seealso>*smart-indentation*</seealso>
<seealso>indent-to</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>user-config-path</title>
<type>Function</type>
<arguments>user-config-path</arguments>
<package>editor</package>
<description>
ユーザ設定を格納しているディレクトリを返します。

ダイアログでの規定値等が格納されるディレクトリです
使用例： 
  (user-config-path)
  =&gt;"H:/xyzzy/usr/Administrator/w2k/"
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>macrolet</title>
<type>Special Form</type>
<arguments>macrolet ({(NAME LAMBDA-LIST {declaration}* [doc-string] {FORM}*)}*) {FORM}*</arguments>
<package>lisp</package>
<description>
defmacroの局所版です。
</description>
<seealso>defmacro</seealso>
<seealso>flet</seealso>
<link></link>
<section>マクロ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tagbody</title>
<type>Special Form</type>
<arguments>tagbody {TAG|STATEMENT}*</arguments>
<package>lisp</package>
<description>
labelジャンプです。
tagbody内は任意の数のtag(シンボルもしくは数字)とstatement(S式)からなり
実行時にはtagは無視されstatementが実行されます。(go tag)が評価されたときに
実行はtagの場所に移ります。tagbodyは終了時にnilを返します。
</description>
<seealso>go</seealso>
<link></link>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>block</title>
<type>Special Form</type>
<arguments>block NAME {FORM}*</arguments>
<package>lisp</package>
<description>
フォームを順番に評価して最後のフォームの結果を返します。 
ほとんどprognですがreturn-fromやreturnで戻り値が指定できるところが違います。
returnやreturn-fromにぶつかったときには残りの式は評価しません。
</description>
<seealso>return-from</seealso>
<link></link>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-sexp</title>
<type>Function</type>
<arguments>read-sexp PROMPT</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーがS式を入力するのを待ちます。
ユーザーの入力したS式と文字数を多値で返します。

使用例：
  ;;; ミニバッファからS式を入力する。
  (read-sexp "sexp: ")
  =&gt; (+ 3 3)
  =&gt; 7

</description>
<seealso>read-integer</seealso>
<seealso>read-string</seealso>
<link></link>
<section>ミニバッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>flet</title>
<type>Special Form</type>
<arguments>"({(NAME LAMBDA-LIST {declaration}* [doc-string] {FORM}*)}*) {FORM}*"</arguments>
<package>lisp</package>
<description>
ローカルな関数を定義してフォームを評価します。フォーム内で flet で
定義された関数は、外部で定義された同じ名前の関数よりも優先されます。
関数は同時に複数定義できます。

それぞれの定義方法は defun のように、最初に関数名、
次にパラメータのリスト(&amp;optional, &amp;rest, &amp;key パラメータも使えます)、
そしてoptional declaration と docstring、そして最後にフォームと続きます。

  (flet ((safesqrt (x) (sqrt (abs x)))) 
    ;; The safesqrt function is used in two places. 
    (safesqrt (apply #'+ (map 'list #'safesqrt longlist))))

</description>
<seealso>labels</seealso>
<seealso>macrolet</seealso>
<link></link>
<section>関数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-from-string</title>
<type>Function</type>
<arguments>read-from-string STRING &amp;optional EOF-ERROR-P EOF-VALUE &amp;key :start :end :preserve-whitespace</arguments>
<package>lisp</package>
<description>
文字列を読み、多値で2つの値を返します。1つ目の戻り値は Lisp Reader が読
み込んだオブジェクトそのもの、2つ目の戻り値は文字列中において読まなかっ
た最初の文字の位置です。文字列を最後まで読んだ場合、2つ目の戻り値はその
文字列の長さと等しくなります。

  STRING               : 読む対象である文字列
  EOF-ERROR-P          : EOFの状態でread-from-stringしたときにどうするか？
                non-nil    エラーとします。(デフォルト)
                nil        エラーとせず、nilを返します。
  EOF-VALUE            : EOFの状態でread-from-stringしたときにnilの代わりに返す文字を指定します。
  :start               : 読み始める位置(デフォルトは0)
  :end                 : 読み終わる位置(デフォルトは文字列の長さ)
  :preserve-whitespace : (詳細不明)<!-- ホワイトスペースを保持するかどうか？ -->
                non-nil    <!-- 保持する -->
                nil        <!-- 保持しない(デフォルト) -->
</description>
<seealso>parse-integer</seealso>
<link></link>
<section>入出力</section>
<file>stream.l</file>
</chapter>

<chapter>
<title>shrink-window</title>
<type>Function</type>
<arguments>shrink-window &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルのあるウィンドウの高さを小さくします。 
</description>
<seealso>shrink-window-horizontally</seealso>
<seealso>enlarge-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>window-coordinate</title>
<type>Function</type>
<arguments>window-coordinate &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
指定されたウィンドウの座標をリストで返します。
(左端のx座標 左端のy座標 右端のx座標 右端のy座標)

座標軸は左上が (0 0) で右下にいくほど値が大きくなり、
単位はピクセルです。

使用例:
  (window-coordinate)
  =&gt; (0 0 693 636)
</description>
<seealso>window-width</seealso>
<seealso>window-height</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>describe-variable</title>
<type>Function</type>
<arguments>describe-variable SYMBOL</arguments>
<package>editor</package>
<description>
指定された変数の現在の値、種類(constant or special)および docstring を表
示します。
</description>
<seealso>describe-function</seealso>
<link></link>
<section>シンボル</section>
<file>help.l</file>
</chapter>

<chapter>
<title>describe-function</title>
<type>Function</type>
<arguments>describe-function SYMBOL</arguments>
<package>editor</package>
<description>
指定された関数の引数と docstring を表示します。
</description>
<seealso>describe-variable</seealso>
<link></link>
<section>シンボル</section>
<file>help.l</file>
</chapter>

<chapter>
<title>describe-key</title>
<type>Function</type>
<arguments>describe-key KEY</arguments>
<package>editor</package>
<description>
指定したキーにバインドされた関数と docstring を表示します。
</description>
<seealso></seealso>
<link></link>
<section>キーマップ</section>
<file>help.l</file>
</chapter>

<chapter>
<title>describe-key-briefly</title>
<type>Function</type>
<arguments>describe-key-briefly KEY &amp;optional ARG</arguments>
<package>editor</package>
<description>
指定したキーにバインドされた関数を表示します。[C-x ?]

  KEY : 検索するキー
  ARG : 出力(表示)先をどこにするか
        nil     : ステータスバーに表示
        non-nil : バッファに「キー (関数名)」のフォーマットで文字列を出力
</description>
<seealso>describe-key</seealso>
<link></link>
<section>キーマップ</section>
<file>help.l</file>
</chapter>

<chapter>
<title>command-apropos</title>
<type>Function</type>
<arguments>command-apropos STRING</arguments>
<package>editor</package>
<description>
指定した正規表現に一致する interactive 宣言されている関数の一覧を表示し
ます。バインドされたキーがあれば、同時に表示します。
</description>
<seealso>apropos</seealso>
<link></link>
<section>シンボル</section>
<file>help.l</file>
</chapter>

<chapter>
<title>*apropos-no-regexp*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
non-nil に設定すると、apropos 実行時に、正規表現のメタ文字はエスケープさ
れます。デフォルトは nil です。
</description>
<seealso>apropos</seealso>
<link></link>
<section>シンボル</section>
<file>help.l</file>
</chapter>

<chapter>
<title>apropos</title>
<type>Function</type>
<arguments>apropos STRING &amp;optional PRINT-KEY PRED</arguments>
<package>editor</package>
<description>
指定した正規表現に一致するシンボルの一覧を表示します。

  STRING    : 検索する文字列
  PRINT-KEY : バインドされているキーを表示するかどうか
        non-nil : 表示する
        nil     : 表示しない
  PRED      : ？？？
</description>
<seealso>*apropos-no-regexp*</seealso>
<link></link>
<section>シンボル</section>
<file>help.l</file>
</chapter>

<chapter>
<title>nsubst-if-not</title>
<type>Function</type>
<arguments>nsubst-if-not NEW TEST TREE &amp;key :KEY</arguments>
<package>lisp</package>
<description>
TREEの中でTESTを満たさないものがあればNEWに置き換えたものを返します。
TESTが変更される点を除いてsubst-if-notと同じです。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         nilを返したら置き換えます。
  TREE : 対象のツリー

TESTの引数についてはsubst-ifを参照して下さい。

使用例：
  ;;; 適当なツリーを用意して、数字以外のものがあれば0に変換する。
  (setq a '((123 "abc") '(456 "123") (789 #\a)))
  =&gt; ((123 "abc") '(456 "123") (789 #\a))
  (nsubst-if-not 0 #'(lambda (x) (or (listp x) (integerp x))) a)
  =&gt; ((123 0) (0 (456 0)) (789 0))
  a
  =&gt; ((123 0) (0 (456 0)) (789 0))
</description>
<seealso>subst-if</seealso>
<seealso>nsubst-if</seealso>
<seealso>nsubst</seealso>
<link></link>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nsubst-if</title>
<type>Function</type>
<arguments>nsubst-if NEW TEST TREE &amp;key :KEY</arguments>
<package>lisp</package>
<description>
TREEの中でTESTを満たすものがあればNEWに置き換えたものを返します。
TREEが変更される点を除いてsubst-ifと同じです。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         non-nilを返したら置き換えます。
  TREE : 対象のツリー

TESTの引数についてはsubst-ifを参照して下さい。

使用例：
  ;;; 適当なツリーを用意して、その要素が奇数ならば0に置き換える。
  (setq a '((1 2) ((1 3) (1 (1 3)))))
  =&gt; ((1 2) ((1 3) (1 (1 3))))
  (nsubst-if 0 #'(lambda (x) (and (integerp x) (oddp x))) a)
  =&gt; ((0 2) ((0 0) (0 (0 0))))
  a
  =&gt; ((0 2) ((0 0) (0 (0 0))))
</description>
<seealso>subst-if</seealso>
<seealso>nsubst-if-not</seealso>
<seealso>nsubst</seealso>
<link></link>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>subst-if-not</title>
<type>Function</type>
<arguments>subst-if-not NEW TEST TREE &amp;key :KEY</arguments>
<package>lisp</package>
<description>
TREEの中でTESTを満たさないものがあればNEWに置き換えたものを返します。
TREEはそのままです。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         nilを返したら置き換えます。
  TREE : 対象のツリー

TESTの引数についてはsubst-ifを参照して下さい。

使用例：
  ;;; 適当なツリーを用意して、数字以外のものがあれば0に変換する。
  (setq a '((123 "abc") '(456 "123") (789 #\a)))
  =&gt; ((123 "abc") '(456 "123") (789 #\a))
  (subst-if-not 0 #'(lambda (x) (or (listp x) (integerp x))) a)
  =&gt; ((123 0) (0 (456 0)) (789 0))
  a
  =&gt; ((123 "abc") '(456 "123") (789 #\a))  
</description>
<seealso>subst-if</seealso>
<seealso>subst</seealso>
<link></link>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>subst-if</title>
<type>Function</type>
<arguments>subst-if NEW TEST TREE &amp;key :KEY</arguments>
<package>lisp</package>
<description>
TREEの中でTESTを満たすものがあればNEWに置き換えたものを返します。
TREEはそのままです。

  NEW  : 置き換える要素
  TEST : 置き換えるかどうかを判定するテスト
         non-nilを返したら置き換えます。
  TREE : 対象のツリー

TESTにはTREEの部分リストと要素を順番に引数として与えるので、必ずしも末端
の要素だけが置き換えの対象とはなりません。例えば、こんな感じで呼び出され
ます。

  ;;; funcで判定する場合
  (subst-if 0 #'func '(1 2 3))

  ;;; funcに引数として与えられる値(1 2 3だけじゃない)
  (1 2 3) 1 (2 3) 2 (3) 3 nil

下の使用例の様に事前の型チェックをして回避します。

使用例：
  ;;; 適当なツリーを用意して、その要素が奇数ならば0に置き換える。
  (setq a '((1 2) ((1 3) (1 (1 3)))))
  =&gt; ((1 2) ((1 3) (1 (1 3))))
  (subst-if 0 #'(lambda (x) (and (integerp x) (oddp x))) a)
  =&gt; ((0 2) ((0 0) (0 (0 0))))
  a
  =&gt; ((1 2) ((1 3) (1 (1 3))))
</description>
<seealso>subst-if-not</seealso>
<seealso>subst</seealso>
<link></link>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>with-hash-table-iterator</title>
<type>Macro</type>
<arguments>with-hash-table-iterator (MNAME HASH-TABLE) &amp;body BODY</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの要素を順番に返す関数を返してもらいます。

  MNAME      : 要素を順番に返す関数名を指定します。
               この関数は要素を列挙し終わるとnilを返します。
  HASH-TABLE : ハッシュテーブルを指定します。
  BODY       : フォームを記述します。

関数が順番に要素を返すので、loopを使ってnilが返るまで繰り返します。

使用例：
  (with-output-to-selected-buffer
    (with-hash-table-iterator (foo hsh)
      (loop
        (multiple-value-bind (f x y)
            (foo)
          (unless f (return))
          (format t "~S ~S~%" x y)))))
</description>
<seealso>maphash</seealso>
<link></link>
<section>ハッシュ</section>
<file>cmu_loop.l</file>
</chapter>

<chapter>
<title>file-newer-than-file-p</title>
<type>Function</type>
<arguments>file-newer-than-file-p FILE1 FILE2</arguments>
<package>editor</package>
<description>
ファイルの最終更新日を比較します。
戻り値は以下のとおりです。

  t   file1の方が新しい、もしくはfile2が無効。
  nil file2の方が新しい、もしくはfile1が無効。
</description>
<seealso>file-write-time</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*standard-output*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
標準出力を表すストリームです。
普段はステータスバーのウィンドウへの出力になっています。
lisp-interaction-modeではそのバッファへの出力になっています。

使用例：
  ;;; eval-expressionで評価した場合
  *standard-output*  
  =&gt; #&lt;status window stream 48042808&gt;

  ;;; lisp-interaction-modeで評価した場合
  *standard-output*
  =&gt; #&lt;buffer stream 48042280&gt;
</description>
<seealso>*standard-input*</seealso>
<link></link>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>write</title>
<type>Function</type>
<arguments>write OBJECT &amp;key :STREAM :ESCAPE :PRETTY :BASE :RADIX :CIRCLE :LEVEL :LENGTH :READABLY</arguments>
<package>lisp</package>
<description>
OBJECTを印字表現でストリームに出力します。:STREAMを省略すると
*standard-output*に出力します。
（詳細不明）
</description>
<seealso>read</seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>store-match-data</title>
<type>Function</type>
<arguments>store-match-data DATA</arguments>
<package>editor</package>
<description>
match-data で退避しておいた検索時点の状態を戻します。
</description>
<seealso>scan-buffer</seealso>
<seealso>match-data</seealso>
<link></link>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>match-data</title>
<type>Function</type>
<arguments>match-data &amp;optional DATA</arguments>
<package>editor</package>
<description>
scan-buffer で検索時点の状態を保持します。複数の検索をした後で、元の
検索の結果で match-string / match-beginning / match-end / replace-match 
を行うことが可能です。

使用例：
  ;;; カーソルより後ろにabcdefと文字列があった場合
  ;;; 検索を2回してからその結果をそれぞれ取得する。
  (let (1st 2nd)
    ; 検索
    (scan-buffer "a\\(\\w*\\)" :regexp t)
    (setq 1st (match-data))
    (scan-buffer "abc\\(\\w*\\)" :regexp t)
    (setq 2nd (match-data))
    ; 結果参照
    (store-match-data 1st)
    (msgbox "~A" (match-string 1))
    (store-match-data 2nd)
    (msgbox "~A" (match-string 1)))
</description>
<seealso>store-match-data</seealso>
<seealso>scan-buffer</seealso>
<link></link>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>msgbox</title>
<type>Function</type>
<arguments>msgbox FMT &amp;rest ARGS</arguments>
<package>editor</package>
<description>
メッセージボックスを表示します。
「OK」ボタンとインフォメーションアイコンが表示されます。

  FMT  : formatの出力書式と同じものを指定できます。
  ARGS : 出力書式へのパラメタとなります。

戻り値は:okのようです。

使用例：
  ;;; 出力書式で整形してみる。
  (msgbox "このバッファは ~A です。" buffer-mode)
  =&gt; :ok
</description>
<seealso>message-box</seealso>
<link></link>
<section>その他</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>global-unset-key</title>
<type>Function</type>
<arguments>global-unset-key KEY</arguments>
<package>editor</package>
<description>
グローバルなキーマップのキーの割り当てを解除します。

使用例：
  ;;; global-set-keyで割り当てたキーを解除してみる。
  (global-set-key #\C-r 'previous-page)
  =&gt; t
  (global-unset-key #\C-r)
  =&gt; t
</description>
<seealso>global-set-key</seealso>
<link></link>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>型一覧</title>
<type>Misc</type>
<arguments></arguments>
<package>lisp</package>
<description>
型は綺麗に階層構造を成す訳ではないのですが、subtypepでロジックに組み込ま
れているところから、嘘にならない程度に階層化したものです。[]付きの物は二
重に出現しています。

  list                                  リスト
  ├null                                ヌル
  └cons                                コンス
  atom                                  アトム
  ├number                              数値
  │├real                              実数
  ││├rational                        有理数
  │││├ratio                         分数
  │││└integer                       整数
  │││  └bignum                      －
  ││└float                           浮動小数点数
  ││  ├short-float                   小精度浮動小数点数
  ││  ├single-float                  単精度浮動小数点数
  ││  ├double-float                  倍精度浮動小数点数
  ││  └long-float                    長精度浮動小数点数
  │└complex                           複素数
  ├symbol                              シンボル
  │├[null]                            －
  │└keyword                           キーワード
  ├character                           文字
  │├base-character                    －
  ││└standard-char                   標準文字
  │└extended-character                －
  ├stream                              ストリーム
  │├two-way-stream                    双方向ストリーム
  │├echo-stream                       －
  │├broadcast-stream                  －
  │├file-stream                       ファイルストリーム
  │├synonym-stream                    文字列ストリーム
  │├string-stream                     －
  │└concatenated-stream               －
  ├sequence                            シーケンス
  │├[list]                            －
  │└[vector]                          －
  └array                               配列
    ├simple-array                      単純配列
    │└simple-string                   単純文字列
    └vector                            ベクタ
      ├simple-vector                   単純ベクタ
      └string                          文字列
        └[simple-string]               －

使用例：
  ;;; listはsequenceで、sequenceはatomだけど、listはatomではない。
  (subtypep 'list 'sequence)    =&gt; t
  (subtypep 'sequence 'atom)    =&gt; t
  (subtypep 'list 'atom)        =&gt; nil

参考：
  typespec.l
</description>
<seealso></seealso>
<link></link>
<section>シンボル</section>
<file></file>
</chapter>

<chapter>
<title>use-syntax-table</title>
<type>Function</type>
<arguments>use-syntax-table SYNTAX-TABLE &amp;optional BUFFER (INVALIDATE-P T)</arguments>
<package>editor</package>
<description>
バッファで使用するシンタックステーブルを設定します。

使用例：
  ;;; lispmode.lの例
  (use-syntax-table *lisp-mode-syntax-table*)
  =&gt; t
</description>
<seealso>syntax-table-p</seealso>
<seealso>syntax-table</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert-file-contents</title>
<type>Function</type>
<arguments>insert-file-contents FILENAME &amp;optional VISIT-P OFFSET SIZE</arguments>
<package>editor</package>
<description>
ファイルの内容をカーソル位置に挿入します。

  FILENAME : 挿入するファイル名
  VISIT-P  : ファイルを挿入後の動作を指定します。
        t       変更フラグ・UNDO情報のクリア、ファイルの日付の変更等を行います。
        nil     特に何もしません。
  OFFSET   : 挿入するオフセット
  SIZE     : 挿入する長さ

使用例：
  ;;; 簡単なテンプレートの挿入例
  ;;; site-lisp/template.lを用意しておくこと
  (defun insert-template ()
    (and (get-buffer-file-name)
         (not (file-exist-p (get-buffer-file-name)))
         (insert-file-contents (merge-pathnames "site-lisp/template.l" (si:system-root)) t)
         (message "template inserted")))
  =&gt; insert-template
  (add-hook '*lisp-mode-hook* 'insert-template)
  =&gt; (insert-template lisp-load-keyword-file)
</description>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-temp-file-name</title>
<type>Function</type>
<arguments>make-temp-file-name &amp;optional PREFIX SUFFIX DIRECTORY DIRECTORY-P</arguments>
<package>editor</package>
<description>
一時作業用のファイルを作成しそのパスを返します。
ファイルは即時に作成されます。同じようにディレクトリを作成することも可能です。

  PREFIX      : 一時作業用のファイルの接頭子
  SUFFIX      : 一時作業用のファイルの拡張子
                指定が無ければ".tmp"となります。
  DIRECTORY   : 一時作業用のファイルを作成するディレクトリ
                指定が無ければ環境変数TMPに作成されます。
  DIRECTORY-P : ファイルではなくディレクトリを作成する場合
        t       ディレクトリを作成します。
        nil     ファイルを作成します。

使用例：
  ;;; C:\spoolに一時作業用ファイルを作成します。 
  (make-temp-file-name "_den" "tmp" "c:/spool")
  =&gt; "c:/spool/_denc0dc.tmp"
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>shiftf</title>
<type>Macro</type>
<arguments>shiftf &amp;rest ARGS &amp;environment ENV</arguments>
<package>lisp</package>
<description>
引数として与えられた値の格納場所の内容をシフトさせます。
(shift a b c)とすると以下のようになります。

        ┌a ┐  ┌b ┐  ┌c ┐
実行前：│ 1│  │ 2│  │ 3│
        └─┘  └┬┘  └┬┘
              ┌─┘  ┌─┘
          ┌─┘  ┌─┘  
          ↓      ↓      
        ┌a ┐  ┌b ┐  ┌c ┐
実行後：│ 2│  │ 3│  │ 3│
        └─┘  └─┘  └─┘
</description>
<seealso>rotatef</seealso>
<link></link>
<section>関数</section>
<file>setf.l</file>
</chapter>

<chapter>
<title>gethash-region</title>
<type>Function</type>
<arguments>gethash-region FROM TO HASHTABLE &amp;optional DEFAULT</arguments>
<package>editor</package>
<description>
リージョンの文字列をハッシュテーブルから取得します。
(buffer-substring FROM TO)してから(gethash ... HASHTABLE)するようなものです。
</description>
<seealso>gethash</seealso>
<link></link>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>second</title>
<type>Function</type>
<arguments>second X</arguments>
<package>lisp</package>
<description>
cadrの別名です。
全く同じ動きをします。

使用例：
  ;;; cadrと同じ動きをする。
  (cadr '(1 2 3))
  =&gt; 2
  (second '(1 2 3))
  =&gt; 2
  (symbol-function 'cadr)
  =&gt; #&lt;lexical-closure: cadr&gt;
  (symbol-function 'second)
  =&gt; #&lt;lexical-closure: cadr&gt;
 
参考：
  ;;; list.lの定義
  (si:*fset 'second #'cadr)
</description>
<seealso>first</seealso>
<seealso>cadr</seealso>
<link></link>
<section>リスト</section>
<file></file>
</chapter>

<chapter>
<title>first</title>
<type>Function</type>
<arguments>first</arguments>
<package>lisp</package>
<description>
carの別名です。
全く同じ動きをします。

使用例：
  ;;; carと同じ動きをする。
  (car '(1 2 3))
  =&gt; 1
  (first '(1 2 3))
  =&gt; 1
  (symbol-function 'car)
  =&gt; #&lt;function: car&gt;
  (symbol-function 'first)
  =&gt; #&lt;function: car&gt;
 
参考：
  ;;; list.lの定義
  (si:*fset 'first #'car)
</description>
<seealso>car</seealso>
<link></link>
<section>リスト</section>
<file></file>
</chapter>

<chapter>
<title>set-buffer-eol-code</title>
<type>Function</type>
<arguments>set-buffer-eol-code CODE &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの改行コードを設定します。
引数として改行コードの種類を表す定数が用意されています。
昔は、set-buffer-newline-codeという名称でしたが、xyzzy 0.2.0.121 からこ
の名前に変更されました。

  CODE：バッファの改行コードの種類を指定します。
        LFの場合        *eol-lf*        0
        CRLFの場合      *eol-crlf*      1
        CRの場合        *eol-cr*        2

使用例：
  ;;; バッファの改行コードをLFに変更する。
  (set-buffer-eol-code *eol-lf*)
  =&gt; t

参考：
  Changelogのxyzzy 0.2.0.121を参照のこと
</description>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>base64-decode-region</title>
<type>Function</type>
<arguments>from to</arguments>
<package>editor</package>
<description>
リージョンをBase64デコードします。
</description>
<seealso>si:base64-encode</seealso>
<seealso>base64-decode-region-to-file</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>base64-decode-region-to-file</title>
<type>Function</type>
<arguments>filename from to</arguments>
<package>editor</package>
<description>
リージョンをBase64デコードしてファイルに保存します。
</description>
<seealso>si:base64-decode</seealso>
<seealso>base64-decode-region</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>uudecode-region</title>
<type>Function</type>
<arguments>from to</arguments>
<package>editor</package>
<description>
リージョンをuudecodeします。
</description>
<seealso>si:uudecode</seealso>
<seealso>uudecode-region-to-file</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>uudecode-region-to-file</title>
<type>Function</type>
<arguments>filename from to</arguments>
<package>editor</package>
<description>
リージョンをuudecodeしてファイルに保存します。
</description>
<seealso>si:uudecode</seealso>
<seealso>uudecode-region</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>quoted-printable-decode-region</title>
<type>Function</type>
<arguments>from to</arguments>
<package>editor</package>
<description>
リージョンをQuoted-Printableデコードします。
</description>
<seealso>si:quoted-printable-decode</seealso>
<seealso>quoted-printable-decode-region-to-file</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>quoted-printable-decode-region-to-file</title>
<type>Function</type>
<arguments>filename from to</arguments>
<package>editor</package>
<description>
リージョンをQuoted-Printableデコードしてファイルに保存します。
</description>
<seealso>si:quoted-printable-decode</seealso>
<seealso>quoted-printable-decode-region</seealso>
<section>リージョン</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>decode-mime-header</title>
<type>Function</type>
<arguments></arguments>
<description>
現在行から下にRFC822ヘッダを探してMIMEデコードします。
</description>
<seealso></seealso>
<section>その他</section>
<file>encdec.l</file>
</chapter>

<chapter>
<title>substitute-string</title>
<type>Function</type>
<arguments>substitute-string STRING PATTERN REPLACEMENT &amp;key :CASE-FOLD :START :END :SKIP :COUNT</arguments>
<package>editor</package>
<description>
文字列中のパターンを置換して返します。

使用例：
  ;;; 部分文字列を置換する。
  (substitute-string "Hogehoge" "ho" "pa")
  =&gt; "Hogepage"

  ;;; 大文字小文字を区別せず置換する。
  (substitute-string "Hogehoge" "ho" "pa" :case-fold t)
  =&gt; "pagepage"
</description>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>decode-escape-sequence</title>
<type>Function</type>
<arguments>decode-escape-sequence STRING REGEXPP</arguments>
<package>editor</package>
<description>
エスケープシーケンスをデコードします。

  STRING ：デコードするエスケープシーケンス
  REGEXPP：STRING が正規表現か否かを指定します。
  
使用例：
  ;;; [\thoge]という6文字をデコードして5文字にする。
  "\\thoge"
  =&gt; "\\thoge"
  (decode-escape-sequence "\\thoge" nil)
  =&gt; "  hoge"
  (length "\\thoge")
  =&gt; 6
  (length (decode-escape-sequence "\\thoge" nil))
  =&gt; 5
</description>
<seealso>[xyzzy:04201]</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>defmacro</title>
<type>Macro</type>
<arguments>defmacro NAME (&amp;rest LAMBDA-LIST) &amp;body BODY</arguments>
<package>lisp</package>
<description>
マクロを定義します。

使用例：
  ;;; cadrをマクロで定義し直した場合
  (defmacro cadr (x)
    (list 'car (list 'cdr x)))
  =&gt; cadr
  (macroexpand '(cadr y))
  =&gt; (car (cdr y))

参考：
  --- 亀井さんの説明 [xyzzy:03975] ---
  
  マクロは 2 回評価される関数みたいなものと思っていれば
  間違いないでしょう(ただし 1 回目の評価のときには引数の
  評価はされない)。ごく簡単な例をあげると、
  
    (defmacro foo ()
      '(+ 1 2))
  
  このように定義して (foo) を評価すると、1 回目の評価で
  (+ 1 2) が返り、それをさらに評価して 3 が返る、となり
  ます。引数がある場合も同様に、
  
    (defmacro bar (n)
      (list '+ 1 n))
  
    (bar 3)
    -&gt; (+ 1 3)
    =&gt; 4
  
  となります。
  
  | (M (any1) (any2) (any3)) と呼び出すと、
  |     (progn
  |       (m-setup)
  |       (any1)
  |       (any2)
  |       (any3)
  |       (m-cleanup))
  | と呼ばれるのと同じよう動作するものはどうしたら良いですか？
  
  この場合、引数が 3 つなので、こうなります。
  
    (defmacro M (a b c)
      (list 'progn '(m-setup) a b c '(m-cleanup)))
  
    (M (any1) (any2) (any3))
    -&gt; (progn (m-setup) (any1) (any2) (any3) (m-cleanup))
    =&gt; ?
  
  ふつ～、引数は何個でもありだろうってなときは、通常の関
  数と同様に &amp;rest で受けてやればいいわけですね。
  
    (defmacro M2 (&amp;rest args)
      (append '(progn) '((m-setup)) args '((m-cleanup))))
  
    (M2 (any1) (any2) (any3))
    -&gt; (progn (m-setup) (any1) (any2) (any3) (m-cleanup))
    =&gt; ?
  
  ちなみに、1 回目がどのように評価されているか(マクロの
  展開)を見るには macroexpand を使います。
  
    (macroexpand '(M2 (any1) (any2) (any3)))
    =&gt; (progn (m-setup) (any1) (any2) (any3) (m-cleanup))
  
  複雑なマクロ定義だと、list やら append やら cons やら 
  quote やらをごちゃごちゃ書くのがめんどくせ～、というわ
  けでテンプレートを使うことができます。詳しい説明は面倒
  なのでしませんが(^^; 上の例をテンプレートを使って書く
  とこのようになります。
  
    (defmacro M (a b c)
      `(progn
         (m-setup)
         ,a ,b ,c
         (m-cleanup)))
  
    (defmacro M2 (&amp;rest args)
      `(progn
         (m-setup)
         ,@args
         (m-cleanup)))
</description>
<seealso>macroexpand</seealso>
<seealso>``'(backquote)</seealso>
<section>マクロ</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>macroexpand</title>
<type>Function</type>
<arguments>macroexpand FORM &amp;optional ENV</arguments>
<package>System</package>
<description>
フォームがどのようにマクロ展開されるかを返します。
マクロの展開され方を確認するのに役立ちます。

使用例：
  ;;; マクロM2を定義してどのように展開
  (defmacro M2 (&amp;rest args)
      `(progn
         (m-setup) ,@args (m-cleanup)))
  (macroexpand '(M2 (insert "Begin") (insert "End")))
  =&gt; (progn (m-setup) (insert "Begin") (insert "End") (m-cleanup)) 
</description>
<seealso>defmacro</seealso>
<section>マクロ</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>``'(backquote)</title>
<type>Misc</type>
<arguments>form</arguments>
<package>???</package>
<description>
注：タイプはリードマクロなんですが・・・
　　info-modokiでどうしようか悩んでしまいます。

``'(逆引用符(backquote))はリストをquoteします。ただし、特別な標識 `,' 
及び `,@' を用いることで、リストの要素を選択的に評価することができます。

使用例：
  ;;; 逆引用符を使用してリストを作成
  (setq f0 '(0 1 2 3))         =&gt;  (0 1 2 3)  
  (setq f1 `(0 1 2 3))         =&gt;  (0 1 2 3)
  (setq f2 `(4 5 ,(car f1)))   =&gt;  (4 5 0)
  (setq f3 `(6 7 ,(cdr f1)))   =&gt;  (6 7 (1 2 3))
  (setq f4 `(8 9 ,@(cdr f1)))  =&gt;  (8 9 1 2 3)

参考：
  --- elisp-jpより引用 ---
  
  逆引用符の引数の中に特別な標識`,'を入れると、その値は定数でないことを表
  わします。逆引用符は`,'の引数を評価し、リスト構造にその値を入れます。
  
     (list 'a 'list 'of (+ 2 3) 'elements)
          =&gt; (a list of 5 elements)
     `(a list of ,(+ 2 3) elements)
          =&gt; (a list of 5 elements)
  
  特別な標識`,@'を用いることで、評価した値を結果のリストに"組み込む
  (splice)"こともできます。組み込まれたリストの要素は、結果のリストのほか
  の要素と同じレベルの要素になります。``'を使わない等価なコードは、往々に
  して読みにくくなります。例をあげます。
     (setq some-list '(2 3))
          =&gt; (2 3)
     (cons 1 (append some-list '(4) some-list))
          =&gt; (1 2 3 4 2 3)
     `(1 ,@some-list 4 ,@some-list)
          =&gt; (1 2 3 4 2 3)
</description>
<seealso></seealso>
<section>マクロ</section>
<file></file>
</chapter>

<chapter>
<title>map-backslash-to-slash</title>
<type>Function</type>
<arguments>STRING</arguments>
<package>editor</package>
<description>
文字列のバックスラッシュをスラッシュに置換して返します。

  STRING : 変換対象の文字列

使用例：
  ;;; パスを変換する。
  (map-backslash-to-slash "C:\\xyzzy\\xyzzy.exe")
  =&gt; "C:/xyzzy/xyzzy.exe"
</description>
<seealso>map-slash-to-backslash</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>map-slash-to-backslash</title>
<type>Function</type>
<arguments>STRING</arguments>
<package>editor</package>
<description>
文字列のスラッシュをバックスラッシュに置換して返します。

  STRING : 変換対象の文字列

使用例：
  ;;; パスを変換する。
  (map-slash-to-backslash "C:/xyzzy/xyzzy.exe")
  =&gt; "C:\\xyzzy\\xyzzy.exe"
</description>
<seealso>map-backslash-to-slash</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>butlast</title>
<type>Function</type>
<arguments>LIST &amp;optional (N 1)</arguments>
<package>lisp</package>
<description>
リストの最後のN要素分を除いたリストを返します。元のリストは変更されません。

使用例：
  ;;; 最後の要素を取り除く。
  (butlast '(1 2 3))
  =&gt; (1 2) 
  ;;; 最後の2要素を取り除く。
  (butlast '(1 2 3) 2)
  =&gt; (1) 
</description>
<seealso>nbutlast</seealso>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>nbutlast</title>
<type>Function</type>
<arguments>LIST &amp;optional (N 1)</arguments>
<package>lisp</package>
<description>
リストの最後のN要素分を除いたリストを返します。元のLISTも変更されます。

使用例：
  ;;; 最後の要素を取り除きます。
  (setq foo '(1 2 3))
  =&gt; (1 2 3)
  (nbutlast foo)
  =&gt; (1 2)
  foo
  =&gt; (1 2)
</description>
<seealso>butlast</seealso>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>file-name-dialog</title>
<type>Function</type>
<arguments>:CHAR-ENCODING :EOL-CODE :FILTER :FILTER-INDEX :TITLE :DEFAULT :EXTENSION :SAVE :MULTIPLE :MUST-EXIST :EXPLORER :HIDE-READ-ONLY :INITIAL-DIRECTORY</arguments>
<package>editor</package>
<description>
ファイルを指定するダイアログを表示します。
ユーザーが指定したファイルを返します。多値で返します。
（詳細不明）

  :char-encoding        文字コード指定プルダウンメニューを表示
  :eol-code             改行コード指定プルダウンメニューを表示
  :filter               ファイルの種類リスト
  :filter-index         （詳細不明）
  :title                ダイアログのタイトル
  :default              デフォルトのファイル名
  :initial-directory    初期表示するディレクトリ
  :extension            （詳細不明）
  :save                 non nilならファイル名を付けて保存？
  :multiple             non nilなら複数ファイル指定可
  :must-exist           non nilなら存在しないファイルを指定できない
  :explorer             （詳細不明）
  :hide-read-only       Read Onlyなファイルを表示しない？

使用例：
  ;;; タイトルをFooにして、複数選択可能なダイアログを表示する。
  (file-name-dialog :title "Foo"
                    :multiple t
                    :filter '(("すべてのﾌｧｲﾙ(*.*)" . "*.*")))
  =&gt; ("C:/applications/xyzzy/xyzzycli.exe")
</description>
<seealso>read-directory-name</seealso>
<section>ダイアログ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>connect</title>
<type>Function</type>
<arguments>HOSTNAME SERVICE &amp;key :ENCODING</arguments>
<package>editor</package>
<description>
ホストのポートとのTCP接続を開きます。
成功すれば接続へのストリームを返します。

参考：
  ;;; http://www.yahoo.co.jp/を取得してみる。
  (with-open-stream (stream (connect "www.yahoo.co.jp" 80))
    (format stream "GET / HTTP/1.0\n\n")
    (while (setq in (read-line stream nil))
      (insert in "\n")))
</description>
<seealso>open-network-stream</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>open-network-stream</title>
<type>Function</type>
<arguments>BUFFER HOSTNAME SERVICE &amp;key :INCODE :OUTCODE :EOL-CODE</arguments>
<package>editor</package>
<description>
ホストのポートとのTCP接続を開きます。
成功すれば接続をBUFFERのサブプロセスとして返します。

使用例：
  ;;; http://www.yahoo.co.jp/を取得してみる。
  (progn
    (defun filter (proc in) (insert in))
    (setq proc (open-network-stream (selected-buffer) "www.yahoo.co.jp" 80))
    (process-send-string proc "GET / HTTP/1.0\n\n")
    (set-process-filter proc 'filter))
  =&gt; HTTP/1.1 200 OK
     Server: ...
</description>
<section>システム</section>
<seealso>connect</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>yes-or-no-p</title>
<type>Function</type>
<arguments>FMT &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
「はい」「いいえ」のボタン付メッセージボックスを表示します。デフォルトは「はい」です。

  FMT  : format同様の書式が指定できます。
  ARGS : 出力書式へのパラメタとなります。

戻り値は以下のとおりです。

  t     「はい」を選択
  nil   「いいえ」を選択

使用例：
  ;;; ダイアログを表示して選択させる。
  (yes-or-no-p "foo")
  =&gt; t          ; 「はい」を選択
  (yes-or-no-p "~A" "hogehoge")  
  =&gt; nil        ; 「いいえ」を選択
</description>
<section>ダイアログ</section>
<seealso>no-or-yes-p</seealso>
<seealso>y-or-n-p</seealso>
<seealso>yes-no-or-cancel-p</seealso>
<file>misc.l</file>
</chapter>

<chapter>
<title>no-or-yes-p</title>
<type>Function</type>
<arguments>fmt &amp;rest args</arguments>
<package>lisp</package>
<description>
「はい」「いいえ」のボタン付メッセージボックスを表示します。
デフォルトは「いいえ」です。

  t     「はい」を選択
  nil   「いいえ」を選択

使用例：
  ;;; ダイアログを表示して選択させる。
  (no-or-yes-p "foo")
  =&gt; t          ; 「はい」を選択
</description>
<section>ダイアログ</section>
<seealso>yes-or-no-p</seealso>
<seealso>y-or-n-p</seealso>
<seealso>yes-no-or-cancel-p</seealso>
<file>misc.l</file>
</chapter>

<chapter>
<title>yes-no-or-cancel-p</title>
<type>Function</type>
<arguments>fmt &amp;rest args</arguments>
<package>lisp</package>
<description>
「はい」「いいえ」「キャンセル」のボタン付メッセージボックスを表示します。
デフォルトは「はい」です。「キャンセル」を選択した場合には、quitが実行されます。

  t     「はい」を選択
  nil   「いいえ」を選択

使用例：
  ;;; ダイアログを表示して選択させる。
  (yes-no-or-cancel-p "foo")
  =&gt; t          ; 「はい」を選択
  (yes-no-or-cancel-p "foo")
  =&gt; nil        ; 「いいえ」を選択
</description>
<section>ダイアログ</section>
<seealso>yes-or-no-p</seealso>
<seealso>no-or-yes-p</seealso>
<seealso>y-or-n-p</seealso>
<file>misc.l</file>
</chapter>

<chapter>
<title>y-or-n-p</title>
<type>Function</type>
<arguments>fmt &amp;rest args</arguments>
<package>lisp</package>
<description>
ミニバッファにメッセージを表示してユーザーが'y'か'n'を入力するのを待ちます。

  t     'y'を押下した
  nil   'n'を押下した

使用例：
  ;;; "Foo: (y or n) "と表示して選択させる。
  (y-or-n-p "Foo: ")
  =&gt; t          ; 'y'を押下
</description>
<section>ミニバッファ</section>
<seealso>yes-or-no-p</seealso>
<seealso>no-or-yes-p</seealso>
<seealso>yes-no-or-cancel-p</seealso>
<file>misc.l</file>
</chapter>

<chapter>
<title>current-window-configuration</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
現在のウィンドウの状態を返します。
ここでいうウィンドウの状態とは、画面の分割状態、表示されているバッファを
指します。ウィンドウの状態はset-window-configurationで設定することが出来
ます。

使用例：
  ;;; 画面の状態を元に戻す。
  (split-window)
  =&gt; t
  (setq winconf (current-window-configuration))
  =&gt; (window-configuration #&lt;window&gt; ......  
  (delete-other-windows)
  =&gt; t
  (set-window-configuration winconf)
</description>
<section>ウィンドウ</section>
<seealso>set-window-configuration</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-window-configuration</title>
<type>Function</type>
<arguments>CONF</arguments>
<package>editor</package>
<description>
取得しておいたウィンドウの状態に戻します。

  CONF：current-window-configurationで取得したウィンドウの状態
</description>
<section>ウィンドウ</section>
<seealso>current-window-configuration</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>reverse-region</title>
<type>Function</type>
<arguments>FROM TO &amp;optional TEMPORARY</arguments>
<package>editor</package>
<description>
リージョンを反転表示します。
TEMPORARYがnon nilならば、次のキー入力で反転表示が元に戻ります。
</description>
<section>リージョン</section>
<seealso>clear-reverse-region</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>clear-reverse-region</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
reverse-regionで反転表示した部分を元に戻します。
</description>
<section>リージョン</section>
<seealso>reverse-region</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>write-region</title>
<type>Function</type>
<arguments>FROM TO FILENAME &amp;optional APPEND CHAR-ENCODING EOL-CODE</arguments>
<package>editor</package>
<description>
リージョンをファイルに書き込みます。
APPENDがnon nilなら追加書き込みをします。
</description>
<section>ファイルシステム</section>
<seealso></seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert-buffer</title>
<type>Function</type>
<arguments>BUFFER</arguments>
<package>editor</package>
<description>
指定されたバッファの内容を現在のバッファに挿入します。
</description>
<section>バッファ</section>
<seealso>insert-buffer-substring</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert-buffer-substring</title>
<type>Function</type>
<arguments>BUFFER &amp;optional FROM TO</arguments>
<package>editor</package>
<description>
指定されたバッファの内容を現在のバッファに挿入します。
リージョンが指定されていればその領域を挿入します。
</description>
<section>バッファ</section>
<seealso>insert-buffer</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>completing-read</title>
<type>Function</type>
<arguments>PROMPT COMPLETIONS &amp;key :CASE-FOLD :DEFAULT :HISTORY :MUST-MATCH</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーの入力を読み取ります。

  PROMPT      : 表示するプロンプト
  COMPLETIONS : 補完入力のためのリスト
  :case-fold  : non nilなら大文字小文字を区別しない
  :default    : 初期値の指定
  :history    : ヒストリに使用するリストを指定
  :must-match : non nilならcompletions以外受け付けない
</description>
<section>ミニバッファ</section>
<seealso>read-string</seealso>
<seealso>interactive</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>next-page</title>
<type>Function</type>
<arguments>ARG</arguments>
<package>editor</package>
<description>
指定ページ分画面を下スクロールします。
*page-scroll-half-window*がnon nilなら半画面ずつスクロールします。
</description>
<section>ウィンドウ</section>
<seealso>previous-page</seealso>
<file>page.l</file>
</chapter>

<chapter>
<title>previous-page</title>
<type>Function</type>
<arguments>ARG</arguments>
<package>editor</package>
<description>
指定ページ分画面を上スクロールします。
*page-scroll-half-window*がnon nilなら半画面ずつスクロールします。
</description>
<section>ウィンドウ</section>
<seealso>next-page</seealso>
<file>page.l</file>
</chapter>

<chapter>
<title>*page-scroll-half-window*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
next-page/previous-pageのスクロールの単位を半画面ずつにするか制御します。

  t     半画面ずつスクロール
  nil   一画面ずつスクロール
</description>
<section>ウィンドウ</section>
<seealso>next-page</seealso>
<seealso>previous-page</seealso>
<file>page.l</file>
</chapter>

<chapter>
<title>read-string</title>
<type>Function</type>
<arguments>PROMPT &amp;key :DEFAULT :HISTORY</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーが文字列を入力するのを待ちます。
ユーザーの入力した文字列を返します。
  
  :default      初期値とする文字列
  :history      ヒストリのリスト

使用例：
  ;;; ミニバッファからURLを入力する。
  (read-string "URL: ")
  =&gt; "http://www.yahoo.co.jp"
</description>
<seealso>read-integer</seealso>
<section>ミニバッファ</section>
</chapter>

<chapter>
<title>read-integer</title>
<type>Function</type>
<arguments>PROMPT</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーが数値を入力するを待ちます。
ユーザーの入力を数値として返します。

使用例：
  ;;; ミニバッファから数値を読み取る。
  (read-integer "num: ")
  =&gt; 123
</description>
<seealso>read-string</seealso>
<section>ミニバッファ</section>
</chapter>

<chapter>
<title>read-file-name</title>
<type>Function</type>
<arguments>PROMPT &amp;key :DEFAULT :TITLE</arguments>
<package>editor</package>
<description>
ミニバッファにプロンプトを表示してユーザーがファイル名を入力するのを待ちます。
入力中はTABキーでファイル名を補完できます。 
"~"はユーザーのホームディレクトリに、".."は親ディレクトリに変換されます。
ユーザーの入力したファイル名を返します。
  
  :default 初期表示するファイル名

使用例：
  ;;; ミニバッファからファイル名を読み取る。
  (read-file-name "filename: ")
  =&gt; "C:/applications/xyzzy/xyzzy.exe"
</description>
<seealso>read-directory-name</seealso>
<section>ファイルシステム</section>
</chapter>

<chapter>
<title>read-directory-name</title>
<type>Function</type>
<arguments>PROMPT &amp;key :DEFAULT :TITLE</arguments>
<package>editor</package>
<description>
ミニバッファにをプロンプトを表示してユーザーがディレクトリ名を入力するの
を待ちます。
  
  :default 初期表示するディレクトリ名

入力中はTABキーでディレクトリ名を補完できます。
"~"はユーザーのホームディレクトリに、".."は親ディレクトリに変換されます。
ユーザーの入力したディレクトリ名を返します。

使用例：
  ;;; ミニバッファからディレクトリ名を読み取る。
  (read-directory-name "directory: ")
  =&gt; "C:/applications/xyzzy/etc"
</description>
<seealso>read-file-name</seealso>
<seealso>directory-name-dialog</seealso>
<section>ファイルシステム</section>
</chapter>

<chapter>
<title>directory-name-dialog</title>
<type>Function</type>
<arguments>&amp;key :TITLE :DEFAULT</arguments>
<description>
ディレクトリを指定するダイアログを表示します。
ユーザーが指定したディレクトリを返します。
  
  :title ダイアログのタイトル
  :default 初期表示するディレクトリ

使用例：
  ;;; ミニバッファからディレクトリ名を読み取る。
  (directory-name-dialog)
  =&gt; "C:/applications/xyzzy/site-lisp"
</description>
<seealso>read-directory-name</seealso>
<section>ダイアログ</section>
</chapter>

<chapter>
<title>clear-all-text-attributes</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
set-text-attributeで設定した属性を全部消します
</description>
<seealso>delete-text-attributes</seealso>
<section>システム</section>
</chapter>

<chapter>
<title>delete-text-attributes</title>
<type>Function</type>
<arguments>TAG &amp;key :TEST :TEST-NOT :KEY</arguments>
<package>editor</package>
<description>
set-text-attributeで指定したタグの属性を消します
</description>
<seealso></seealso>
<section>システム</section>
</chapter>

<chapter>
<title>find-text-attribute</title>
<type>Function</type>
<arguments>TAG &amp;key :TEST :TEST-NOT :KEY</arguments>
<package>editor</package>
<description>
set-text-attributeで指定したタグを検索します。

(progn
  (set-text-attribute 1 6 'my-tag 1)
  (multiple-value-bind (from to tag)
      (find-text-attribute 'my-tag)
    (format t "~d, ~d, ~A" from to tag)))
==&gt; 1, 6, my-tag

| 2. set-text-attribute で、複数範囲に同一 tag を指定した場
|    合、find～ は一番先頭に近いものしか返さない(ところしか
|    見たことがない)のですが、二番目以降を取得することはで
|    きますでしょうか？

find-text-attribute TAG :start POS

で、POS に現在位置+1を与えれば次のが返ってくる予定です。
使ったことないので動くかどうか分かりませんが。

| 3. find-text-attribute の &amp;key 引数は、何か意味を持ってい
|    ますでしょうか？

シーケンスと同様に、:test と :test-not には比較関数を
与えます。また、:key にはアクセス関数(か?)を与えます。
たとえば、tag の形式が

  ("foo" bar)

である場合、

  (find-text-attribute "foo" :test #'equal :key #'car)

とか、

  (find-text-attribute 'bar :test #'eq :key #cadr)

で検索することができる予定です。使ったことないので動く
かどうか分かりませんが。

:test-not は、関数が nil を返した場合に真とする以外は :
test と同様です。:test と :test-not は同時に指定するこ
とはできず、省略した場合は :test #'eql が与えられたも
のとします。また :key を省略した場合は :key #'identity 
が与えられたものとします(たぶん)。
</description>
<seealso></seealso>
<section>システム</section>
</chapter>


<chapter>
<title>with-open-stream</title>
<type>Macro</type>
<arguments>(VAR STREAM) &amp;body BODY</arguments>
<package>lisp</package>
<description>
出力ストリームを開きます。

--- 原文 ---
evaluates the form stream to return a stream with dynamic extent. The 
value of the stream is bound to var, and then the body forms are 
evaluated as an implicit progn. The value of with-open-stream is that of 
the last form evaluated. On termination, whether normal or otherwise, 
the stream is closed by close.

--- 意訳 ---
STREAMのフォームを評価して動的エクステントのストリームを返します。返され
たストリームの値はVARに束縛されます。そして、BODYのフォームは暗黙のprogn
の中で評価されます。with-open-streamの値は、最後のBODYのフォームのものに
なります。正常終了か否かにかかわらず、終了時にストリームはクローズされます。

参考：
  connectの例を参照のこと
</description>
<seealso></seealso>
<section>システム</section>
</chapter>

<chapter>
<title>create-shortcut</title>
<type>Function</type>
<arguments>SRC DEST &amp;rest REST</arguments>
<package>editor</package>
<description>
ショートカットを作成します。

  SRC ：ショートカットが指すパスを指定します。
  DEST：ショートカットを作成するパスを指定します。
  DIR ：ショートカットを作成するパスを指定します。

使用例：
  ;;; スタートメニューにショートカットを作成する。
  (create-shortcut (merge-pathnames "xyzzy.exe" (si:system-root)) (get-special-folder-location :start-menu))
  =&gt; t
  (delete-file (merge-pathnames "xyzzy.exe.lnk" (get-special-folder-location :start-menu)))
  =&gt; t

  ;;; 送るメニューにxyzzyを登録する。
  (create-shortcut (merge-pathnames "xyzzy.exe" (si:system-root)) (get-special-folder-location :send-to))
  =&gt; t
  (delete-file (merge-pathnames "xyzzy.exe.lnk" (get-special-folder-location :send-to)))
  =&gt; t
</description>
<seealso>resolve-shortcut</seealso>
<section>ファイルシステム</section>
</chapter>

<chapter>
<title>set-text-attribute</title>
<type>Function</type>
<arguments>FROM TO TAG &amp;key :FOREGROUND :BACKGROUND :BOLD :UNDERLINE :STRIKE-OUT :PREFIX :EXTEND</arguments>
<package>editor</package>
<description>
リージョンに色などの属性を付けます。
付けた属性はdelete-text-attributeで消せます。
一括して消す場合には、clear-all-text-attributesを使用します。

  FROM          属性を付加する開始位置
  TO            属性を付加する終了位置
  TAG           個々の属性を区別するタグ
  :BOLD         ボールドで表示するかどうかを
  :UNDERLINE    下線付きで表示するかどうかを
  :STRIKE-OUT   取り消し線を表示するかどうか
  :FOREGROUND   文字色を整数で指定
  :BACKGROUND   背景色を整数で指定
  :PREFIX       使い方は不明
  :EXTEND       行末の改行文字以降も変えるかどうか

色の整数について：
  [ツール]-[共通設定]-[フォント]のところにある表示色になります。

  :FOREGROUND 0     : 文字色
              1～15 : 文字1～文字15
  :BACKGROUND 0     : 背景色
              1～15 : 背景1～背景15

  15 より大きい値を指定すると，0～15 の色が繰り返されます。

使用例：
  ;;; バッファ全体を文字1の色にする。
  (set-text-attribute (point-min) (point-max) 'all :bold t :foreground 1)
  =&gt; t
  (delete-text-attributes 'all)
  =&gt; t
</description>
<seealso>modify-text-attributes</seealso>
<seealso>set-text-color</seealso>
<seealso>find-text-attribute</seealso>
<section>テキスト</section>
</chapter>

<chapter>
<title>modify-text-attributes</title>
<type>Function</type>
<arguments>TAG &amp;key :FOREGROUND :BACKGROUND :BOLD :UNDERLINE :STRIKE-OUT :PREFIX :EXTEND :START :END :TEST :TEST-NOT :KEY</arguments>
<package>editor</package>
<description>
set-text-attributeで付けた領域の属性を変更します。
属性は引き継がれません。
例えば、set-text-attributeでは:underline tとしてから、
modify-text-attributeで:strike-out tとしても、
下線と取り消し線の両方が表示される訳ではありません。

  TAG           set-text-attributeで指定したタグ
  :BOLD         ボールドで表示するかどうか
  :UNDERLINE    下線付きで表示するかどうか
  :STRIKE-OUT   取り消し線を表示するかどうか
  :FOREGROUND   文字色を整数で指定
  :BACKGROUND   背景色を整数で指定
  :PREFIX       使い方は不明
  :EXTEND       行末の改行文字以降も変えるかどうか

使用例：
  ;;; バッファ全体をに下線を付けてから取り消し線にする。
  (set-text-attribute (point-min) (point-max) 'all :bold t :foreground 1)
  =&gt; t
  (modify-text-attributes 'all :strike-out t)
  =&gt; t
  (delete-text-attributes 'all)
  =&gt; t
</description>
<seealso>set-text-attribute</seealso>
<seealso>set-text-color</seealso>
<section>テキスト</section>
</chapter>

<chapter>
<title>mark</title>
<type>Function</type>
<arguments>&amp;optional FORCE</arguments>
<package>editor</package>
<description>
マークの位置を数値で返します。

  FORCE：マークが設定されていない場合に処理を継続するか？
        t       エラーとしない、関数はnilを返す
        nil     エラーとする
</description>
<seealso></seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>minibuffer-prompt</title>
<type>Function</type>
<arguments>FMT &amp;rest ARGS</arguments>
<package>editor</package>
<description>
書式に従ってミニバッファにメッセージを表示します。
その後read-charを使ってキーボードから文字を読み込めば、
凝ったミニバッファからの入力が可能になります。

  FMT  : format同様の書式が指定できます。
  ARGS : 出力書式へのパラメタとなります。

使用例：
  ;;; 以下のようにすると、パスワード入力のようにエコーバックしない。
  minibuffer入力が可能
  (defun test1 ()
    (interactive)
    (let ((ans ""))
      (loop
        (minibuffer-prompt "From ~d: " 12)
        (let ((c (read-char *keyboard*)))
          (case c
            (#\RET (return ans))
            (#\C-g (quit))
            (t (setq ans (format nil "~a~c" ans c))))))))  

参考：
  wip/ftp.lのgetpass
</description>
<seealso></seealso>
<section>ミニバッファ</section>
<file></file>
</chapter>


<chapter>
<title>copy-selection-to-clipboard</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
選択範囲をクリップボードに転送します。

使用例：
  ;;; 1. いったんJISに変換して保存
  ;;; 2. [ファイル]-[開く]で漢字コードを[シフトJIS]にして開く
  ;;;    （またはメモ帳などで開く？）
  ;;; 3. 選択してコピー
  (defun tojiscopy ()
    (interactive)
    (let ((ocode *kanji-expected-code*)
          (tempfile (concat (default-directory) "tempfile.txt")))
      (save-excursion
        (set-buffer-kanji-fileio-code 1)
        (write-region (point-min) (point-max) tempfile nil)
        (switch-to-buffer "*JIS*"))
      (pop-to-buffer "*JIS*")
      (setq *kanji-expected-code* 0)
      (find-file tempfile)
      (setq *kanji-expected-code* ocode)
      (selection-whole-buffer)
      (copy-selection-to-clipboard)))
</description>
<seealso></seealso>
<section>リージョン</section>
<file></file>
</chapter>

<chapter>
<title>local-unset-key</title>
<type>Function</type>
<arguments>KEY</arguments>
<package>editor</package>
<description>
ローカルキーマップのキー割り当てを解除します。

使用例：
  ;;; lisp-modeのTABのローカルキーマップを外す。
  (lookup-key-command #\TAB)
  =&gt; lisp-indent-line
  (local-unset-key #\TAB)
  =&gt; t
  (lookup-key-command #\TAB)
  =&gt; self-insert-command
</description>
<seealso></seealso>
<section>キーマップ</section>
<file></file>
</chapter>

<chapter>
<title>si:getenv</title>
<type>Function</type>
<arguments>VARIABLE</arguments>
<package>system</package>
<description>
環境変数の値を取り出します。

  VARIABLE：環境変数名

使用例：
  ;;; 環境変数PATHを取り出して、個々のPATHに分割する。
  (split-string (si:getenv "PATH") #\;)
  =&gt; ("c:\\usr\\local\\bin" "C:\\WINNT\\system32" "C:\\WINNT" ...)
</description>
<section>システム</section>
<file></file>
</chapter>

<chapter>
<title>make-list-from-keyword-table</title>
<type>Function</type>
<arguments>HASH</arguments>
<package>editor</package>
<description>
キーワードハッシュテーブルから補完用のリストを作成します。

  HASH：キーワードハッシュテーブル(*xxxx-keyword-hash-table*)を指定

使用例：
  ;;; CSSのキーワードハッシュテーブルを元に
  ;;; 補完用リストを作成して、do-completionする。
  (defun css-completion ()
    (interactive)
    (or *css-completion-list*
        (setq *css-completion-list* (make-list-from-keyword-table *css-keyword-hash-table*))
        (return-from css-completion nil))
    (let ((opoint (point)))
      (when (skip-syntax-spec-backward "w_")
        (let ((from (point)))
          (goto-char opoint)
          (do-completion from opoint :list-ignore-case *css-completion-list*)))))
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>kwd.l</file>
</chapter>

<chapter>
<title>vector-push-extend</title>
<type>Function</type>
<arguments>NEW-ELEMENT VECTOR &amp;optional EXTENSION</arguments>
<package>lisp</package>
<description>
ベクタに新しい要素を追加します。長さが足りなければ拡張します。

  NEW-ELEMENT：新しい要素 
  VECTOR     ：追加するベクタ
  EXTENSION  ：拡張するかどうか

使用例：
  ;;; 文字を要素とする長さ10のベクタを作成し文字を詰める。
  (setq *stream* (make-vector 10 :element-type 'character
                                 :fill-pointer 0 :adjustable t))
  =&gt; ""
  (vector-push-extend #\a *stream*)  =&gt; 0
  *stream*                           =&gt; "a"
  (vector-push-extend #\b *stream*)  =&gt; 1
  *stream*                           =&gt; "ab"

  ;;; 文字を要素とする長さ10のベクタを作成し文字を詰める。
  (setq s (make-vector 10 :element-type 'character
                          :fill-pointer 0 :adjustable t))
  =&gt; ""
  (dotimes (i 20)
    (vector-push-extend (code-char (+ 64 i)) s)
    (vector-push-extend (code-char (+ 64 i)) s)
    (vector-push-extend (code-char (+ 64 i)) s))
  =&gt; "@@@AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSS"
</description>
<seealso>vector</seealso>
<section>配列</section>
<file></file>
</chapter>

<chapter>
<title>format</title>
<type>Function</type>
<arguments>DESTINATION CONTROL-STRING &amp;rest ARGUMENTS</arguments>
<package>lisp</package>
<description>
出力書式に従って出力します。

  destination : 出力先を指定します。
        t       標準出力に出力
        nil     文字列として結果を返す
        fp      指定のストリームに出力

  control-string : 以下の出力指定子で整形します。
        ~A      Ascii（アスキー指示）。princタイプで出力。
        ~S      S-Expression（S式指示）。prin1タイプで出力。
        ~%      改行。~n%はn個の改行
        ~&amp;      出力ストリームが行頭でなければ改行。fresh-line参照。
        ~|      改ページ
        ~~      Tilde（チルダ指示）
        ~改行   改行とそれに続く空白文字を無視する
        ~T      Tabulate（タブ指示）
        ~*      次のargumentを無視
        ~?      Indirection（間接指示）
        ~D      10進数
        ~B      Binary（2進指示）
        ~O      Octal（8進指示）
        ~X      Hexadecimal（16進指示）
        ~R      Radix（基数指示）
        ~P      Plural（複数形指示）
        ~C      Character（文字指示）
        ~F      Fixed-format floating-point（固定小数点形式浮動小数指示）
        ~E      Exponential floating-point（指数形式浮動小数指示）
        ~G      General floating-point（一般浮動小数点指示）
        ~$      Dollars floating-point（ドル浮動小数点指示）
        ~(      Case conversion（ケース変換指示）
        ~)      ~(を閉じる
        ~[      Conditional expression（条件選択指示）
        ~]      ~[を閉じる
        ~{      Iteration（反復指示）
        ~}      ~{を閉じる
        ~^      Up and out（ゼロ終了指示）

使用例:
  ;;; 整数に0を付けて出力 ("~[最小桁数][,パディング文字][,桁区切り文字]D")
  (format nil "~5,'0D" 4)
  =&gt; "00004"

  ;;; 整数を3桁ごとにカンマで区切って出力
  (format nil "~:D" 1234567890)
  =&gt; "1,234,567,890"

  ;;; 文字列を最低桁カラムになるように空白を追加して出力
  (format nil "~10A" "foo")
  =&gt; "       foo"
  (format nil "~10@A" "foo")
  =&gt; "foo       "

  ;;; ケース変換の例
  (format nil "~(~A~)" "FOO BAR")  ;全て小文字
  =&gt; "foo bar"
  (format nil "~:(~A~)" "foo bar") ;単語の先頭の文字を大文字
  =&gt; "Foo Bar"
  (format nil "~@(~A~)" "foo bar") ;先頭の文字を大文字
  =&gt; "Foo bar"
  (format nil "~:@(~A~)" "foo bar");全て大文字
  =&gt; "FOO BAR"

  ;;; 間接指示の例
  (format nil "~? ~D" "[~A ~D]" '("foo" 2) 3)
  =&gt; "[foo 2] 3"
  (format nil "~@? ~D" "[~A ~D]" "foo" 2 3)
  =&gt; "[foo 2] 3"

  ;;; 条件選択指示の例
  (format nil "Windows ~[NT~;98~;95~]" 0)
  =&gt; "Windows NT"
  (format nil "Windows ~[NT~;98~;95~]" 1)
  =&gt; "Windows 98"
  ;デフォルト値 "~:;"
  (format nil "Windows ~[NT~;98~;95~:;3.1~]" 5)
  =&gt; "Windows 3.1"

  ;;; 反復指示の例
  ; "~{" 引数はリスト
  (format nil "~{ ~A~}" '("dog" "cat" "pig"))
  =&gt; " dog cat pig"
  ; "~:{"  引数はリストのリスト
  (format nil "~:{[~A ~D]~}" '(("a" 1) ("b" 2) ("c" 3)))
  =&gt; "[a 1][b 2][c 3]"
  ; "~@{" 残りの引数をリストとして用いる
  (format nil "~@{[~A ~D]~}" "a" 1 "b" 2 "c" 3)
  =&gt; "[a 1][b 2][c 3]"
  ; "~@:{" 引数のリストをリストとして用いる
  (format nil "~:@{[~A ~D]~}" '("a" 1) '("b" 2) '("c" 3))
  =&gt; "[a 1][b 2][c 3]"

  ;;; ゼロ終了指示の例
  ;引数がなければ終了
  (format nil "Done.~^ ~D warning~:P.~^ ~D error~:P.")
  =&gt; "Done."
  (format nil "Done.~^ ~D warning~:P.~^ ~D error~:P." 3)
  =&gt; "Done. 3 warnings."
  (format nil "Done.~^ ~D warning~:P.~^ ~D error~:P." 3 5)
  =&gt; "Done. 3 warnings. 5 errors."

  ;;; 反復指示とゼロ終了指示
  ;副リストの中の引数がもうなければ "~{" をそこで閉じる
  (format nil "~:{/~S~^ ...~}" '((hot dog) (hamburger) (ice cream) (french fries)))
  =&gt; "/hot .../hamburger/ice .../french ..."
  ;リストが終わりならそこで ":{" 全体を終了
  (format nil "~:{/~S~:^ ...~}" '((hot dog) (hamburger) (ice cream) (french fries)))
  =&gt; "/hot .../hamburger .../ice .../french"
  ;副リストの中の引数がもうなければ全体を終了
  (format nil "~:{/~S~#:^ ...~}" '((hot dog) (hamburger) (ice cream) (french fries)))
  =&gt; "/hot .../hamburger"

  ;;; 16進数のformat書式の書き方
  (format nil "~2,'0x" 10)
  =&gt; "0a"
  (format nil "~:@(~2,'0x~)" 10)
  =&gt; "0A"
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>eolp</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
カーソルが行末にあるかどうか調べます。

  t     カーソルが行末にある
  nil   カーソルは行末にはない
</description>
<seealso>bolp</seealso>
<section>ポジション</section>
<file></file>
</chapter>

<chapter>
<title>set-window</title>
<type>Function</type>
<arguments>WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウを変更します。
selected-windowやget-buffer-windowで取得したウィンドウに移動します。

  WINDOW：移動先のウィンドウ

使用例：
  ;;; *scratch*が表示されていれば移動する。
  (setq win (get-buffer-window (find-buffer "*scratch*")))
  =&gt; #&lt;window 48436204&gt;
  (if win (set-window win))
  =&gt; t
(set-window win)
</description>
<seealso></seealso>
<section>ウィンドウ</section>
<file></file>
</chapter>

<chapter>
<title>add-file-history-to-menu</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイルメニューの履歴のところに履歴を記録する？
（詳細不明）
(add-file-history-to-menu)
</description>
<seealso></seealso>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>minibuffer-window-p</title>
<type>Function</type>
<arguments>WINDOW</arguments>
<package>editor</package>
<description>
ウィンドウがミニバッファかどうかを返します。

  WINDOW：ミニバッファかどうかを調べるウィンドウ 

  t     ミニバッファである
  nil   ミニバッファではない

使用例：
  ;;; ミニバッファでは別のバッファに変更できないので別のウィンドウに移動する。
  (if (minibuffer-window-p (selected-window))
      (other-window))
  =&gt; t
</description>
<seealso></seealso>
<section>ミニバッファ</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>minibuffer-window</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファのウインドウを取得します。

使用例：
  ;;; ミニバッファに移動する。
  (set-window (minibuffer-window)))
</description>
<seealso></seealso>
<section>ミニバッファ</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>set-mark-command</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
マークを設定します。
ビルトイン関数のset-markを対話に行うためのものです。

使用例：
  ;;; マークを設定してその位置を取得する。
  (set-mark-command)
  =&gt; t
  (mark)
  =&gt; 2554
</description>
<seealso></seealso>
<section>バッファ</section>
</chapter>

<chapter>
<title>transpose-region</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
（詳細不明）

使用例：
  (transpose-region 'forward-paragraph arg)
</description>
<seealso></seealso>
<section>リージョン</section>
<file></file>
</chapter>

<chapter>
<title>start-selection</title>
<type>Function</type>
<arguments>TYPE &amp;optional TEMPORARY POINT</arguments>
<package>editor</package>
<description>
選択領域の範囲指定を開始します。

  TYPE：選択領域の範囲指定の方法を指定します。 
        1の場合         範囲選択を行で行います。
        2の場合         範囲選択を文字で行います。
        3の場合         範囲選択を矩形で行います。

  TEMPORARY：一時的なものかどうかを指定します。
        tの場合         キー入力されると範囲指定を解除します。
        nilの場合       カーソル移動に応じて範囲を変更します。

使用例：
  ;;; 矩形で範囲指定する。
  (start-selection 3 nil)
  =&gt; t
</description>
<seealso></seealso>
<section>リージョン</section>
<file></file>
</chapter>

<chapter>
<title>rotatef</title>
<type>Macro</type>
<arguments>&amp;rest ARGS &amp;environment ENV</arguments>
<package>lisp</package>
<description>
引数として与えられた値の格納場所の内容をローテーションさせます。
(rotatef a b c d)とすると以下のようになります。

        ┌a ┐  ┌b ┐  ┌c ┐
実行前：│ 1│  │ 2│  │ 3│
        └┬┘  └┬┘  └┬┘
      ┌─┘  ┌─┘  ┌─┘
   (*)┘  ┌─┘  ┌─┘  ┌─(*)
          ↓      ↓      ↓
        ┌a ┐  ┌b ┐  ┌c ┐
実行後：│ 2│  │ 3│  │ 1│
        └─┘  └─┘  └─┘

--- 原文 ---
Description: similar to shiftf except that the value accessed by the 
form place1 is not discarded. Instead it is assigned to the location 
accessed by the form placeN. Therefore, the list of place forms is 
treated like a circular register that is rotated by one position. 
Returns nil As in the case of setf and psetf, the ANSI standard 
specifies that one can rotatef more than one value to a place which has 
more than one store variable and which has an appropriately defined 
setf-method.

--- 意訳 ---
1番目のフォームによって参照される値が捨てられないことを除いてshiftfと同
じです。その代わりに、N番目のフォームによって参照される位置に、1番目のフ
ォームによって参照される値が設定されます。そのため、フォームのリストは環
状のレジスタとして扱われます。setfとpsetfによってはnilを返す場合がありま
すが、ANSIでは、setfにより適切に定義されたひとつ以上の格納用の変数に値を
入れるようにrotatefができると定められています。

使用例：
  ;;; a b cに数値を入れてrotatefする。
  (setq a 1 b 2 c 3)    =&gt; 3
  (list a b c)          =&gt; (1 2 3)
  (rotatef a b c)       =&gt; 1
  (list a b c)          =&gt; (2 3 1)
</description>
<seealso>setf</seealso>
<seealso>shiftf</seealso>
<section>変数と定数</section>
<file>setf.l</file>
</chapter>

<chapter>
<title>subtypep</title>
<type>Function</type>
<arguments>TYPE1 TYPE2</arguments>
<package>lisp</package>
<description>
ある型が他の型の副型かどうか調べて多値で返します。
（詳細不明）

  TYPE1 : 副型を指定します。
  TYPE2 : 型を指定します。

  t   t         TYPE1は明確にTYPE2の副型
  nil t         TYPE1は明確にTYPE1の副型ではない
  nil nil       関係を判断できない

使用例：
  ;;; サブタイプかどうかを調べる。
  (subtypep 'single-float 'number)
  =&gt; (single-float double-float long-float)
  (subtypep 'cons 'number)
  =&gt; nil
</description>
<seealso></seealso>
<section>データ型</section>
<file></file>
</chapter>

<chapter>
<title>defstruct</title>
<type>Macro</type>
<arguments>NAME-AND-OPTIONS &amp;rest REST</arguments>
<package>lisp</package>
<description>
構造体を定義します。C言語のstruct文に相当します。
オプションとして以下のものを指定できるようですが、詳細は不明。

  :conc-name            （詳細不明）
  :constructor          コンストラクタを指定する
  :copier               コピー関数を指定する
  :predicate            指定された構造体であるか否かを調べる関数を指定する。
  :include              （詳細不明）
  :type                 （詳細不明）
  :named                （詳細不明）
  :print-function       （詳細不明）
  :initial-offset       （詳細不明）

特にオプション指定しないとmake-xxxx, copy-xxxx, xxxx-pという関数が作られ
るようです。

  make-xxxx     デフォルトのコンストラクタ
  copy-xxxx     デフォルトのコピー関数
  xxxx-p        指定された構造体であるか否かを調べる関数

定義：
  ;;; struct.lの定義
  (defmacro defstruct (name-and-options &amp;rest rest)
    (eval-when (:compile-toplevel :load-toplevel :execute)
      (defstruct-helper name-and-options rest)))

使用例：
  ;;; FTPサーバを表す構造体の場合
  ;;; 初期値を予め指定することも可能
  (defstruct ftpsvr anonymous hostname (port 80))
  =&gt; #&lt;structure-definition: ftpsvr&gt;
  (setq f1 (make-ftpsvr))
  =&gt; #S(ftpsvr anonymous nil hostname nil port 80)
  (setq f2 (make-ftpsvr  :anonymous t :hostname "ftp.world.com"))
  =&gt; #S(ftpsvr anonymous t hostname "ftp.world.com" port 80)
  (setq f3 #S(ftpsvr anonymous nil hostname "localhost"))
  =&gt; #S(ftpsvr anonymous nil hostname "localhost" port 80)
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>struct.l</file>
</chapter>

<chapter>
<title>overwrite-char</title>
<type>Function</type>
<arguments>C &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
文字を上書きします。

使用例：
  ;;; 半角空白で上書きする。
  (overwrite-char #\SPC)
  =&gt; t
</description>
<seealso></seealso>
<section>テキスト</section>
<file></file>
</chapter>

<chapter>
<title>logand</title>
<type>Function</type>
<arguments>&amp;rest ARGS</arguments>
<package>lisp</package>
<description>
ビット毎のANDを取ります。C言語でいう&amp;です。

使用例：
  ;;; 2進数で#b11110000と#b00110011のビットの積を取る。
  (format nil "~8,'0b" (logand #b11110000 #b00110011))
  =&gt; "00110000"
(logand x #xf)
</description>
<seealso>logior</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>logior</title>
<type>Function</type>
<arguments>&amp;rest ARGS</arguments>
<package>lisp</package>
<description>
ビット毎のORを取ります。C言語でいう|です。

使用例：
  ;;; 2進数で#b00110000と#b00000011のビットの和を取る。
  (format nil "~8,'0b" (logior #b00110000 #b00000011))
  =&gt; "00110011"
</description>
<seealso>logand</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>following-char</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
カーソルがある位置のキャラクタを返します。
バッファの末尾にカーソルがある場合には、#\NULを返します。

使用例：
  ;;; "長崎市"の'崎'の上にカーソルがある場合
  (following-char)
  =&gt; #\崎

  ;;; [EOF]にカーソルがある場合
  (following-char)
  =&gt; #\NUL
(following-char)
</description>
<seealso>preceding-char</seealso>
<section>テキスト</section>
</chapter>

<chapter>
<title>eobp</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
ポイントがバッファの最後にあるかどうか調べます。

使用例：
  ;;; バッファの最後までカーソルをひとつひとつ進める？
  (while (not (eobp))
    (forward-char))
</description>
<seealso>bobp</seealso>
<section>ポジション</section>
<file></file>
</chapter>

<chapter>
<title>delete-char</title>
<type>Function</type>
<arguments>&amp;optional N</arguments>
<package>editor</package>
<description>
指定文字数分だけ削除します。
</description>
<seealso></seealso>
<section>テキスト</section>
<file></file>
</chapter>

<chapter>
<title>princ</title>
<type>Function</type>
<arguments>princ OBJECT &amp;optional STREAM</arguments>
<package>lisp</package>
<description>
オブジェクトをストリームに出力します。

  OBJECT : 出力するオブジェクトを指定します。
  STREAM : ストリームを指定します。

STREAMを省略されたときは、標準出力に出力します。prin1での出力とよく似て
いますが、エスケープ文字を出力しないことや文字列が引用符で囲まれない点が
異なります。
※CLtL2(Common Lisp the Language, 2nd edition)によると人間に読み易いよう
  に意図しているそうです。

使用例：
  ;;; princとprin1の出力の違い
  (princ "abc") =&gt; abc  (prin1 "abc") =&gt; "abc"
  (princ #\a)   =&gt; a    (prin1 #\a)   =&gt; #\a
</description>
<seealso>prin1</seealso>
<section>入出力</section>
</chapter>

<chapter>
<title>prin1</title>
<type>Function</type>
<arguments>obj &amp;optional output-stream</arguments>
<package>lisp</package>
<description>
オブジェクトをストリームに出力します。

  OBJECT : 出力するオブジェクトを指定します。
  STREAM : ストリームを指定します。

STREAMを省略されたときは、標準出力に出力します。princでの出力とよく似て
いますが、エスケープ文字を出力することや文字列が引用符で囲まれる点が異な
ります。

使用例：
  ;;; princとprin1の出力の違い
  (princ "abc") =&gt; abc  (prin1 "abc") =&gt; "abc"
  (princ #\a)   =&gt; a    (prin1 #\a)   =&gt; #\a
</description>
<seealso>princ</seealso>
<section>入出力</section>
</chapter>

<chapter>
<title>truename</title>
<type>Function</type>
<arguments>PATHNAME</arguments>
<package>lisp</package>
<description>
相対パスを絶対パスに変えます。

  PATHNAME : 変換するパスを指定します。

使用例：
  ;;; 相対パス及び絶対パスを指定して変換する。
  (truename ".")
  =&gt; "C:/applications/xyzzy"
  (truename "C:/applications/xyzzy/")
  =&gt; "C:/applications/xyzzy"
</description>
<seealso></seealso>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>kill-buffer</title>
<type>Function</type>
<arguments>BUFFER</arguments>
<package>editor</package>
<description>
バッファを削除します。ただし、kill-bufferはバッファが変更されていると削
除していいかどうか聞いてきます。マクロ中で使う際には、delete-bufferを使
ったほうがいいでしょう。(ユーザに聞かずにいきなり削除します）

また、*query-kill-buffer-hook*にフック関数を設定すると、独自の用件でバッ
ファの破棄を確認できます。

使用例：
  ;;; 現在のバッファを削除する。
  (kill-buffer (selected-buffer))
  =&gt; t
</description>
<seealso>delete-buffer</seealso>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>incf</title>
<type>Macro</type>
<arguments>&amp;environment ENV REFERENCE &amp;optional (DELTA 1)</arguments>
<package>lisp</package>
<description>
変数をインクリメントします。

使用例：
  ;;; 変数xの値をインクリメントする。
  (setq x 1)    =&gt; 1
  (incf x)      =&gt; 2
  x             =&gt; 2
</description>
<seealso>decf</seealso>
<section>数値</section>
<file></file>
</chapter>

<chapter>
<title>decf</title>
<type>Macro</type>
<arguments>&amp;environment ENV REFERENCE &amp;optional (DELTA 1)</arguments>
<package>lisp</package>
<description>
変数をデクリメントする

使用例：
  ;;; 変数xの値をデクリメントする。
  (setq x 1)    =&gt; 1
  (decf x)      =&gt; 0
  x             =&gt; 0
</description>
<seealso>incf</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>enlarge-window-horizontally</title>
<type>Function</type>
<arguments>&amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルのあるウィンドウの幅を大きくします。

使用例：
  ;;; listerのマージンからウィンドウの幅を引く場合
  (enlarge-window-horizontally (- *lister-margin* (window-width)))
</description>
<seealso>shrink-window-horizontally</seealso>
<section>ウィンドウ</section>
<file></file>
</chapter>

<chapter>
<title>shrink-window-horizontally</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
カーソルのあるウィンドウの幅を小さくします。

使用例：
  ;;; listerのマージンからウィンドウの幅を引く場合
  (shrink-window-horizontally (- (window-width) *lister-margin*))
</description>
<seealso>enlarge-window-horizontally</seealso>
<section>ウィンドウ</section>
<file></file>
</chapter>


<chapter>
<title>ding</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
音を鳴らします？（詳細不明）

使用例：
  ;;; 音を鳴らす。
  (ding)
  =&gt; t
</description>
<seealso></seealso>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>window-height</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
ウインドウの高さを行単位で得ます。

使用例：
  ;;; 現在のウィンドウを縦に半分にする。
  (split-window (- (floor (window-height) 2) 2))
  =&gt; t
</description>
<seealso></seealso>
<section>ウィンドウ</section>
<file></file>
</chapter>

<chapter>
<title>delete-package</title>
<type>Function</type>
<arguments>PACKAGE</arguments>
<package>lisp</package>
<description>
パッケージを削除します。

使用例：
  ;;; 指定したパッケージを削除する。
  (delete-package package)
  =&gt; t
(delete-package package)
</description>
<seealso>make-package</seealso>
<section>パッケージ</section>
<file></file>
</chapter>

<chapter>
<title>do-events</title>
<type>Function</type>
<arguments></arguments>
<package>lisp</package>
<description>
長い処理の途中に、Windowsのイベントを処理してあげるおまじないらしい。

使用例：
  ;;; イベント処理をしてみる。
  (do-events)
  =&gt; nil
</description>
<seealso></seealso>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>si:*stream-line-number</title>
<type>Misc</type>
<arguments></arguments>
<package>lisp</package>
<description>
（詳細不明）
(si:*stream-line-number *standard-input*)
</description>
<seealso></seealso>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>peek-char</title>
<type>Function</type>
<arguments>&amp;optional PEEK-TYPE INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P</arguments>
<package>lisp</package>
<description>
ストリームから文字を覗き見ます。read-charしてunread-charするようなもんです。

使用例：
  ;;; 標準入力の文字を除き見る。
  (peek-char *standard-input* nil nil nil)
</description>
<seealso>read-char</seealso>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>with-input-from-buffer</title>
<type>Macro</type>
<arguments>(BUFFER &amp;optional POINT EOB) &amp;rest BODY</arguments>
<package>editor</package>
<description>
バッファを入力ストリームとして扱えるようになり、
*standard-input*から読み込まれるようになります。

使用例：
  ;;; *scratch*の内容を*Output*に吐き出す。
  (with-output-to-buffer ((switch-to-buffer "*Output*"))
    (with-input-from-buffer ((switch-to-buffer "*scratch*"))
      (while (setq line (read-line *standard-input* nil))
        (princ line)
        (princ "\n"))))
</description>
<seealso>with-output-to-buffer</seealso>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>make-package</title>
<type>Function</type>
<arguments>PACKAGE-NAME &amp;key :NICKNAMES :USE :INTERNAL-SIZE :EXTERNAL-SIZE</arguments>
<package>lisp</package>
<description>
パッケージを作成します。defpackageとの違いは？（詳細不明）

使用例：
  (make-package name :external-size 0)
</description>
<seealso>delete-package</seealso>
<seealso>in-package</seealso>
<section>パッケージ</section>
<file></file>
</chapter>


<chapter>
<title>eval-region</title>
<type>Function</type>
<arguments>FROM TO &amp;optional STREAM</arguments>
<package>editor</package>
<description>
リージョン内に書かれたLispコードを評価します。

使用例：
  (eval-region from to (selected-buffer))
</description>
<seealso>eval-buffer</seealso>
<section>評価</section>
<file></file>
</chapter>

<chapter>
<title>forward-sexp</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
lisp-modeでS式を1つ進めます。

使用例：
  (forward-sexp)
</description>
<seealso>backward-sexp</seealso>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>backward-sexp</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
lisp-modeでS式を1つ戻します。

使用例：
  (backward-sexp)
</description>
<seealso>forward-sexp</seealso>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>syntax-table</title>
<type>Function</type>
<arguments>&amp;optional BUFFER</arguments>
<package>editor</package>
<description>
現在のシンタックステーブルを取り出します。

使用例：
  ;;; evalして挿入
  (defun xmldoc-eval-and-insert ()
    (interactive "p")
    (let ((syntab (syntax-table)))  ;;現在のxmldocモードのsyntax-tableを取り出し
      (let (from to col str start end)
        (cond ((selection-start-end (start end)
                 (setq from start to end)))
              (t
               ;;一時的にlispに切り替えて
               (use-syntax-table ed::*lisp-mode-syntax-table*)
               (unwind-protect
                   (setq from (progn
                                (backward-sexp)
                                (point))
                         to (progn
                              (forward-sexp)
                              (point)))
                 ;; また元に戻す
                 (use-syntax-table syntab))))
</description>
<seealso></seealso>
<section>シンタックス</section>
<file></file>
</chapter>

<chapter>
<title>previous-line</title>
<type>Function</type>
<arguments>&amp;optional (N 1)</arguments>
<package>editor</package>
<description>
1行前に移動します。

使用例：
  (previous-line)
</description>
<seealso></seealso>
<section>ポジション</section>
<file></file>
</chapter>

<chapter>
<title>load-keyword-file</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
キーワードファイルをロードします。

使用例：
  (and *xmldoc-keyword-file*
       (null *xmldoc-keyword-hash-table*)
       (setq *xmldoc-keyword-hash-table*
             (load-keyword-file *xmldoc-keyword-file* t)))
  (when *xmldoc-keyword-hash-table*
    (make-local-variable 'keyword-hash-table)
    (setq keyword-hash-table *xmldoc-keyword-hash-table*))
</description>
<seealso></seealso>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>preceding-char</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
カーソルの前の文字を返します。
バッファの先頭にカーソルがある場合には、#\NULを返します。

使用例：
  ;;; カーソルの直前が#\LFDか？つまりカーソルは行頭にあるか？
  (char= (preceding-char) #\LFD)
  =&gt; t
</description>
<seealso>following-char</seealso>
<section>テキスト</section>
<file></file>
</chapter>

<chapter>
<title>match-string</title>
<type>Function</type>
<arguments>REGNUM</arguments>
<package>editor</package>
<description>
正規表現を使った検索後に一致した文字列を取得することができます。
(buffer-substring (match-beginning 0) (match-end 0))に一致します。

  REGNUM : 取得したい文字列を指定
        0の場合         正規表現全体に一致する文字列を取得
        1-9の場合       正規表現中のREGNUM番目の括弧に対応した文字列を取得

使用例：
  ;;; 次に現れるLispのコメントを取得する。
  (progn
    (scan-buffer ";\\([^;\n]+\\)" :regexp t :no-dup nil)
    (match-string 1))
</description>
<seealso>scan-buffer</seealso>
<seealso>match-beginning</seealso>
<seealso>match-end</seealso>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>quietly-read-abbrev-file</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
Q.現在、モードを切り替えて且つ abbrev を有効にするには、
  ┌───────────────────────────────┐
  │M-x: sql-mode,                                                │
  │M-x: abbrev-mode                                              │
  │M-x: read-abbrev-file,                                        │
  │Read-abbrev-file: C:/xyzzy/.abbrev_defs                       │
  └───────────────────────────────┘
  のように４段階踏まなくてはなりません。最初の M-x: sql-mode の時か、
  ファンクションキーに割り当てて一度に行う方法はないもんでしょうか？

A.[xyzzy:02017]赤塚慶さん
  .xyzzy に
  ┌───────────────────────────────┐
  │; 起動時に abbrev file を読み込む                             │
  │(quietly-read-abbrev-file)                                    │
  └───────────────────────────────┘
  とかいておくと、  .abbrev_defs を呼んでくれます。

  [xyzzy:02020]亀井哲弥さん
  これに加えて、
  ┌───────────────────────────────┐
  │(add-hook 'ed::*sql-mode-hook* #'(lambda () (abbrev-mode t))) │
  └───────────────────────────────┘
  も書いておけば、M-x sql-mode だけでいけると思います(たぶん)。
</description>
<seealso>abbrev-mode</seealso>
<section>モード</section>
<file></file>
</chapter>

<chapter>
<title>abbrev-mode</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
abbrev-modeを開始します。

使用例：
  (abbrev-mode t)
</description>
<seealso>quietly-read-abbrev-file</seealso>
<section>モード</section>
<file></file>
</chapter>

<chapter>
<title>string-matchp</title>
<type>Function</type>
<arguments>REGEXP STRING &amp;optional START END</arguments>
<package>editor</package>
<description>
| string-match と string-matchp とはどこがどう
| 違うのでしょう？

p 付きの方は大文字小文字を区別しません。
</description>
<seealso>string-match</seealso>
<section>文字列</section>
<file></file>
</chapter>

<chapter>
<title>lookup-dictionary</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
辞書引き機能
（詳細不明）

使用例：
  (lookup-dictionary *edict-dictionary-path* "xyzzydic" "xyzzye2j" s)
</description>
<seealso></seealso>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>defvar-local</title>
<type>Macro</type>
<arguments>NAME INITIAL-VALUE &amp;optional DOC</arguments>
<package>editor</package>
<description>
変数NAMEがバッファ毎に異なる値を持つようにします。関連する関数として、
defvar/make-local-variable等がありますが、それぞれ機能が異なります。
defvar-localはdefvarと異なり、スペシャル変数とはならないので注意が必要です。

  defvar              : スペシャル変数を作る。
  defvar-local        : 全バッファで変数が独自の値を持つようにする。
  make-local-variable : 特定のバッファで変数が独自の値を持つようにする。

また、defvar-localだけではその変数はローカル変数にはならないようです。バ
ッファでsetqをして初めてローカルになる（local-variable-pがtになる）よう
です。

使用例：
  ;;; defvarとdefvar-localを使ってダイナミックかレキシカルかを確認する。
  (defvar var 3)
  =&gt; var  
  (defvar-local var-local 3)
  =&gt; var-local
  
  (defun foo () (let ((var 4) (var-local 4)) (bar)))
  =&gt; foo
  (defun bar () (format nil "var : ~S, var-local : ~S" var var-local))
  =&gt; bar
  
  (foo)
  =&gt; "var : 4, var-local : 3"
(defvar-local *dabbrevs-case-fold* nil)
</description>
<seealso>make-local-variable</seealso>
<seealso>defvar</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*last-command*</title>
<type>Variable</type>
<package>editor</package>
<description>
最後に実行したコマンドが入っています。直前の*this-command*の値が設定されます。
</description>
<seealso></seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>*this-command*</title>
<type>Variable</type>
<package>editor</package>
<description>
現在実行中の関数名のシンボルを格納しています。*last-command*に設定されます。
*pre-command-hook* / *post-command-hook*で特別な処理をかますのに使ったり、
実行中のコマンドを偽ったりできます。
</description>
<seealso></seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>*minibuffer-execute-history*</title>
<type>Variable</type>
<package>editor</package>
<description>
（詳細不明）
</description>
<seealso></seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>*minibuffer-directory-name-history*</title>
<type>Variable</type>
<package>editor</package>
<description>
ミニバッファのディレクトリ名の履歴です。
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*minibuffer-buffer-name-history*</title>
<type>Variable</type>
<package>editor</package>
<description>
ミニバッファのバッファ名の履歴です。
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*minibuffer-symbol-name-history*</title>
<type>Variable</type>
<package>editor</package>
<description>
ミニバッファのシンボル名の履歴です。
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*minibuffer-lisp-sexp-history*</title>
<type>Variable</type>
<package>editor</package>
<description>
ミニバッファのS式の履歴です。
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*minibuffer-file-name-history*</title>
<type>Variable</type>
<package>editor</package>
<description>
ミニバッファのファイル名の履歴です。
</description>
<seealso></seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>*minibuffer-search-string-history*</title>
<type>Variable</type>
<package>editor</package>
<description>
ミニバッファの検索文字の履歴です。
</description>
<seealso></seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>compile-regexp</title>
<type>Function</type>
<arguments>REGEXP &amp;optional CASE-FOLD</arguments>
<package>editor</package>
<description>
正規表現をコンパイルします。
随時正規表現の解析を行わない分、多少検索が早くなるようです。
第二引数にnil以外を指定すると(普通はtを指定します)大文字小文字を区別しません。

  REGEXP     : コンパイルする正規表現
  :case-fold : 大文字小文字を区別するか？
        t       大文字小文字は区別しない。
        nil     大文字小文字をする。

scan-bufferの引数にコンパイルされた正規表現を渡した場合には、
compile-regexpでの指定が有効になり,scan-bufferの引数にある:case-foldは無
視されます。

使用例：
  ;;; "単語.単語:"という正規表現をコンパイルしてみる。
  ;;; 真ん中の'.'は正規表現として扱って欲しくないので、regexp-quoteする。
  (compile-regexp (concat "\\w+" (regexp-quote ".") "\\w+:"))
  =&gt; #&lt;compiled regular expression: \w+\.\w+:&gt;
</description>
<seealso>scan-buffer</seealso>
<section>検索・正規表現</section>
</chapter>

<chapter>
<title>delete-trailing-spaces</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
行末のスペースを削除します。
</description>
<seealso></seealso>
<section>テキスト</section>
<file></file>
</chapter>

<chapter>
<title>define-abbrev-table</title>
<type>Function</type>
<arguments>define-abbrev-table TABNAME &amp;optional DEFS</arguments>
<package>editor</package>
<description>
abbrev-tableを定義します。
（詳細不明）
</description>
<seealso></seealso>
<section>モード</section>
</chapter>


<chapter>
<title>set-syntax-tag</title>
<type>Function</type>
<arguments>set-syntax-tag SYNTAX-TABLE OPEN-CHAR CLOSE-CHAR</arguments>
<package>editor</package>
<description>
シンタックステーブルにタグの開始記号と終了記号を設定します。
HTMLやXML系のモードに設定するといいみたいです。

使用例：
  ;;; htmlmode.lでの定義
  (set-syntax-tag *html-mode-syntax-table* #\&lt; #\&gt;)
</description>
<seealso></seealso>
<section>シンタックス</section>
</chapter>

<chapter>
<title>set-syntax-option</title>
<type>Function</type>
<arguments>set-syntax-option SYNTAX-TABLE OPTION</arguments>
<package>editor</package>
<description>
シンタックスの補助的な設定をします。

  *syntax-option-c-preprocessor* : （詳細不明）
  *syntax-option-indent-c++*     : （詳細不明）
  *syntax-option-indent-java*    : （詳細不明）
  *syntax-option-indent-csharp*  : （詳細不明）
  *syntax-option-column-comment-char* :
        set-syntax-comment-columnだけでは、指定カラムに空白以外が来ると
        コメントと見なしますが、特定のキャラクタが現れた場合にだけにした
        い場合に設定します。以下の二つを設定しなければなりません。

        1)set-syntax-optionに*syntax-option-comment-column-char*を指定する。
        2)set-syntax-start-column-commentでそのキャラクタを指定する。

使用例：
  ;;; fortran.lの定義
  ;;; 0桁目に'C'か'c'が現れたらその行はコメントと見なす。
  (set-syntax-comment-column fortran-mode-syntax-table 0)
  (set-syntax-option fortran-mode-syntax-table
                     *syntax-option-column-comment-char*)
  (set-syntax-start-column-comment fortran-mode-syntax-table #\C)
  (set-syntax-start-column-comment fortran-mode-syntax-table #\c)

参考：
  [xyzzy:07988]を参照のこと
</description>
<seealso>set-syntax-comment-column</seealso>
<seealso>syntax-start-column-comment</seealso>
<section>シンタックス</section>
</chapter>

<chapter>
<title>set-syntax-symbol</title>
<type>Function</type>
<arguments>set-syntax-symbol SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字CHARがSYNTAX-TABLEでシンボル名を構成する文字（単語構成文字は除く）と
して規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-symbol *c-mode-syntax-table* #\_)
  (set-syntax-symbol *c-mode-syntax-table* #\#)
</description>
<seealso></seealso>
<section>シンタックス</section>
</chapter>

<chapter>
<title>set-syntax-match</title>
<type>Function</type>
<arguments>SYNTAX-TABLE OPEN-CHAR CLOSE-CHAR</arguments>
<package>editor</package>
<description>
文字OPEN-CHARとCLOSE-CHARをSYNTAX-TABLEに対応付けのある文字として規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-match *c-mode-syntax-table* #\( #\))
  (set-syntax-match *c-mode-syntax-table* #\{ #\})
  (set-syntax-match *c-mode-syntax-table* #\[ #\])
</description>
<seealso></seealso>
<section>シンタックス</section>
</chapter>

<chapter>
<title>set-syntax-start-multi-comment</title>
<type>Function</type>
<arguments>SYNTAX-TABLE STRING</arguments>
<package>editor</package>
<description>
文字列STRINGをSYNTAX-TABLEに複数行のコメント開始を表す文字列として規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-start-multi-comment *c-mode-syntax-table* "/*")
</description>
<seealso></seealso>
<section>シンタックス</section>
</chapter>

<chapter>
<title>set-syntax-end-multi-comment</title>
<type>Function</type>
<arguments>SYNTAX-TABLE STRING</arguments>
<package>editor</package>
<description>
文字列STRINGをSYNTAX-TABLEに複数行のコメント開始を表す文字列として規定します。

使用例：
  ;;; c-mode.lの定義
  (set-syntax-start-multi-comment *c-mode-syntax-table* "/*")
</description>
<seealso>set-syntax-start-multi-comment</seealso>
<section>シンタックス</section>
</chapter>


<chapter>
<title>exp</title>
<type>Function</type>
<arguments>NUMBER</arguments>
<package>lisp</package>
<description>
自然対数のNUMBER乗の数値を返します。

使用例：
  ;;; 自然対数とその二乗を表示してみる。
  (exp 1)
  =&gt; 2.718282
  (exp 2)
  =&gt; 7.389056
</description>
<seealso></seealso>
<section>数値</section>
</chapter>

<chapter>
<title>log</title>
<type>Function</type>
<arguments>NUMBER &amp;optional BASE</arguments>
<package>lisp</package>
<description>
BASEを底とするNUMBERの対数を返します。

使用例：
  (log 2.718282)
  =&gt; 1.0
  (log 7.389056)
  =&gt; 2.0
</description>
<seealso></seealso>
<section>数値</section>
</chapter>

<chapter>
<title>float</title>
<type>Function</type>
<arguments>NUMBER</arguments>
<package>lisp</package>
<description>
任意の型の数値を浮動小数点型に変換します。

  (float 'NUMBER) == (coerce 'NUMBER 'single-float)

使用例：
  ;;; integerをfloatに変換する。
  (setq var 0)                  =&gt; 0
  (type-of var)                 =&gt; integer
  (setq var (float var))        =&gt; 0.0
  (type-of var)                 =&gt; single-float
</description>
<seealso></seealso>
<section>数値</section>
</chapter>

<chapter>
<title>abs</title>
<type>Function</type>
<arguments>NUMBER</arguments>
<package>lisp</package>
<description>
絶対値を返します。

使用例：
  ;;; 絶対値を返す。
  (abs -3.0)
  =&gt; 3.0  
</description>
<seealso></seealso>
<section>数値</section>
</chapter>

<chapter>
<title>sin</title>
<type>Function</type>
<arguments>RADIANS</arguments>
<package>lisp</package>
<description>
正弦関数の値を返します。
</description>
<seealso></seealso>
<section>数値</section>
</chapter>


<chapter>
<title>cos</title>
<type>Function</type>
<arguments>RADIANS</arguments>
<package>lisp</package>
<description>
余弦関数の値を返します。
</description>
<seealso></seealso>
<section>数値</section>
</chapter>

<chapter>
<title>tan</title>
<type>Function</type>
<arguments>RADIANS</arguments>
<package>lisp</package>
<description>
正接関数の値を返します。
</description>
<seealso></seealso>
<section>数値</section>
</chapter>

<chapter>
<title>sqrt</title>
<type>Function</type>
<arguments>NUMBER</arguments>
<package>lisp</package>
<description>
平方根の値を返します。
</description>
<seealso></seealso>
<section>数値</section>
</chapter>


<chapter>
<title>ash</title>
<type>Function</type>
<arguments>INTEGER COUNT</arguments>
<package>lisp</package>
<description>
整数をロジカルにシフトします。

  INTEGER : シフトする数値
  COUNT   : ビット数分だけ正ならば左に、負ならば右にシフト
  
例：
  ;;; 4を左と右に3ビットずつシフトさせてみる。
  (ash 4 3)
  =&gt; 32
  (ash 4 -3)
  =&gt; 0
</description>
<seealso></seealso>
<section>数値</section>
</chapter>

<chapter>
<title>check-type</title>
<type>Function</type>
<arguments>x</arguments>
<package>lisp</package>
<description>
（詳細不明）

使用例：
  ;;; nの型チェックをしてみる。
  (check-type n integer)
</description>
<seealso></seealso>
<section>データ型</section>
</chapter>

<chapter>
<title>not</title>
<type>Function</type>
<arguments>x</arguments>
<package>lisp</package>
<description>
否定を返します。
non nilならばnilを返し、nilならばtを返します。機能としてはnullと同じです。
</description>
<seealso></seealso>
<section>その他</section>
</chapter>

<chapter>
<title>with-output-to-string</title>
<type>Macro</type>
<arguments></arguments>
<package>lisp</package>
<description>
文字列を出力するストリームを作成します。

使用例：
  ;;; ストリームを使って文字列を出力してみる。
  (setq var
        (with-output-to-string (out)
          (prin1 "test" out)))
  =&gt; "test"
</description>
<seealso></seealso>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>return</title>
<type>Macro</type>
<arguments>return &amp;optional RESULT</arguments>
<package>lisp</package>
<description>
指定された値でブロックから脱出します。
catchしてくれるブロックがないと例外が発生します。

  (return RESULT) = (return-from nil RESULT)

使用例：
  ;;; ループからの脱出の場合
  (loop (if (yes-or-no-p "quit?") (return 123)))
  =&gt; 123

  ;;; ブロックが無いのでcatchできない場合
  (if (yes-or-no-p "quit?") (return 123))
  =&gt; `return-from'のキャッチャを参照できません: nil
</description>
<seealso>return-from</seealso>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>while</title>
<type>Macro</type>
<arguments>while TEST &amp;body BODY</arguments>
<package>lisp</package>
<description>
条件節が成立する間、BODYを繰り返して実行します。
BODYの実行の途中でwhileを抜けるには、returnを使います。

  (while 条件 本体)

使用例：
  ;;; 確認しつつ処理を実行する場合
  (while (yes-or-no-p "次行に移動しますか？")
    (forward-line)
    (reverse-region (progn (goto-bol) (point))
                    (progn (goto-eol) (point)) t)
    (refresh-screen))
  =&gt; nil
</description>
<seealso></seealso>
<section>制御構造</section>
</chapter>

<chapter>
<title>handler-case</title>
<type>Macro</type>
<arguments>handler-case FORM &amp;rest CASES</arguments>
<package>lisp</package>
<description>
例外をキャッチします。
詳細はエラー処理関連を参照してください。キャッチした例外は
si:*condition-stringで対応する文字列を取得できるようです。

  (handler-case
    例外が発生しそうな処理
    (エラーのシンボル1 (仮引数1) エラー処理1)     
    (エラーのシンボル2 (仮引数2) エラー処理2)     
    (エラーのシンボル3 (仮引数3) エラー処理3))

例えば、例外が発生しそうな処理で(error エラーシンボル2)が起きると、途中
の処理をすっとばして、エラー処理2が実行されます。そこで対応出来れば処理
を継続しますが、対応できなければ(error 仮引数2)を実行して、より上位の
handler-caseに対応をお願いします。どこまでいっても対応できなければ、
xyzzyがエラーダイアログを出して処理を終了します。

使用例：
  ;;; 例外が出ても、個々に対応しつつ処理を継続する場合
  ;;; with-output-to-stringを使ってるのは変数が煩わしいから
  (with-output-to-string (out)
    (dolist (i '((6 3) (6 0) (6 "a")))
      (handler-case
          (/ (car i) (cadr i))
        (division-by-zero (c)
          (format out "division-by-zero: ~a~%" (si:*condition-string c)))
        (error (c)
          (format out "error:\t ~a~%" (si:*condition-string c))))))
  =&gt; "division-by-zero: 0で除算しました: /: (6 0)
      error:     不正なデータ型です: \"a\": number"
</description>
<seealso>error</seealso>
<section>制御構造</section>
</chapter>

<chapter>
<title>エラー処理関係</title>
<type>Tips</type>
<arguments></arguments>
<description>
エラーの種類のツリー（階層）です。

condition
├simple-condition
├serious-condition
│├error
││├simple-error
│││└plain-error
││├arithmetic-error
│││├division-by-zero
│││├floating-point-overflow
│││├floating-point-underflow
│││├domain-error
│││├bignum-overflow
│││└power-number-too-large
││├cell-error
│││├unbound-variable
│││├modify-constant
│││└undefined-function
││├control-error
│││└target-missing
││├file-error
│││├file-not-found
│││├path-not-found
│││├access-denied
│││├invalid-drive
│││├current-directory
│││├not-same-device
│││├write-protected
│││├bad-unit
│││├device-not-ready
│││├sharing-violation
│││├lock-violation
│││├wrong-disk
│││├file-exists
│││├not-empty
│││├archiver-error
│││├network-error
│││└file-lost-error
││├package-error
│││└simple-package-error
││├program-error
│││├no-target
│││├bad-macro-form
│││├invalid-function
│││├invalid-variable-list
│││├invalid-lambda-list
│││└invalid-keyword-list
││├type-error
││├range-error
││├stream-error
│││└end-of-file
││├reader-error
││├too-few-arguments
││├too-many-arguments
││├bad-type-specifier
││├read-only-buffer
││└dde-error
││  ├dde-timeout
││  ├dde-busy
││  ├dde-low-memory
││  ├dde-no-conv
││  ├dde-not-processed
││  ├dde-server-died
││  └dde-terminated-transaction
│├storage-condition
│├stack-overflow
│└invalid-byte-code
├quit
│└silent-quit
└warning
  └simple-warning


| xyzzyはもちろん、Emacs Lispでなくて Common Lispに合わせているんですよね。

そうです。コンディションタイプには独自のがありますけど。Stallman先生は、
直接ではないですがCommonのコンディションシステムに影響を与えているらしい
ので、仕組み的には似てます。

| コンディションって何ですか？

Commonでは、エラーと言わずにコンディションと言うらしいです(エラー以外も
投げられるから?)。簡単に言うとC++のtry-catchと同じです(多分、C++がパクっ
たんだろうけど)。

  class condition {};
  class serious_condition: public condition {};
  class error: public serious_condition {};
  class arithmetic_error: public error {};
  class division_by_zero: public arithmetic_error {};

ってのがある場合、

  throw division_by_zero;

とすると、

  try {...} catch (division_by_zero &amp;) {...}

でも、

  try {...} catch (error &amp;) {...}

でも、

  try {...} catch (condition &amp;) {...}

でも捕まえられますよね?
それと同様に

  (error 'division-by-zero)

は、

  (handler-case ... (division-by-zero (c) ...))
  (handler-case ... (error (c) ...))
  (handler-case ... (condition (c) ...))

どれででも捕まえることができます。ま、名前が違うだけでEmacsの
condition-caseと同じです(多分)。catch&amp;throwのタグに継承関係を付けた
のとも同じかも。

また、Emacsでできるかどうかは知りませんが、↓な感じで次のキャッチャにコ
ンディションを渡すこともできます。

  (handler-case
      (any-expression)
    (error (c)
      (some-expression)
      (error c)))

C++での
  try
    {
      any-expression;
    }
  catch (error &amp;)
    {
      some-expression;
      throw;
    }
と同じですけど。
</description>
<section>エラー</section>
<file></file>
</chapter>


<chapter>
<title>switch-to-buffer</title>
<type>Function</type>
<arguments>switch-to-buffer BUFFER &amp;optional NOWARN</arguments>
<package>editor</package>
<description>
指定されたバッファに移動し、ウィンドウに移動します。バッファが存在しなけ
ればバッファを作成します。そのバッファを操作中のウィンドウに表示するとこ
ろ以外は、get-buffer-createのinteractive版と言えます。

使用例：
  ;;; *calc*があろうとなかろうと*calc*に移動する。
  (switch-to-buffer "*calc*")
  =&gt; #&lt;buffer: *calc*&gt;
</description>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>isqrt</title>
<type>Function</type>
<arguments>INTEGER</arguments>
<package>lisp</package>
<description>
整数の平方根を整数で返します。

 (isqrt INTEGER) == (floor (sqrt INTEGER))

使用例：
  ;;; 143と144のisqrtを計算する。
  (isqrt 143)
  =&gt; 11
  (isqrt 144)
  =&gt; 12
</description>
<seealso></seealso>
<section>数値</section>
</chapter>

<chapter>
<title>unuse-package</title>
<type>Function</type>
<arguments>unuse-package PACKAGES-TO-UNUSE &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
パッケージが別のパッケージを使用しないようにします。

使用例：
  ;;; 使用例はcalc.lを参照
  (unuse-package "lisp" *calc-package*)
  =&gt; t
</description>
<seealso></seealso>
<section>パッケージ</section>
<file></file>
</chapter>

<chapter>
<title>auto-save</title>
<type>BufferLocal</type>
<package>editor</package>
<description>
自動保存を行うかを制御するためのフラグです。
個々のバッファ毎や特定のモードだけしたくないのであれば、使用例の様にロー
カル変数にします。

  t     自動保存する
  nil   自動保存しない

使用例：
  ;;; 現在のバッファは自動保存しないようにする。
  (make-local-variable 'auto-save)
  =&gt; t  
  (setq auto-save nil)
  =&gt; nil
</description>
<seealso></seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>mode-name</title>
<type>BufferLocal</type>
<package>editor</package>
<description>
モードの名前を格納しているローカル変数です。
？mode-nameとbuffer-modeは必ずローカル変数になるのでしょうか？
</description>
<seealso></seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>need-not-save</title>
<type>BufferLocal</type>
<package>editor</package>
<description>
保存する必要があるかどうかを設定します。
個々のバッファ毎や特定のモードだけしたくないのであれば、使用例の様にロー
カル変数にします。例えば、*scratch*の様に書き捨てたりするバッファでは、
保存の必要はないので、tになっています。

  t     保存の必要はない
  nil   保存する

使用例：
  ;;; 現在のバッファは保存の必要はなし。
  (make-local-variable 'need-not-save)
  =&gt; t
  (setq need-not-save t)
  =&gt; t
</description>
<seealso>need-buffer-save-p</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>:regexp</title>
<type>Keyword</type>
<arguments></arguments>
<package>lisp</package>
<description>
検索文字列が正規表現か否かを指定します。

  t     検索文字列は正規表現
  nil   検索文字列はただの文字列
</description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>:no-dup</title>
<type>Keyword</type>
<arguments></arguments>
<package>lisp</package>
<description>
検索する場合に同じ位置から行うかどうかを指定します。

  t     ひとつ次から検索を行う。
  nil   同じ位置から検索を行う。
</description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>:case-fold</title>
<type>Keyword</type>
<arguments></arguments>
<package>lisp</package>
<description>
検索する場合に大文字と小文字を区別するかどうかを指定します。

  t     大文字と小文字を区別しません。
  nil   大文字と小文字を区別します。
</description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>:reverse</title>
<type>Keyword</type>
<arguments></arguments>
<package>lisp</package>
<description>
検索する場合に正方向か逆方向かを指定します。

  t     逆方向に検索します。
  nil   正方向に検索します。
</description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>:tail</title>
<type>Keyword</type>
<arguments></arguments>
<package>lisp</package>
<description>
検索した場合にカーソルを文字列の先頭か末尾のどちらに位置づけるかを指定します。

  t     カーソルを末尾に位置づけます。
  nil   カーソルを先頭に位置づけます。
</description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>:right-bound</title>
<type>Keyword</type>
<arguments></arguments>
<package>lisp</package>
<description></description>
<seealso>scan-buffer</seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>throw</title>
<type>Function</type>
<arguments>tag-form result</arguments>
<package>lisp</package>
<description>
catchで指定されたラベルまで、非局所脱出します。
名前はC++と同じです。

  C++  : try    throw
  Lisp : catch  throw

使用例：
  ;;; test2で例外を出してtest1でキャッチする。
  (defun test1 (x)
    (catch 'label1
      (test2 x)))
  =&gt; test1
  (defun test2 (x)
    (if (zerop x)
        (throw 'label1 'division-by-zero)
        (/ 1 x)))
  =&gt; test2
  (test1 0)
  =&gt; division-by-zero

参考：
  エラー処理関連
</description>
<seealso>catch</seealso>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>catch</title>
<type>Function</type>
<arguments></arguments>
<package>lisp</package>
<description>
throwを投げるためのラベルを設定します。
C++のtryに相当します。

  C++  : try    throw
  Lisp : catch  throw

参考：
  エラー処理関連
</description>
<seealso>throw</seealso>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>load-library</title>
<type>Function</type>
<arguments>filename &amp;rest rest</arguments>
<package>lisp</package>
<description>
ライブラリを対話的に読み込みます。
requireと異なり、一度読んでいてももう一度読み込みます。

内部的には、si:*load-libraryをinteractiveで宣言したものです。

| また、si:*load-library中で失敗したら、メッセージ等を出力して、処理を続けると
| いうのは可能でしょうか？

  (handler-case
      (si:*load-library "foo")
    (error (c) (si:*print-condition c)))
      (si:*load-library "bar")
</description>
<seealso>si:*load-library</seealso>
<section>評価</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>loop</title>
<type>Macro</type>
<arguments></arguments>
<package>lisp</package>
<description>
無限ループします。
脱出するには以下の様にreturnを使います。

 (loop
   処理
   (if 条件 (return 値))
   処理)

使用例：
  ;;; 「はい」と答えるまで繰り返し
  (loop (if (yes-or-no-p "quit?") (return 123)))
  =&gt; 123
</description>
<seealso></seealso>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>nil</title>
<type>Variable</type>
<package>lisp</package>
<description>
偽を表す定数です。
</description>
<seealso>t</seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>t</title>
<type>Variable</type>
<package>lisp</package>
<description>
真を表す定数です。
</description>
<seealso>nil</seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>refresh-screen</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
画面をリフレッシュします。
キー入力の方が画面の再描画よりも優先されます。従って、外部プロセスから非
同期に入力される文字列をバッファに出力したり、処理の途中でダイアログを表
示すると、画面が追いついていない場合があります。そのような場合に実行します。
</description>
<seealso></seealso>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>case</title>
<type>Macro</type>
<arguments>case KEYFORM &amp;rest FORMS</arguments>
<package>lisp</package>
<description>
C言語のswitch文みたいなのです。

(case &lt;キー&gt;
  (&lt;リスト1&gt; &lt;式&gt;～&lt;式&gt;)
  (&lt;リスト2&gt; &lt;式&gt;～&lt;式&gt;)
       ...
  (&lt;リストn&gt; &lt;式&gt;～&lt;式&gt;))

まず&lt;キー&gt;を評価し，それが&lt;リスト&gt;のどれかの要素と一致すれば，
その&lt;リスト&gt;に続く式を順に評価して，最後の式の値をcaseの値として返
す。どの&lt;リスト&gt;のどの要素にも一致しなければcaseの値はnilである。
ただし例外として，最後のリスト(&lt;リストn&gt;)がtであれば，「どれにも一
致しなければ」を意味する。

&lt;リスト1&gt;～&lt;リストn&gt;までは，それぞれデータのリストで，これら
は評価されない。すなわち値がリストになる式ではなく，リストそのものがここ
に入る。要素が一つだけの場合は，リストの代わりに要素がここにきてもいい。

使用例：
  ;;; 4を入力して場合分けさせる
  (setq x 4)
  =&gt; 4
  (case x
    (1 'one)
    (2 'two)
    (3 'three)
    ((4 5) 'four_or_five)
    (t 'large))
  =&gt; four_or_five
</description>
<seealso></seealso>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>message-box</title>
<type>Function</type>
<arguments>message-box MESSAGE &amp;optional TITLE STYLES &amp;key :BUTTON1 :BUTTON2 :BUTTON3 :BUTTON4 :BUTTON5 :NO-WRAP</arguments>
<package>editor</package>
<description>
yes-or-no-p系よりも柔軟なダイアログを表示します。

  MESSAGE : ダイアログに表示するメッセージ
  TITLE   : ダイアログのタイトル
  STYLES  : ダイアログのスタイルをリストで指定します。
        :ok                     [OK]を表示します。
        :ok-cancel              [OK][ｷｬﾝｾﾙ]を表示します。
        :yes-no                 [はい][いいえ]を表示します。
        :yes-no-cancel          [はい][いいえ][ｷｬﾝｾﾙ]を表示します。
        :abort-retry-ignore     [中止][再試行][無視]を表示します。
        :information            (i)インフォメーションマークを表示します。
        :exclamation            (!)感嘆符を表示します。
        :question               (?)疑問符を表示します。
        :button1                ボタン1をデフォルト選択にします。
        :button2                ボタン2をデフォルト選択にします。
        :button3                ボタン3をデフォルト選択にします。
        :button4                ボタン4をデフォルト選択にします。
        :button5                ボタン5をデフォルト選択にします。
  BUTTON1 : ボタン1のテキストを変更します。
  BUTTON2 : ボタン2のテキストを変更します。
  BUTTON3 : ボタン3のテキストを変更します。
  BUTTON4 : ボタン4のテキストを変更します。
  BUTTON5 : ボタン5のテキストを変更します。
  NO-WRAP : MESSAGEが長すぎるときに折り返すかを制御します。
        t       長くとも折り返さない。
        nil     長ければ折り返す。

ボタンを押したときの戻り値は、それぞれ以下のとおりです。
  :ok     [OK]を選択
  :cancel [ｷｬﾝｾﾙ]を選択
  :yes    [はい]を選択
  :ignore [無視]を選択

使用例：
  ;;; [はい][いいえ][ｷｬﾝｾﾙ]を表示し選択させます。
  (message-box "メールを送信しますか?" nil
    '(:yes-no-cancel :question :button1))
  =&gt; :yes

  ;;; ダイアログの結果をcaseで場合わけしてみる
  (case (message-box "メールを送信しますか?" nil
                     '(:yes-no-cancel :question :button1))
    (:yes (den8-draft-send t))
    (:no t)
    (t nil))
</description>
<seealso></seealso>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>screen-height</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
xyzzyのウィンドウ全体の高さが何行になるのかを返します。
</description>
<seealso></seealso>
<section>ウィンドウ</section>
<file></file>
</chapter>

<chapter>
<title>delete-other-windows</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
現在カーソルがあるウィンドウ以外のウィンドウを削除します。
</description>
<seealso></seealso>
<section>ウィンドウ</section>
<file></file>
</chapter>

<chapter>
<title>buffer-read-only</title>
<type>BufferLocal</type>
<package>editor</package>
<description>
バッファが読み取り専用かどうかを管理します。

  t     バッファは読み取り専用
  nil   バッファは読み書き可能
</description>
<seealso></seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>concatenate</title>
<type>Function</type>
<arguments>&amp;rest str</arguments>
<package>lisp</package>
<description>
（詳細不明）

使用例：
  (concatenate 'string     "^X-Status[ \t]*:[ \t]*" (car from) "[ \t]*$")  
</description>
<seealso></seealso>
<section>文字列</section>
<file></file>
</chapter>

<chapter>
<title>si:*activate-toplevel</title>
<type>Function</type>
<arguments></arguments>
<package>lisp</package>
<description>
xyzzyを他のウィンドウの最前面に表示します。
</description>
<seealso></seealso>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>dotimes</title>
<type>Macro</type>
<arguments></arguments>
<package>lisp</package>
<description>
(dotimes (&lt;変数&gt; &lt;整数式&gt; &lt;値&gt;)
  &lt;式1&gt; ... &lt;式n&gt;)

指定された回数だけ繰り返しを行う。

まず&lt;整数式&gt;を評価する。その値をnとすると，0～n-1までのそれぞれの
整数値に対して，&lt;変数&gt;をその整数値にバインドして，本体の&lt;式1&gt;
～&lt;式n&gt;までを評価する。すなわち本体式はn回繰り返される。本体式の評
価がn回繰り返されると，&lt;値&gt;を評価し，dotimesの値として返す。
また&lt;値&gt;は省略でき，その場合はdotimesの値はnilである。

dotimes式の一般形は，

(do* ((temp &lt;整数式&gt;)
      (&lt;変数&gt; 0 (1+ &lt;変数&gt;)))
    ((&gt;= &lt;変数&gt; temp) &lt;値&gt;)
  &lt;式1&gt;
  ...
  &lt;式n&gt;)

と同値である。
</description>
<seealso></seealso>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>scroll-window</title>
<type>Function</type>
<arguments>scroll-window ARG</arguments>
<package>editor</package>
<description>
ウィンドウを指定行数分スクロールします。
負の数値を指定すると逆方向にスクロールします。

使用例：
  ;;; 0.3秒おきに1行ずつスクロールさせる。
  (dotimes (i 4) (scroll-window 1) (sit-for .3))
  =&gt; nil
(scroll-window n)
</description>
<seealso></seealso>
<section>ウィンドウ</section>
<file></file>
</chapter>

<chapter>
<title>safe-car</title>
<type>Function</type>
<arguments>x</arguments>
<package>lisp</package>
<description>
(car x)はxがnilかconsでなければエラーになります
しかしsafe-carはエラーを発生せずにnilを返します。

使用例：
  ;;; carとsafe-carの違い
  (car "abc")
  =&gt; 不正なデータ型です: "abc": cons
  (safe-car "abc")
  =&gt; nil
</description>
<seealso>car</seealso>
<section>リスト</section>
<file></file>
</chapter>

<chapter>
<title>safe-cdr</title>
<type>Function</type>
<arguments>x</arguments>
<package>lisp</package>
<description>
(cdr x)はxがnilかconsでなければエラーになります
しかしsafe-cdrはエラーを発生せずにnilを返します。
</description>
<seealso>cdr</seealso>
<section>リスト</section>
<file></file>
</chapter>

<chapter>
<title>cond</title>
<type>Macro</type>
<arguments></arguments>
<package>lisp</package>
<description>
cond CLAUSE...
     `cond'は任意個の選択肢から選択します。`cond'の個々のCLAUSEはリスト
     でなければなりません。このリストのCARはCONDITIONです。残りの要素は
     (もしあれば)BODY-FORMSです。したがって句(clause)は次のようになりま
     す。

          (CONDITION BODY-FORMS...)

     `cond'は個々の句のCONDITIONを評価していくことによって、その句の並び
     をテキストどおりの順序で試します。CONDITIONの値が`nil'でなければ、
     その句は「成功」します。その場合、`cond' はそのBODY-FORMSを評価し、
     BODY-FORMSの最後の値が`cond'の値となります。残りの句は無視されます。

     CONDITIONの値が`nil'ならば、その句は「失敗」し、`cond'は次の句に制
     御を移し、その CONDITIONを試していきます。

     すべてのCONDITIONが`nil'に評価された場合、すなわち、すべての句が失
     敗した場合、`cond'は`nil'を返します。

     句は次のようになっているかもしれません。

          (CONDITION)

     その場合、CONDITIONのテスト結果が`nil'でなければ、CONDITIONの値が
     `cond'形式の値になります。

     以下の例では四つの句を持っていて、それぞれ`x'の値が数値、文字列、バッ
     ファ、シンボルのどれかであるかをテストします。

          (cond ((numberp x) x)
                ((stringp x) x)
                ((bufferp x)
                 (setq temporary-hack x) ; 一つの句に
                 (buffer-name x))        ; 複数の body-forms
                ((symbolp x) (symbol-value x)))

     最後の句より前の句がどれも成功しなかった場合には、その最後の句を実
     行したいということがよくあります。これを行うために私たちは次のよう
     に最後の句のCONDITIONとして`t'を使用します。`(t BODY-FORMS)'。形式
     `t'は`t'に評価され、決して`nil'にはならず、したがって、この句は決し
     て失敗せず、最悪でもそこには到達する`cond'が提供されます。

     例えば、

          (cond ((eq a 'hack) 'foo)
                (t "default"))
          =&gt; "default"

     この式は`a'の値が`hack'ならば`foo'を返し、そうでなければ文字列
     `"default"'を返す`cond'です。

あらゆる条件分岐の構造は`cond'でも`if'でも表現することができます。したがっ
て、どちらを使うかの選択はスタイルの問題です。例えば:

     (if A B C)
     ==
     (cond (A B) (t C))

</description>
<seealso></seealso>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>setf</title>
<type>Macro</type>
<arguments>{place new-value}*</arguments>
<package>lisp</package>
<description>
このマクロは、変数にアクセスし、その値を変更するために使われます。従来用
いられてきたsetqよりも汎用的であり、setqと全く置き換えて使用することがで
きます。placeは、アクセスしようとするデータオブジェクトのある場所を指し、
new-valueを評価した値がその場所に書き込まれます。

setfは、いくつでもplaceやnew-valueの対でも受け付けます。そして、同時にで
はなく、順番に値を割り当てます。つまり、最初の引数の対は、二番目の対が評
価される前に評価され、placeによって示される場所に値が書き込まれています。
このように、二番目の引数の対は、最初の対の評価によって割り当てられた値を
使うことが可能です。setfは、最後に評価された引数の対によって割り当てられ
た値、あるいは、まったく引数が与えられなかった場合は、nilを返します。

placeの形式は以下のどのようなものも可能です：

(1)変数名(レキシカル変数でもスペシャル変数でもよい)

  (setf hoge 1); 変数hogeに1を代入する
  =&gt; 1
  hoge
  =&gt; 1

(2)アクセス関数
 * 構造体(構造体名＋変数)

  (defstruct foo a b c); 構造体fooを宣言する
  =&gt; #&lt;structure-definition: foo&gt;
  (setf hoge (make-foo)); hogeに空のfoo構造体を代入する(ここのsetfはsetqでもよい)
  =&gt; #S(foo a nil b nil c nil)
  (setf (foo-a hoge) 10); hogeのスロットaに10を代入する
  =&gt; 10
  hoge
  =&gt; #S(foo a 10 b nil c nil)

* 配列(aref, svref, fill-pointer)

  (setf hoge (make-array 3)); hogeに空のベクトルを代入する(ここのsetfはsetqでもよい)
  =&gt; #(nil nil nil)
  (setf (aref hoge 1) 5); hogeベクトルの2番目の数値を5にする
  =&gt; 5
  hoge
  =&gt; #(nil 5 nil)

 * リスト(car, cdr, first, rest, etc...)

  (setf hoge '("a" "b" "c"))
  =&gt; ("a" "b" "c")
  (setf (car (cdr hoge)) "d")
  =&gt; "d"
  hoge
  =&gt;("a" "d" "c")

* 属性リスト(get, getf, symbol-plist)

  (setf (get 'Japan 'language) "Japanese")
  =&gt; "Japanese"
  (setf (get 'Japan 'population) 120000000)
  =&gt; 120000000
  (symbol-plist 'Japan)
  =&gt; (population 120000000 language "Japanese")

 * その他(symbol-value, gethash, symbol-function, documentation, macro-function)
</description>
<seealso>setq</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>do</title>
<type>Macro</type>
<arguments>( { var | ( var [init [step] ] ) }* ) (end-test {result}*) {declaration}* {tag | statement}*</arguments>
<package>lisp</package>
<description>
(do ((var1 init1 step1)
     (var2 init2 step2)
            ...
     (varm initm stepm))
    (end-test result1 result2 ... resultm) 
   declaration1
       ...
   declarationN)

(do ((&lt;変数1&gt; &lt;初期値1&gt; &lt;ステップ1&gt;)
     (&lt;変数2&gt; &lt;初期値2&gt; &lt;ステップ2&gt;)
              ...
     (&lt;変数m&gt; &lt;初期値m&gt; &lt;ステップm&gt;))
    (&lt;&lt;終了条件&gt; &lt;後式1&gt; ... &lt;後式p&gt;) 
   &lt;式1&gt;
   ...
   &lt;式n&gt;)


&lt;変数1&gt;～&lt;変数m&gt;までを局所変数とし，&lt;終了条件&gt;が真
になるまでdo式本体の&lt;式1&gt;～&lt;式n&gt;を繰り返し実行する。&lt;
変数1&gt;～&lt;変数m&gt;までは変数を表す記号で，do式の中で局所的に使
われる変数を指定する。do式が評価されるときは，まず&lt;初期値1&gt;～
&lt;初期値m&gt;までが評価され，その値が各局所変数にバインドされる。そ
の後で，&lt;終了条件&gt;が評価され，もし値がnilであれば本体を実行する。
次に&lt;ステップ1&gt;～&lt;ステップm&gt;までを評価してその値を各局所
変数に代入してから&lt;終了条件&gt;を評価する。これを&lt;終了条件&gt;
の値がnil以外になるまで繰り返す。&lt;終了条件&gt;の値がnil以外になっ
たら，&lt;終了条件&gt;に続く&lt;後式1&gt;～&lt;後式p&gt;を評価し，そ
の最後の式の値をdo式の値とする。

do式の一般形は，

(block nil
  (let ((&lt;変数1&gt; &lt;初期値1&gt; &lt;ステップ1&gt;)
        (&lt;変数2&gt; &lt;初期値2&gt; &lt;ステップ2&gt;)
                 ...
        (&lt;変数m&gt; &lt;初期値m&gt; &lt;ステップm&gt;))
    (tagbody
      loop
      (when &lt;終了条件&gt;
        (return (progn &lt;後式1&gt; ... &lt;後式p&gt;)))
      &lt;式1&gt;
      ...
      &lt;式n&gt;
     (psetq &lt;変数1&gt; &lt;ステップ1&gt;
              ...
            &lt;変数m&gt; &lt;ステップm&gt;)
      (go loop))))

と同値である。(loop というタグは他では使われていないものとする)
</description>
<seealso></seealso>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>do*</title>
<type>Macro</type>
<arguments>(&amp;rest VARLIST) (&amp;optional END-TEST &amp;rest RESULT) &amp;body BODY</arguments>
<package>lisp</package>
<description>
doと同じようにループ処理を行う。
doとだいたい同じだけど、letとlet*の違いのように、局所変数の初期化と更
新の方法にある。doはletを使って局所変数を初期化しているため、全ての初
期値を計算してから局所変数をバインドするが，do*ではletの代わりにlet*
が使われている。またpsetqのかわりにsetqを使う。

do*式の一般形は、

(block nil
  (let* ((&lt;変数1&gt; &lt;初期値1&gt; &lt;ステップ1&gt;)
         (&lt;変数2&gt; &lt;初期値2&gt; &lt;ステップ2&gt;)
                  ...
         (&lt;変数m&gt; &lt;初期値m&gt; &lt;ステップm&gt;))
    (tagbody
      loop
      (when &lt;終了条件&gt;
        (return (progn &lt;後式1&gt; ... &lt;後式p&gt;)))
      &lt;式1&gt;
      ...
      &lt;式n&gt;
     (setq &lt;変数1&gt; &lt;ステップ1&gt;
              ...
           &lt;変数m&gt; &lt;ステップm&gt;)
      (go loop))))

と同値である。(loop というタグは他では使われていないものとする)
</description>
<seealso>do</seealso>
<seealso>let</seealso>
<seealso>let*</seealso>
<section>制御構造</section>
</chapter>

<chapter>
<title>defconstant</title>
<type>Macro</type>
<arguments>defconstant NAME VALUE &amp;optional DOC</arguments>
<package>lisp</package>
<description>
定数を宣言します。

使用例：
  ;;; encoding.lの中より
  (defconstant *eol-crlf* 1)
  =&gt; *eol-crlf*
</description>
<seealso></seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>quote-string</title>
<type>Function</type>
<arguments>quote-string STRING TARGET-CHAR QUOTE-CHAR</arguments>
<package>editor</package>
<description>
文字列中の特定文字の前にエスケープ文字をつけます。

  STRING      : 置換する文字列
  TARGET-CHAR : エスケープされる文字
  QUOTE-CHAR  : エスケープ文字

使用例：
  ;;;   スペースの前に'をつけます。
  (quote-string  "a b  c"  #\SPC #\')
  =&gt; "a' b' ' c"
</description>
<seealso></seealso>
<section>文字列</section>
<file></file>
</chapter>
  
<chapter>
<title>add-history</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
（詳細不明）

使用例：
  (add-history file '*minibuffer-file-name-history*)
  (add-history cmd '*minibuffer-execute-history*)
</description>
<seealso></seealso>
<section>変数と定数</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>wild-pathname-p</title>
<type>Function</type>
<arguments></arguments>
<package>lisp</package>
<description>
ワイルドカード指定されたパスかどうかを返します。

  t     ワイルドカード指定されたパスです。
  nil   ワイルドカード指定されていません。

使用例：
  ;;; ワイルドカードかどうかを調べてみる。
  (wild-pathname-p "site-lisp/*.l")
  =&gt; t
</description>
<seealso></seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>count-buffers</title>
<type>Function</type>
<arguments>count-buffers &amp;optional ALL</arguments>
<package>editor</package>
<description>
全バッファの数を返します。

  ALL : " *Completion*"や" *Minibuf0*"等の先頭が空白のバッファも数えるか？
        t       先頭が空白のバッファも数える。
        nil     先頭が空白のバッファは数えない。

使用例：
  ;;; バッファの数を数えてみる。
  (count-buffers)
  =&gt; 20
  (count-buffers t)
  =&gt; 23
</description>
<seealso></seealso>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>lambda</title>
<type>Misc</type>
<arguments>lambda-list documentation-string body</arguments>
<package>lisp</package>
<description>
  関数に名前を付ける必要がなく、手続きだけを記述したい場合にラムダ式
  を用いる。ラムダ式の二番目の引数はラムダリストと呼ばれ、関数の
  パラメータの名前を与える。lambda式のより完全な構文は以下である。

  (lambda ({var}*
           [&amp;optional {var | (var [initform [svar]])}*]
           [&amp;rest var]
           [&amp;key {var | ({var | (keyword var)} [initform [svar]])}*]
           [&amp;aux {var | (var [initform])}*])
     [[{declaration}* | documentation-string]]
     {form}*)
  
  引数がラムダ式によって表される関数に適用されると、form が評価
  されて最後の form の結果が返される。form は順に評価される。

  ((lambda (x y) (+ x y)) 10 20)        =&gt; 30
  
  ラムダリストの各要素は、パラメータ指定子や、記号＆（アンパサンド）
  で始まるラムダリストキーワードからなる。ラムダリストは５つの部分で
  構成される。
  
  ・必須パラメータの記述
      ラムダリストキーワードよりも前に現れる var を必須パラメータという。
  
  ・オプショナルパラメータの記述
      &amp;optionalから次のラムダリストキーワードまでか、ラムダリストの
      終わりまで。関数呼び出し時に、オプショナルパラメータに対応する
      引数はあっても無くてもよい。引数が省略された場合、initform が
      あれば initform に初期化され、無ければ nil で初期化される。
      svar は引数が与えられたかどうかを示す。
  
    ((lambda (x &amp;optional (y 0 given))
         (if given (+ x y) x))
      10 20)
    =&gt; 30
  
  ・レストパラメータの記述
      &amp;restとそれに続く一つのパラメータ指定子。関数への引数のうち、
      必須パラメータとオプショナルパラメータに対応するもの以外
      からなるリストが束縛される。
  
    ((lambda (x &amp;optional (y 1) (z 2) &amp;rest args)
         (list x y z args))
      'a 'b 'c 'd 'e 'f)
    =&gt; (a b c (d e f))
  
  ・キーワードパラメタの記述
      &amp;keyから次のラムダリストキーワードまでか、ラムダリストの
      終わりまで。関数が呼ばれたときに対応する keyword に対応する
      パラメータ指定子 var に値を束縛する。
  
    ((lambda (x &amp;key ((:test f) #'eq))
         (if (funcall f x "word") 'True 'False))
     "word" :test #'equal)
    =&gt; True
  
    ((lambda (x &amp;key (test #'eq))
         (if (funcall test x "word") 'True 'False))
      "word" :test #'eql)
    =&gt; False
  
  ・補助変数の記述
      ラムダリストに &amp;aux が含まれるなら、この後の全ての指定は
      補助変数の指定子である。次に示す二つの例は同じ結果を与える。
      これらの使用については純粋にスタイルの問題である。
    
    ((lambda (x &amp;aux (l (length x)))
         (list x l))
      '(a b c))
    =&gt; ((a b c) 3)
    
    ((lambda (x)
         (let ((l (length x))) (list x l)))
      '(a b c))
    =&gt; ((a b c) 3)
</description>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>let*</title>
<type>Special Form</type>
<package>lisp</package>
<arguments>let* ({VAR|(VAR [VALUE])}*) {declaration}* {FORM}*</arguments>
<description>
letとよく似ています。letと異なり、VARの初期化に先に定義した他のVARを参照
することが可能です。

使用例：
  ;;; letとlet*の違い
  (setq Y 2)
  =&gt; 2
  (let (X (Y 1) (Z Y)) (list X Y Z))
  =&gt; (nil 1 2)
  (let* (X (Y 1) (Z Y)) (list X Y Z))
  =&gt; (nil 1 1)
</description>
<seealso>let</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>if</title>
<type>Special Form</type>
<arguments>if TEST THEN [ELSE]</arguments>
<package>lisp</package>
<description>
いわゆるIF文を実行します。
TESTがnon nilならTHENを実行。nilならELSEを実行します。

構文：
  (if TEST THEN [ELSE])
</description>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unwind-protect</title>
<type>Special Form</type>
<arguments>protected-form {cleanup-form}*</arguments>
<package>lisp</package>
<description>
protected-form中に終了もしくは例外が発生しても（正常、異常を問わず）
cleanup-formを実行します。

使用例：
  ;;; ゼロ除算が起きてもcleanup-formが実行される。
  (progn
    (msgbox "計算前")
    (unwind-protect (/ 1 0)
      (msgbox "計算後")))
  =&gt; 0で除算しました: /: (1 0)
</description>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>multiple-value-setq</title>
<type>Special Form</type>
<arguments>multiple-value-setq VARIABLES FORM</arguments>
<package>lisp</package>
<description>
返された多値を個々の変数に設定します。
変数の個数よりもフォームが返した値の数が多いときには余った分は捨てられま
す。少ない場合には、足りない分だけnilが設定されます。

  VARIABLES : 変数のリスト
  FORM      : 評価するフォーム

使用例：
  ;;; valuesで多値を返した場合
  (setq a (values 1 2)) =&gt; 1
  a                     =&gt; 1
  (multiple-value-setq (a b) (values 1 2))
                        =&gt; 1
  a                     =&gt; 1
  b                     =&gt; 2
</description>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>quote</title>
<type>Special Form</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTを評価せずに返します。
single quoteで代用されます。

使用例：
  ;;; quoteと'を使ってみる。
  (quote x)             =&gt; x
  'x                    =&gt; x
  (eq (quote x) 'x)     =&gt; t
</description>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set</title>
<type>Function</type>
<arguments>SYMBOL VALUE</arguments>
<package>lisp</package>
<description>
シンボルに値を束縛します。

  SYMBOL : シンボル名
  VALUE  : 設定する値

使用例：
  ;;; fooというシンボルに値を束縛してみる。
  (boundp 'foo)         =&gt; nil
  (set 'foo 2)          =&gt; 2
  (boundp 'foo)         =&gt; t
  foo                   =&gt; 2
</description>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>symbol-value</title>
<type>Function</type>
<arguments>SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルに束縛されている値を返します。

  SYMBOL : 値を返すシンボル

使用例：
  ;;; fooというシンボルの値を返してみる。
  (set 'foo 3)          =&gt; 3
  (symbol-value 'foo)   =&gt; 3
  foo                   =&gt; 3
</description>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>special-form-p</title>
<type>Function</type>
<arguments>SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルが特殊形式かどうかを返します。

  SYMBOL : 判定するシンボル

  t     シンボルは特殊形式
  nil   シンボルは特殊形式ではない。

特殊形式一覧：
  block         catch           declare
  eval-when     flet            function
  go            if              labels
  let           let*            macrolet
  multiple-value-call
  multiple-value-prog1
  progn         progv           quote
  return-from   setq            tagbody
  the           throw           unwind-protect
</description>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>symbol-function</title>
<type>Function</type>
<arguments>SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルに束縛された関数定義を返します。

  SYMBOL : 関数定義を取得するシンボル名

使用例：
  ;;; 関数定義の取得
  (symbol-function 'foo)
  =&gt; 関数が定義されていません: foo
  (defun foo (x) (* x 2))
  =&gt; foo
  (symbol-function 'foo)
  =&gt; #&lt;lexical-closure: foo&gt;
</description>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>constantp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
オブジェクトがconstantかどうかを返します。

  t     オブジェクトはconstant
  nil   オブジェクトはconstantでない

使用例：
  ;;; defvar/defconstantの違い
  (defvar foo 2)
  =&gt; foo
  (defconstant bar 3)
  =&gt; bar
  (constantp 'foo)
  =&gt; nil
  (constantp 'bar)
  =&gt; t
</description>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>eval</title>
<type>Function</type>
<arguments>form</arguments>
<package>lisp</package>
<description>
formを評価します。
</description>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>funcall</title>
<type>Function</type>
<arguments>funcall FN &amp;rest ARGUMENTS</arguments>
<package>lisp</package>
<description>
引数を指定して関数を表すシンボルから関数を呼び出します。
FNには関数を表すシンボルでも関数でも構いません。引数の個数が静的に定まら
ない場合にはfuncallは向いていないので、その場合にはapplyを使います。

使用例：
  ;;; carをいろいろな呼び出し方でする。
  (car '(a b c))                =&gt; a
  (funcall 'car '(a b c))       =&gt; a
  (funcall #'car '(a b c))      =&gt; a

注意：
  funcallやapply等の様に関数を引数とする標準の関数は、carがlambdaの式や
  シンボルを内部的に関数に変換します。従って、関数を表すシンボルでも関数
  そのものでも構いません。
</description>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>apply</title>
<type>Function</type>
<arguments>function arg &amp;rest more-args</arguments>
<package>lisp</package>
<description>
引数を格納したリストを指定して関数を表すシンボルから関数を呼び出します。
FNには関数を表すシンボルでも関数でも構いません。引数の個数が必ず定まって
いる場合には、applyを使う必要は無くfuncallの方が良いと思います。

使用例：
  ;;; carをいろいろな呼び出し方でする。
  (car '(a b c))                =&gt; a
  (apply 'car '((a b c)))       =&gt; a
  (apply #'car '((a b c)))      =&gt; a
</description>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>function</title>
<type>Special Form</type>
<arguments>function FN</arguments>
<package>lisp</package>
<description>
関数の関数定義を返します。#'と同じです。

使用例：
  ;;; #'とfunctionとsymbol-functionを比べてみる。
  (defun foo (x) (* x 3))
  =&gt; foo
  #'foo
  =&gt; #&lt;lexical-closure: foo&gt;
  (function foo)
  =&gt; #&lt;lexical-closure: foo&gt;
  (symbol-function 'foo)
  =&gt; #&lt;lexical-closure: foo&gt;
</description>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>values-list</title>
<type>Function</type>
<arguments>lvalues-list LIST</arguments>
<package>lisp</package>
<description>
指定されたリストを多値として返します。

  (values-list '(a b c)) == (values a b c)
  (values-list list) == (apply #'values list)
</description>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>makunbound</title>
<type>Function</type>
<arguments>SYMBOL</arguments>
<package>lisp</package>
<description>
指定されたシンボルの値への束縛を解消します。
これ以降boundpはnilを返すようになります。シンボルへの値と関数定義の束縛
は独立しているので、makunboundをしてもfboundpの結果は変わりません。

使用例：
  ;;; 束縛を解消してみる。
  (set 'foo 2)          =&gt; 2
  (boundp 'foo)         =&gt; t
  (makunbound 'foo)     =&gt; foo
  (boundp 'foo)         =&gt; nil
</description>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fmakunbound</title>
<type>Function</type>
<arguments>SYMBOL</arguments>
<package>lisp</package>
<description>
指定されたシンボルの関数定義への束縛を解消します。
これ以降fboundpはnilを返すようになります。シンボルへの値と関数定義の束縛
は独立しているので、fmakunboundをしてもboundpの結果は変わりません。

使用例：
  ;;; 関数定義への束縛を解消してみる。
  (defun foo (x) (* x 3))       =&gt; foo
  (fboundp 'foo)                =&gt; t
  (fmakunbound 'foo)            =&gt; foo
  (fboundp 'foo)                =&gt; nil
</description>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>type-of</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
与えられたオブジェクトの型を返します。
(typep OBJECT (type-of OBJECT))は必ずtになります。

使用例：
  ;;; それぞれの型を調べてみる。
  (type-of 1)
  =&gt; integer
  (type-of 2.2)
  =&gt; single-float
  (type-of #'car)
  =&gt; compiled-function
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>null</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTが()ならばt、それ以外ならnilを返します。

  (null x) == (typep x 'null) == (eq x '())
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>symbolp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがsymbolならt、それ以外ならnilを返します。

  (symbolp x) == (typep x 'symbol)
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>atom</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがconsでなければt、それ以外ならnilを返します。

  (atom x) == (typep x 'atom) == (not (typep x 'cons))

注意：(atom '()) は '() == nilなのでt
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>consp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがconsならt、それ以外ならnilを返します。

  (consp x) == (typep x 'cons) == (not (typep x 'atom))

注意： (consp '()) は '() == nilなのでnil。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>listp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがconsか空リスト()ならt、それ以外ならnilを返します。

  (listp x) == (typep x 'list) == (typep x '(or cons null))
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>numberp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTが数値ならばt、それ以外ならnilを返します。

  (numberp x) == (typep x 'number)
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>integerp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがintegerならt、それ以外ならnilを返します。

  (integerp x) == (typep x 'integer)
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rationalp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがratioかintegerならt、それ以外ならnilを返します。

  (rationalp x) == (typep x 'rational)
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>floatp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがfloatならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>single-float-p</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがsingle-floatならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>short-float-p</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがshort-floatならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>double-float-p</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがdouble-floatならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>long-float-p</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがlong-floatならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>realp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがreal numberならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>complexp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがcomplex numberならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>characterp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがcharacterならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>stringp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがstringならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>simple-string-p</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがsimple-stringならt、それ以外ならnilを返します。

使用例：
  ;;; make-vectorを使ってsimple-stringでないstringを作ります。
  (setq var1 (make-vector 10 :element-type 'character)
        var2 (make-vector 10 :element-type 'character :fill-pointer 0))
  =&gt; ""
  (type-of var1)                =&gt; simple-string
  (type-of var2)                =&gt; string
  (simple-string-p var1)        =&gt; t
  (simple-string-p var2)        =&gt; nil
</description>
<seealso>simple-string</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>simple-string</title>
<type>Misc</type>
<arguments></arguments>
<package>lisp</package>
<description>
simple-string とはシンプルな文字列のことを指します。
共有可能でなく、フィルポインタを持たず、サイズ変更不可能な文字列のことで
す。formatやconcatを使って文字列を操作する場合にはsimple-stringのままです。

使用例：
  ;;; simple-stringの場合
  (type-of "abc") 
  =&gt; simple-string
</description>
<seealso>simple-string-p</seealso>
<section>データ型</section>
<file></file>
</chapter>

<chapter>
<title>vectorp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがvectorならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>simple-vector-p</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがsimple-vectorならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>arrayp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがarrayならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>functionp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTが関数ならt、それ以外ならnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>compiled-function-p</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがcompiled code objectならt、それ以外ならnilを返します。

使用例：
  ;;; carの型を調べてみる。
  (type-of #'car)
  =&gt; compiled-function
  (compiled-function-p #'car)
  =&gt; t
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>packagep</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがpackageならt、それ以外ならnilを返します。

使用例：
  ;;; 指定された文字列のパッケージがあるかを調べる。
  (setq pkg (find-package "win32"))     =&gt; nil
  (packagep pkg)                        =&gt; nil
  (setq pkg (find-package "winapi"))    =&gt; #&lt;package: winapi&gt;
  (packagep pkg)                        =&gt; t
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>eq</title>
<type>Function</type>
<arguments>eq X Y</arguments>
<package>lisp</package>
<description>
X と Y が同一オブジェクトならt、そうでないならnilを返します。
数値や文字列に対しては見かけ上同じでもtとなる保障はありません。xyzzyでは、
数値はtとなるが文字列ではnilとなるように実装されているようです。

使用例：
  ;;; eqで比較してみる。
  (eq 'foo 'foo)        =&gt; t            ; 仕様
  (eq 2 2)              =&gt; t            ; 処理系依存
  (eq "foo" "foo")      =&gt; nil  ; 処理系依存
  (eq '(1 2) '(1 2))    =&gt; nil  ; 処理系依存
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>eql</title>
<type>Function</type>
<arguments>eql X Y</arguments>
<package>lisp</package>
<description>
X と Y が同一オブジェクトか、同じ型の数値または文字型で値が等しいかを返します。
等しければtを、そうでなければnilを返します。eqとは異なり、値として等しい
かを判断します。ただし、中身までは見ないので文字列は対象外となります。

使用例：
  ;;; eqlで比較してみる。
  (eql 'foo 'foo)       =&gt; t            ; 仕様
  (eql 2 2)             =&gt; t            ; 仕様
  (eql "foo" "foo")     =&gt; nil  ; 処理系依存
  (eql '(1 2) '(1 2))   =&gt; nil  ; 処理系依存
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>equal</title>
<type>Function</type>
<arguments>equal X Y</arguments>
<package>lisp</package>
<description>
X と Y が同じ構造を持っていればtを、そうでなければnilを返します。

使用例：
  ;;; equalで比較してみる。
  (equal 'foo 'foo)     =&gt; t            ; 仕様
  (equal 2 2)           =&gt; t            ; 仕様
  (equal "foo" "foo")   =&gt; t            ; 仕様
  (equal '(1 2) '(1 2)) =&gt; t            ; 仕様
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>equalp</title>
<type>Function</type>
<arguments>x y</arguments>
<package>lisp</package>
<description>
equalと同じように X と Y を比較します。例えば大文字と小文字は区別しません。

使用例：
  ;;; equalpで比較してみる。
  (equalp "Foo" "foo")  =&gt; t
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get</title>
<type>Function</type>
<arguments>SYMBOL INDICATOR &amp;optional DEFAULT</arguments>
<package>lisp</package>
<description>
シンボルのプロパティを返します。

  SYMBOL    : プロパティを返すシンボル
  INDICATOR : プロパティのインジケータ

使用例：
  ;;; シンボルにプロパティを設定してみる。
  (get 'clyde 'species)                         =&gt; nil 
  (setf (get 'clyde 'species) 'elephant)        =&gt; elephant 
  (get 'clyde 'species)                         =&gt; elephant

  ;;; 関数の説明を取得してみる。
  (defun foo (x) "increment" (1+ x))            =&gt; foo
  (get 'foo 'lisp::function-documentation)      =&gt; "increment"
</description>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remprop</title>
<type>Function</type>
<arguments>SYMBOL INDICATOR</arguments>
<package>lisp</package>
<description>
シンボルのプロパティを削除します。

  SYMBOL    : プロパティを返すシンボル
  INDICATOR : プロパティのインジゲーター

使用例：
  ;;; 関数の説明を削除してみる。
  (defun foo (x) "increment" (1+ x))            =&gt; foo
  (get 'foo 'lisp::function-documentation)      =&gt; "increment"
  (remprop 'foo 'lisp::function-documentation)  =&gt; t
  (get 'foo 'lisp::function-documentation)      =&gt; nil
</description>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>symbol-plist</title>
<type>Function</type>
<arguments>SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルのプロパティリストを返す。

使用例：
  ;;; シンボルのプロパティリストを見てみる。
  (symbol-plist 'xyzzy)         =&gt; nil
  (setf (get 'xyzzy 'foo) 1)    =&gt; 1
  (symbol-plist 'xyzzy)         =&gt; (foo 1)
</description>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>getf</title>
<type>Function</type>
<arguments>getf PLACE INDICATOR &amp;optional DEFAULT</arguments>
<package>lisp</package>
<description>
インジケータと値のリストから、インジケータに一致する値を取得します。

  (get x y) == (getf (symbol-plist x) y)

使用例：
  ;;; 実用性は無いけれどgetfを使って取得してみる。
  (getf '(ind1 10 ind2 20 ind3 30) 'ind2)
  =&gt; 20
</description>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-properties</title>
<type>Function</type>
<arguments>get-properties PLACE INDICATOR-LIST</arguments>
<package>lisp</package>
<description>
2番目の引数がリストになっているgetfです。
一致すると多値で値を返します。

使用例：
  ;;; get-propertiesで値を取得してみる。
  (get-properties '(ind1 10 ind2 20 ind3 30) '(ind2))
  =&gt; ind2
     20
     (ind2 20 ind3 30)
</description>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>symbol-name</title>
<type>Function</type>
<arguments>SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルの名前を印字用の文字列として返します。

使用例：
  ;;; シンボルxyzzyを文字列にしてみる。
  (symbol-name 'xyzzy)
  =&gt; "xyzzy"
</description>
<seealso>intern</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-symbol</title>
<type>Function</type>
<arguments>PRINT-NAME</arguments>
<package>lisp</package>
<description>
印字名がPRINT-NAMEであるuninternedなシンボルを返します。

参考：
  evalmacs.l
</description>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-symbol</title>
<type>Function</type>
<arguments>SYMBOL &amp;optional COPY-PROPS</arguments>
<package>lisp</package>
<description>
同じ名前を持つuninternedなSYMBOLのコピーを返します。
COPY-PROPSがnon-nilなら、初期定義値、プロパティリストもコピーされます。
</description>
<seealso>uninterned</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>uninterned</title>
<type>Misc</type>
<arguments></arguments>
<description>
uninterned とは intern されていない状態を表します。
すなわちどのパッケージにも属していない状態です。

使用例：
  ;;; make-symbolでパッケージに属さないシンボルを作ってみる。
  (setq a (make-symbol "foo"))  =&gt; #:foo
  (symbol-package a)            =&gt; nil
</description>
<section>パッケージ</section>
<file></file>
</chapter>

<chapter>
<title>symbol-package</title>
<type>Function</type>
<arguments>SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルが属するパッケージを返します。
make-symbolとかgensymで生成されたシンボルはどのパッケージにも属しません。

使用例：
  ;;; uninternedなシンボルとそうでないシンボルを作ってみる。
  (setq foo 2)                          =&gt; foo
  (symbol-package 'foo)                 =&gt; #&lt;package: user&gt;
  
  (setq bar (make-symbol "bar"))        =&gt; #:bar
  (set bar 3)                           =&gt; 3
  (symbol-value bar)                    =&gt; 3
  (symbol-package bar)                  =&gt; nil
</description>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>endp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTが空かどうかを返します。
リストの終わりを判定するのに使用されます。nullと異なり、
例えば文字列を指定するとエラーを発生します。

  空リストもしくはnil   t
  空でないリスト        nil
  それ以外              エラー

使用例：
  ;;; nullとの違いを見てみる。
  (endp "foo")  =&gt; 不正なデータ型です: t: list
  (endp nil)    =&gt; t
  (null "foo")  =&gt;nil
  (null nil)    =&gt; t
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list-length</title>
<type>Function</type>
<arguments>LIST</arguments>
<package>lisp</package>
<description>
リストの長さを返します。
リストが循環している場合、length は結果を返さないかもしれませんが、
list-length は nil を返します。

使用例：
  ;;; リストの長さを比べてみる。
  (list-length '())             =&gt; 0 
  (list-length '(a b c d))      =&gt; 4 
  (list-length '(a (b c) d))    =&gt; 3 
  (let ((a '(x)))
    (setf (cdr a) a)
    (list-length a))            =&gt; nil
</description>
<seealso>length</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>last</title>
<type>Function</type>
<arguments>LIST &amp;optional (N 1)</arguments>
<package>lisp</package>
<description>
リストの末尾からN個分のリストを返します。

使用例：
  ;;; 末尾を取得してみる。
  (last '(a b c d))     =&gt; (d)
  (last '(a b c d) 2)   =&gt; (c d)
  (last '(a b c d) 5)   =&gt; (a b c d)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-list</title>
<type>Function</type>
<arguments>LIST</arguments>
<package>lisp</package>
<description>
リストのコピーを返します。
コピーとオリジナルはequalですが、eqではありません。コピーとオリジナルは
同じ構造を持っており、一番上位のリストの要素は同じものを共有しています。
一方を変えると他方も変わります。オリジナルと同じものを指している部分に下
線を引いています。

オリジナル：
  '(((1 2) . #\a) ((3 4) . #\b))

copy-list ：
  '(((1 2) . #\a) ((3 4) . #\b))
    ~~~~~~~~~~~~~ ~~~~~~~~~~~~~
使用例：
  ;;; [A] eqではないことを示してみます。
  (setq a '((1 2 3) (4 5 6)))   =&gt; ((1 2 3) (4 5 6))
  (setq b (copy-list a))        =&gt; ((1 2 3) (4 5 6))
  (eq a b)                      =&gt; nil
  (equal a b)                   =&gt; t
  ;;; [B] car同士はeqです。
  (eq (car a) (car b))          =&gt; t
  ;;; [C] caarを変えると変わるけど、carを変えても変わらない。
  (progn (setf (caar a) 7) a)   =&gt; ((7 2 3) (4 5 6))
  b                             =&gt; ((7 2 3) (4 5 6))
  (progn (setf (car a) 8) a)    =&gt; (8 (4 5 6))
  b                             =&gt; ((7 2 3) (4 5 6))
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-alist</title>
<type>Function</type>
<arguments>LIST</arguments>
<package>lisp</package>
<description>
連想リストのコピーを返します。例えばこんな連想リストをコピーした場合に、
オリジナルと同じものを指している部分に下線を引いています。copy-listでは
最上位の要素そのものがオリジナルと共有しているのに対し、copy-alistは第二
階層の要素を共有しています。

オリジナル：
  '(((1 2) . #\a) ((3 4) . #\b))

copy-list ：
  '(((1 2) . #\a) ((3 4) . #\b))
    ~~~~~~~~~~~~~ ~~~~~~~~~~~~~
copy-alist：
  '(((1 2) . #\a) ((3 4) . #\b))
     ~~~~~   ~~~   ~~~~~   ~~~

GNU Emacs Lisp Reference Manualによると、コピー元の連想リストとは独立し
て連想リストの修正を行えるようにするためとか。下の例でも示しているとおり、
copy-listでは元のリストまで変わってしまいます。

使用例：
  ;;; copy-listとcopy-alistの違いを見てみる。
  (setq a '((1 . #\a) (2 . #\b)))       =&gt; ((1 . #\a) (2 . #\b))
  (setq b (copy-list a))                =&gt; ((1 . #\a) (2 . #\b))
  (setq c (copy-alist a))               =&gt; ((1 . #\a) (2 . #\b))
  (rplacd (assoc 2 a) #\c)              =&gt; (2 . #\c)
  a                                     =&gt; ((1 . #\a) (2 . #\c))
  b                                     =&gt; ((1 . #\a) (2 . #\c))
  c                                     =&gt; ((1 . #\a) (2 . #\b))
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>revappend</title>
<type>Function</type>
<arguments>X Y</arguments>
<package>lisp</package>
<description>
Xを反転させてYをくっつけます。

  (revappend x y) == (append (reverse x) y)
  
revappendの方が効率が良いようです。
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nconc</title>
<type>Function</type>
<arguments>nconc &amp;rest LISTS</arguments>
<package>lisp</package>
<description>
複数のリストを引数にとってそれらを結合したリストを返します。
引数は変更されます。

使用例：
  ;;; リストをくっつけてみる。
  (setq x '(a b c))
  (setq y '(d e f))
  (nconc x y)
  =&gt; (a b c d e f) 
  x
  =&gt; (a b c d e f)
  y
  =&gt; (d e f)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nreconc</title>
<type>Function</type>
<arguments>X Y</arguments>
<package>lisp</package>
<description>
Xを反転させてYをくっつけます。

  (nreconc x y) == (nconc (nreverse x) y)

nreconcの方が効率が良いようです。
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rplaca</title>
<type>Function</type>
<arguments>X Y</arguments>
<package>lisp</package>
<description>
リストXのcarをYに置き換えて、置き換えたXを返します。
(progn (setf (car X) Y) X)と同じでしょうか。

使用例：
  ;;; 置き換えてみる。
  (setq g '(a b c)) 
  =&gt; (a b c)
  (rplaca (cdr g) 'd)
  =&gt; (d c) 
  g
  =&gt; (a d c)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rplacd</title>
<type>Function</type>
<arguments>X Y</arguments>
<package>lisp</package>
<description>
リストXのcdrをYに置き換えて、置き換えたXを返します。
(progn (setf (cdr X) Y) X)と同じでしょうか。

使用例：
  ;;; 置き換えてみる。
  (setq x '(a b c)) 
  (rplacd x 'd)
  =&gt; (a . d) 
  x
  =&gt; (a . d)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>subst</title>
<type>Function</type>
<arguments>NEW OLD TREE &amp;key :TEST :TEST-NOT :KEY</arguments>
<package>lisp</package>
<description>
TREEの中でOLDをNEWに置き換えたTREEのコピーを返します。
元のTREEはそのままです。

使用例：
  ;;; 階層のあるツリーをsubstしてみる。aはそのまま
  (setq a '((1 2) ((1 3) (1 4))))       =&gt; ((1 2) ((1 3) (1 4)))
  (subst 5 1 a)                         =&gt; ((5 2) ((5 3) (5 4)))
  a                                     =&gt; ((1 2) ((1 3) (1 4)))
</description>
<seealso>nsubst</seealso>
<seealso>subst-if</seealso>
<seealso>subst-if-not</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>
<chapter>
<title>nsubst</title>
<type>Function</type>
<arguments>NEW OLD TREE &amp;key :TEST :TEST-NOT :KEY</arguments>
<package>lisp</package>
<description>
TREEの中でOLDをNEWに置き換えたTREEを返します。
元のTREEは置き換えられます。

使用例：
  ;;; 階層のあるツリーをsubstしてみる。aはそのまま
  (setq a '((1 2) ((1 3) (1 4))))       =&gt; ((1 2) ((1 3) (1 4)))
  (nsubst 5 1 a)                        =&gt; ((5 2) ((5 3) (5 4)))
  a                                     =&gt; ((5 2) ((5 3) (5 4)))
</description>
<seealso>subst</seealso>
<seealso>nsubst-if</seealso>
<seealso>nsubst-if-not</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sublis</title>
<type>Function</type>
<arguments>ALIST TREE &amp;key :TEST :TEST-NOT :KEY</arguments>
<package>lisp</package>
<description>
TREEの中でALISTのKEYとのTESTを満たすものをVALUEに置き換えます。
元のTREEはそのままです。

使用例：
  ;;; a-&gt;1、b-&gt;2に変更
  (sublis '((a . 1) (b . 2)) '(a b c))
  =&gt; (1 2 c)
</description>
<seealso>nsublis</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nsublis</title>
<type>Function</type>
<arguments>ALIST TREE &amp;key :TEST :TEST-NOT :KEY</arguments>
<package>lisp</package>
<description>
TREEの中でALISTのKEYとのTESTを満たすものをVALUEに置き換えます。
元のTREEは置き換えられます。

使用例：
  ;;; fooの変換テーブルの内容に基づいてbarを変換します。
  (setq foo '((1 . #\a) (2 . #\b) (3 . #\c)))
  =&gt; ((1 . #\a) (2 . #\b) (3 . #\c))
  (setq bar '(1 (2 3) ((4 5 6) (7 8 9))))
  =&gt; (1 (2 3) ((4 5 6) (7 8 9)))
  (nsublis foo bar)
  =&gt; (#\a (#\b #\c) ((4 5 6) (7 8 9)))
  bar
  =&gt; (#\a (#\b #\c) ((4 5 6) (7 8 9)))
</description>
<seealso>sublis</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>member</title>
<type>Function</type>
<arguments>ITEM LIST &amp;key :TEST :TEST-NOT :KEY </arguments>
<package>lisp</package>
<description>
LISTの中でITEMとのTESTを満たすものがあれば一致したところからのリストを返します。
なければnilを返します。

使用例：
  (member 'e '(a b c d))
  =&gt; nil
  (member 'b '(a b c d))
  =&gt; (b c d)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>member-if</title>
<type>Function</type>
<arguments>PREDICATE LIST &amp;key :KEY </arguments>
<package>lisp</package>
<description>
LISTの中で条件PREDICATEを満たすものがあれば、そこからのリストを返します。
なければNILを返します。

使用例：
  (member-if #'numberp '(a b c))
  =&gt; nil
  (member-if #'numberp '(a b 3 c))
  =&gt; (3 c)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>member-if-not</title>
<type>Function</type>
<arguments>PREDICATE LIST &amp;key :KEY</arguments>
<package>lisp</package>
<description>
LISTの中で条件PREDICATEを満たさないものがあれば、そこからのリストを返します。
なければNILを返します。

使用例：
  (member-if-not #'numberp '(1 2 3))
  =&gt; nil
  (member-if-not #'numberp '(1 2 a 3))
  =&gt; (a 3)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>adjoin</title>
<type>Function</type>
<arguments>ITEM LIST &amp;key :TEST :TEST-NOT :KEY</arguments>
<package>lisp</package>
<description>
ITEMがLISTのmemberでなければ先頭に追加したLISTを返す。memberならLISTを
そのまま返します。

  (adjoin item list) == (if (member item list) list (cons item list))

  KEY : KEYに fn が指定された場合，xyzzyでは
    (adjoin item list) == (if (member item list :key fn) list (cons item list))
  となりますが，CLTL2では次のように動作し，非互換です．
    (adjoin item list) == (if (member (funcall fn item) list :key fn) list (cons item list))

使用例：
  (adjoin 'a '(b c d))
  =&gt; (a b c d)
  (adjoin 'b '(a b c d))
  =&gt; (a b c d)
  (adjoin '(a) '((b) (c) (d)) :key #'car)
  =&gt; ((a) (b) (c) (d))
</description>
<seealso>pushnew</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>acons</title>
<type>Function</type>
<arguments>KEY DATUM A-LIST</arguments>
<package>lisp</package>
<description>
(KEY . DATUM)をA-LISTに加えた連想リストを返します。

  (acons x y a) == (cons (cons x y) a)

使用例：
  (setq foo '((b . 2))) =&gt; ((b . 2))
  (acons 'a 1 foo)      =&gt; ((a . 1) (b . 2))
  foo                   =&gt; ((b . 2))
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pairlis</title>
<type>Function</type>
<arguments>KEYS DATA &amp;optional A-LIST</arguments>
<package>lisp</package>
<description>
二つのリストKEYSとDATAから要素を一つずつ組み合わせた連想リストを作って返します。
A-LISTが与えられればそれに加えて返します。

  '(1 2 3 4 5) ─┬→ '((5 . e) (4 . d) (3 . c) (2 . b) (1 . a))
  '(a b c d e) ─┘

使用例：
  (pairlis '(one two) '(1 2) '((three . 3)))
  =&gt; ((two . 2) (one . 1) (three . 3))
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>assoc</title>
<type>Function</type>
<arguments>ITEM A-LIST &amp;key :TEST :TEST-NOT :KEY</arguments>
<package>lisp</package>
<description>
連想リストA-LISTの中でcar部がITEMとのTESTを満たす最初のペアを返します。

使用例：
  (assoc 'r '((a . b) (c . d) (r . x) (s . y) (r . z))) 
  =&gt;  (r . x) 
  (assoc 'goo '((foo . bar) (zoo . goo)))
  =&gt; nil 
  (assoc '2 '((1 a b c) (2 b c d) (-7 x y z)))
  =&gt; (2 b c d)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>assoc-if</title>
<type>Function</type>
<arguments>PREDICATE A-LIST &amp;key :KEY</arguments>
<package>lisp</package>
<description>
連想リストA-LISTの中でcar部がPREDICATEを満たす最初のペアを返します。

使用例：
  (assoc-if #'numberp '((a . b) (1 . c) (2 . d)))
  =&gt; (1 . c)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>assoc-if-not</title>
<type>Function</type>
<arguments>PREDICATE A-LIST &amp;key :KEY</arguments>
<package>lisp</package>
<description>
連想リストA-LISTの中でcar部がPREDICATEを満たさない最初のペアを返します。

使用例：
  (assoc-if-not #'numberp '((a . b) (1 . c) (2 . d)))
  =&gt; (a . b)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rassoc</title>
<type>Function</type>
<arguments>ITEM A-LIST &amp;key :TEST :TEST-NOT :KEY </arguments>
<package>lisp</package>
<description>
連想リストA-LISTの中でcdr部がITEMとのTESTを満たす最初のペアを返します。

使用例：
  (rassoc 'a '((a . b) (b . c) (c . a) (z . a)))
  =&gt; (c . a)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rassoc-if</title>
<type>Function</type>
<arguments>PREDICATE A-LIST &amp;key :KEY </arguments>
<package>lisp</package>
<description>
連想リストA-LISTの中でcdr部がPREDICATEを満たす最初のペアを返します。

使用例：
  (rassoc-if #'numberp '((a . b) (1 . c) (2 . 4)))
  =&gt; (2 . 4)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rassoc-if-not</title>
<type>Function</type>
<arguments>PREDICATE A-LIST &amp;key :KEY</arguments>
<package>lisp</package>
<description>
連想リストA-LISTの中でcdr部がPREDICATEを満たさない最初のペアを返します。

使用例：
  (rassoc-if-not #'numberp '((a . b) (1 . c) (2 . d)))
  =&gt; (a . b)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>sequencep</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがsequenceなら真、そうでなければnilを返します。
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>elt</title>
<type>Function</type>
<arguments>SEQUENCE INDEX</arguments>
<package>lisp</package>
<description>
SEQUENCEのINDEX番目の要素を返します。
INDEXは0を基底とします。なければnilを返します。
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>subseq</title>
<type>Function</type>
<arguments>SEQUENCE START &amp;optional END</arguments>
<package>lisp</package>
<description>
SEQUENCEのSTART番目からENDもしくは最後までの新しいsequenceを返します。
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-seq</title>
<type>Function</type>
<arguments>シーケンス</arguments>
<package>lisp</package>
<description>
SEQUENCEのコピーを作成して返します。元のSEQUENCEとはequalpだがeqではありません。

  (copy-seq x) == (subseq x 0)
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>reverse</title>
<type>Function</type>
<arguments>シーケンス</arguments>
<package>lisp</package>
<description>
SEQUENCEを逆順にした新しいSEQUENCEを作成して返します。元のsequenceはそのままです。
</description>
<seealso>nreverse</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nreverse</title>
<type>Function</type>
<arguments>シーケンス</arguments>
<package>lisp</package>
<description>
SEQUENCEを逆順にした新しいSEQUENCEを作成して返します。元のsequenceは置き
換えられます。
</description>
<seealso>reverse</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-sequence</title>
<type>Function</type>
<arguments>TYPE SIZE &amp;key :INITIAL-ELEMENT</arguments>
<package>lisp</package>
<description>
要素のタイプがtypeでサイズがsizeなシーケンスを作成して返します。
INITIAL-ELEMENTが与えられた場合はそれぞれの項目はそれで初期化されます。

使用例：
  ;;; #\aが8文字の文字列を作ってみる
  (make-sequence 'string 8 :initial-element #\a)
  =&gt; "aaaaaaaa"
  (make-sequence 'list 4 :initial-element "abc")
  =&gt; (#1="abc" #1# #1# #1#)
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fill</title>
<type>Function</type>
<arguments>SEQUENCE ITEM &amp;key :START :END</arguments>
<package>lisp</package>
<description>
SEQUENCEのそれぞれをITEMに置換えます。元のSEQUENCEは置き換えられます。

使用例：
  ;;; シーケンスを作って、変更してみる。
  (setq foo (make-sequence 'string 8 :initial-element #\a))
  =&gt; "aaaaaaaa"
  (fill foo #\b :start 3 :end 4)
  =&gt; "aaabaaaa"
  foo
  =&gt; "aaabaaaa"
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>replace</title>
<type>Function</type>
<arguments>SEQUENCE1 SEQUENCE2 &amp;key :START1 :END1 :START2 :END2</arguments>
<package>lisp</package>
<description>
SEQUENCE1をSEQUENCE2で置換します。元のSEQUENCEは置き換えられます。
SEQUENCE1のSTART1-END1の位置に、SEQUENCE2のSTART2-END2を挿入します。

使用例：
  (setq foo (make-sequence 'string 8 :initial-element #\a))
  =&gt; "aaaaaaaa"
  (setq bar (make-sequence 'string 3 :initial-element #\b))
  =&gt; "bbb"
  (replace foo bar)
  =&gt; "bbbaaaaa"
  (replace foo bar :start1 4 :end1 5)
  =&gt; "bbbabaaa"
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remove</title>
<type>Function</type>
<arguments>ITEM SEQUENCE &amp;key :FROM-END :TEST :TEST-NOT :START :END :COUNT :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でITEMと一致するものを削除したSEQUENCEを返します。
元のSEQUENCEはそのまま。元のSEQUENCEを変更したければ、deleteを使うこと。

  :COUNT    削除する文字数を制限します。
  :FROM-END :COUNTが指定された場合にのみ意味を持ちます。
            nil SEQUENCEの先頭から削除します。
            t   SEQUENCEの後尾から削除します。

使用例：
  ;;; removeとdeleteを使ってみる。
  (setq foo "abcabcdef")        =&gt; "abcabcdef"
  (remove #\b foo)              =&gt; "acacdef"
  foo                           =&gt; "abcabcdef"
  (delete #\b foo)              =&gt; "acacdef"
  foo                           =&gt; "acacdef"
</description>
<seealso>delete</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remove-if</title>
<type>Function</type>
<arguments>PREDICATE SEQUENCE &amp;key :FROM-END :START :END :COUNT :KEY </arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たすものを削除したSEQUENCEを返します。
元のSEQUENCEはそのまま。
</description>
<seealso>delete-if</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remove-if-not</title>
<type>Function</type>
<arguments>PREDICATE SEQUENCE &amp;key :FROM-END :START :END :COUNT :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たさないものを削除したSEQUENCEを返す。
元のSEQUENCEはそのまま。
</description>
<seealso>delete-if-not</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete</title>
<type>Function</type>
<arguments>ITEM SEQUENCE &amp;key :FROM-END :TEST :TEST-NOT :START :END :COUNT :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でITEMと一致するものを削除したSEQUENCEを返します。
元のSEQUENCEは変更されます。元のSEQUENCEを保持したければ、removeを使うこと。

  :COUNT    削除する文字数を制限します。
  :FROM-END :COUNTが指定された場合にのみ意味を持ちます。
            nil SEQUENCEの先頭から削除します。
            t   SEQUENCEの後尾から削除します。

使用例：
  ;;; removeとdeleteを使ってみる。
  (setq foo "abcabcdef")        =&gt; "abcabcdef"
  (remove #\b foo)              =&gt; "acacdef"
  foo                           =&gt; "abcabcdef"
  (delete #\b foo)              =&gt; "acacdef"
  foo                           =&gt; "acacdef"
</description>
<seealso>remove</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-if</title>
<type>Function</type>
<arguments>PREDICATE SEQUENCE &amp;key :FROM-END :START :END :COUNT :KEY </arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たすものを削除します。
</description>
<seealso>remove-if</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-if-not</title>
<type>Function</type>
<arguments>PREDICATE SEQUENCE &amp;key :FROM-END :START :END :COUNT :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たさないものを削除します。
</description>
<seealso>remove-if-not</seealso>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find</title>
<type>Function</type>
<arguments>ITEM SEQUENCE &amp;key :FROM-END :TEST :TEST-NOT :START :END :KEY </arguments>
<package>lisp</package>
<description>
SEQUENCEの中でITEMとのTESTを満たすものがあればそれを返します。なければnilを返します。

使用例：
  ;;; リストから'aを探してみる。
  (find 'a '(e c a b))
  =&gt; a
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-if</title>
<type>Function</type>
<arguments>PREDICATE SEQUENCE &amp;key :FROM-END :START :END :KEY </arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たすものがあればそれを返します。なければnilを返します。
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-if-not</title>
<type>Function</type>
<arguments>PREDICATE SEQUENCE &amp;key :FROM-END :START :END :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たさないものがあればそれを返します。なければNILを返します。
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>position</title>
<type>Function</type>
<arguments>ITEM SEQUENCE &amp;key :FROM-END :TEST :TEST-NOT :START :END :KEY </arguments>
<package>lisp</package>
<description>
SEQUENCEの中でITEMとのTESTを満たすものがあればそのインデックスを返します。
なければnilを返します。

使用例：
  ;;; リストの中から'aのインデックスを調べる
  (position 'a '(e c a b))
  =&gt; 2
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>position-if</title>
<type>Function</type>
<arguments>PREDICATE SEQUENCE &amp;key :FROM-END :START :END :KEY </arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たすものがあればそのインデックスを返します。
なければnilを返します。
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>position-if-not</title>
<type>Function</type>
<arguments>PREDICATE SEQUENCE &amp;key :FROM-END:START :END :KEY</arguments>
<package>lisp</package>
<description>
SEQUENCEの中でPREDICATEを満たさないものがあればそのインデックスを返します。
なければnilを返します。
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-string</title>
<type>Function</type>
<arguments>STRING</arguments>
<package>lisp</package>
<description>
STRINGのコピーを返します。

使用例：
  ;;; 単にsetqしただけでは同じオブジェクトになっている。
  (setq foo "abc")              =&gt; "abc"
  (setq bar foo)                =&gt; "abc"
  (eq foo bar)                  =&gt; t

  ;;; コピーすると別のオブジェクトになる。
  (setq bar (copy-string foo))  =&gt; "abc"
  (eq foo bar)                  =&gt; nil
</description>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char</title>
<type>Function</type>
<arguments>STRING INDEX</arguments>
<package>lisp</package>
<description>
STRINGのINDEX番目の文字を返します。
INDEXは0を基底とします。

使用例：
  ;;; 先頭から最後まで取得する。
  (char "foo" -1) =&gt; 範囲外の値です: -1
  (char "foo" 0)  =&gt; #\f
  (char "foo" 1)  =&gt; #\o
  (char "foo" 2)  =&gt; #\o
  (char "foo" 3)  =&gt; 範囲外の値です: 3
</description>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>schar</title>
<type>Function</type>
<arguments>SIMPLE-STRING INDEX</arguments>
<package>lisp</package>
<description>
SIMPLE-STRINGのINDEX番目の文字を返します。
INDEXは0を基底とします。

使用例：
  ;;; simpleでないstringでscharを使ってみる。
  (setq foo (make-vector 10 :initial-element #\a :element-type 'character :fill-pointer 3))
                        =&gt; "aaa"
  (schar foo 0)         =&gt; 不正なデータ型です: "aaa": simple-string
  (setq bar "aaa")      =&gt; "aaa"
  (schar bar 0)         =&gt; #\a
</description>
<seealso>simple-string</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string=</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を比較して等しければt、そうでなければnilを返します。
英字の大文字と小文字は区別します。

使用例：
  (string= "foo" "foo")
  =&gt; t
  (string= "foo" "Foo")
  =&gt; nil
  (string= "together" "frog" :start1 1 :end1 3 :start2 2)
  =&gt; t

参考：
  case-sensitive        case-insensitive
  ----                  ----
  string=               string-equal
  string/=              string-not-equal
  string&lt;               string-lessp
  string&gt;               string-greaterp
  string&lt;=              string-not-greaterp
  string&gt;=              string-not-lessp
</description>
<seealso>string-equal</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-equal</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して等しければt、そうでなければnilを返します。

使用例：
  (string-equal "foo" "foo")
  =&gt; t
  (string-equal "foo" "Foo")
  =&gt; t
</description>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string/=</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を比較して等しくなければt、そうでなければnilを返します。
英字の大文字と小文字は区別します。string=の反対の機能です。
</description>
<section>文字列</section>
<seealso>string=</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-not-equal</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して等しくなければt、そうでなければnilを返します。
string-equalの反対の機能です。
</description>
<section>文字列</section>
<seealso>string-equal</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string&lt;</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<description>
STRING1とSTRING2を比較して条件に合えば一致しない文字のインデックスを、そうでなければnilを返します。

使用例：
  (string&lt;"aa" "aa")
  =&gt; nil
  (string&lt;"aa" "ab")
  =&gt; 1
</description>
<section>文字列</section>
<seealso>string-lessp</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-lessp</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して条件に合えば一致しない文字のインデックスを、そうでなければnilを返します。

使用例：  
  (string-lessp "Aa" "ab")
  =&gt; 1
  (string-lessp "ac" "AB")
  =&gt; nil  
</description>
<section>文字列</section>
<seealso>string&lt;</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string&gt;</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を比較して条件に合えば一致しない文字のインデックスを、そうでなければnilを返します。

使用例：
  (string&gt; "ac" "ab")
  =&gt; 1
  (string&gt; "ac" "ac")
  =&gt; nil
  (string&gt; "AC" "ab")
  =&gt; nil
</description>
<section>文字列</section>
<seealso>string-greaterp</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-greaterp</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して、等しければ一致しない文字のインデックスを、そうでなければnilを返します。

使用例：
  (string-greaterp "ac" "ab")
  =&gt; 1
  (string-greaterp "ac" "ac")
  =&gt; nil
  (string-greaterp "AC" "ab")
  =&gt; 1
</description>
<section>文字列</section>
<seealso>string&gt;</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string&lt;=</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<description>
STRING1とSTRING2を比較して条件に合えば一致しない文字のインデックスを、そうでなければnilを返します。
</description>
<section>文字列</section>
<seealso>string-not-greaterp</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-not-greaterp</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して条件に合えば一致しない文字のインデックスを、そうでなければnilを返します。
</description>
<section>文字列</section>
<seealso>string&lt;=</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string&gt;=</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を比較して条件に合えば一致しない文字のインデックスを、そうでなければnilを返します。
</description>
<section>文字列</section>
<seealso>string-not-lessp</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-not-lessp</title>
<type>Function</type>
<arguments>STRING1 STRING2 &amp;key :START1 :END1 :START2 :END2</arguments>
<package>lisp</package>
<description>
STRING1とSTRING2を大文字小文字に関係なく比較して条件に合えば一致しない文字のインデックスを、そうでなければnilを返します。
</description>
<section>文字列</section>
<seealso>string&gt;=</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-upcase</title>
<type>Function</type>
<arguments>STRING &amp;key :START :END</arguments>
<package>lisp</package>
<description>
STRINGを大文字にした文字列を返します。元のSTRINGは変更されません。

使用例：
  (string-upcase "xyzzy")
  =&gt; "XYZZY"
  (string-upcase "xyzzy" :start 2 :end 4)
  =&gt; "xyZZy"
</description>
<section>文字列</section>
<seealso>nstring-upcase</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-downcase</title>
<type>Function</type>
<arguments>STRING &amp;key :START :END</arguments>
<package>lisp</package>
<description>
STRINGを小文字にした文字列を返します。元のSTRINGは変更されません。

使用例：
  (string-downcase "XyZzY")
  =&gt; "xyzzy"
  (string-downcase "XYZZY" :start 2 :end 4)
  =&gt; "XYzzY"
</description>
<section>文字列</section>
<seealso>nstring-downcase</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-capitalize</title>
<type>Function</type>
<arguments>STRING &amp;key :START :END</arguments>
<package>lisp</package>
<description>
STRINGの内部の単語の先頭を大文字に、それ以外を小文字にした文字列を返します。

使用例：
  (string-capitalize "xYZzY")
  =&gt; "Xyzzy"  
  (string-capitalize "tHis iS a pEn.")
  =&gt; "This Is A Pen."
</description>
<seealso>nstring-capitalize</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nstring-upcase</title>
<type>Function</type>
<arguments>STRING &amp;key :START :END</arguments>
<package>lisp</package>
<description>
STRINGを大文字にした文字列を返します。元のSTRINGは変更されます。

使用例：
  (setq foo "xyzzy")
  =&gt; "xyzzy"
  (nstring-upcase foo)
  =&gt; "XYZZY"
  foo
  =&gt; "XYZZY"
</description>
<section>文字列</section>
<seealso>string-upcase</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nstring-downcase</title>
<type>Function</type>
<arguments>STRING &amp;key :START :END</arguments>
<package>lisp</package>
<description>
STRINGを小文字にした文字列を返します。元のSTRINGは変更されます。

使用例：  
  (setq foo "XyZzY")
  =&gt; "XyZzY"
  (nstring-downcase foo)
  =&gt; "xyzzy"
  foo
  =&gt; "xyzzy"  
</description>
<section>文字列</section>
<seealso>string-downcase</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nstring-capitalize</title>
<type>Function</type>
<arguments>STRING &amp;key :START :END</arguments>
<package>lisp</package>
<description>
STRINGの内部の単語の先頭を大文字に、それ以外を小文字にします。
元のSTRINGは変更されます。

使用例：  
  (setq foo "tHis iS a pEn.")
  =&gt; "tHis iS a pEn."
  (nstring-capitalize foo)
  =&gt; "This Is A Pen."
  foo
  =&gt; "This Is A Pen."
</description>
<seealso>string-capitalize</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string</title>
<type>Function</type>
<arguments>X</arguments>
<package>lisp</package>
<description>
Xが文字列ならそれを返します。シンボルならその名前を返します。

使用例：
  (string "foo")
  =&gt; "foo"
  (string 'bar)
  =&gt; "bar"
</description>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>zerop</title>
<type>Function</type>
<arguments>NUMBER</arguments>
<package>lisp</package>
<description>
NUMBERがゼロならt、そうでなければnilを返します。

使用例：  
  (zerop 0)
  =&gt; t
  (zerop 1)
  =&gt; nil
  (zerop 0.0)
  =&gt; t
  (zerop -0.00)
  =&gt; t
</description>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>plusp</title>
<type>Function</type>
<arguments>NUMBER</arguments>
<package>lisp</package>
<description>
NUMBERがゼロより大きければt、そうでなければnilを返します。

使用例：
  (plusp 0)
  =&gt; nil
  (plusp 1)
  =&gt; t
  (plusp 0.00001)
  =&gt; t
</description>
<seealso>minusp</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>minusp</title>
<type>Function</type>
<arguments>NUMBER</arguments>
<package>lisp</package>
<description>
NUMBERがゼロより小さければt、そうでなければnilを返します。

使用例：
  (minusp 0)
  =&gt; nil
  (minusp -1)
  =&gt; t
  (minusp -0.00001)
  =&gt; t
</description>
<seealso>plusp</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>oddp</title>
<type>Function</type>
<arguments>INTEGER</arguments>
<package>lisp</package>
<description>
INTEGERが奇数ならばt、そうでなければnilを返します。

使用例：  
  (oddp 1)
  =&gt; t
  (oddp 0)
  =&gt; nil
  (oddp -35)
  =&gt; t
</description>
<seealso>evenp</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>evenp</title>
<type>Function</type>
<arguments>INTEGER</arguments>
<package>lisp</package>
<description>
INTEGERが偶数ならばt、そうでなければnilを返します。

使用例：  
  (evenp 2)
  =&gt; t
  (evenp 0)
  =&gt; t
  (evenp 1)
  =&gt; nil
</description>
<seealso>oddp</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>=</title>
<type>Function</type>
<arguments>NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数がすべて等しければt、そうでなければnilを返します。

使用例：  
  (= 3 3)
  =&gt; t
  (= 3 4)
  =&gt; nil
  (= 3 3 3 3)
  =&gt; t
  (= 3 3 3 4)
  =&gt; nil
</description>
<seealso>/=</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>/=</title>
<type>Function</type>
<arguments>NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数がすべて異なっていればt、そうでなければnilを返します。

使用例：  
  (/= 2 3)
  =&gt; t
  (/= 3 3)
  =&gt; nil
  (/= 2 3 4 5)
  =&gt; t
  (/= 2 3 4 2)
  =&gt; nil
</description>
<seealso>=</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>&lt;</title>
<type>Function</type>
<arguments>NUMBER &amp;rest MORE-NUMBERS</arguments>
<description>
引数が小さい順に並んでいればt、そうでなければnilを返します。

使用例：  
  (&lt; 2 3 4)
  =&gt; t
  (&lt; 2 4 3 5)
  =&gt; nil
</description>
<seealso>&gt;</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>&gt;</title>
<type>Function</type>
<arguments>NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数が大きい順に並んでいればt、そうでなければnilを返します。

使用例：  
  (&gt; 3 2 1)
  =&gt; t
  (&gt; 3 2 1 4)
  =&gt; nil
</description>
<seealso>&lt;</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>&lt;=</title>
<type>Function</type>
<arguments>NUMBER &amp;rest MORE-NUMBERS</arguments>
<description>
隣り合った引数がすべて&lt;=の関係ならt、そうでなければnilを返します。

使用例：  
  (&lt;= 2 3 3 4)
  =&gt; t
  (&lt;= 2 4 3 5)
  =&gt; nil
</description>
<seealso>&gt;=</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>&gt;=</title>
<type>Function</type>
<arguments>NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
隣り合った引数がすべて&gt;=の関係ならt、そうでなければnilを返します。
  
使用例：  
  (&gt;= 4 3 3 2 1)
  =&gt; t
  (&gt;= 4 2 3 1)
  =&gt; nil
</description>
<seealso>&lt;=</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>max</title>
<type>Function</type>
<arguments>NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数の中で最大の数値を返します。

使用例：  
  (max 3)
  =&gt; 3
  (max -3 0 2)
  =&gt; 2
  (max 2.5 1)
  =&gt; 2.5
  (max 3 2.5)
  =&gt; 3
</description>
<seealso>min</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>min</title>
<type>Function</type>
<arguments>NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数の中で最小の数値を返します。

使用例：
  (min 3)
  =&gt; 3
  (min -2 0 3)
  =&gt; -2
  (min 2.5 1)
  =&gt; 1
</description>
<seealso>max</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>1+</title>
<type>Function</type>
<arguments>NUM</arguments>
<package>lisp</package>
<description>
NUMに1を足した数を返します。

使用例：  
  (1+ 1)
  =&gt; 2
</description>
<seealso>1-</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>1-</title>
<type>Function</type>
<arguments>NUM</arguments>
<package>lisp</package>
<description>
NUMから1を引いた数を返します。

使用例：  
  (1- 2)
  =&gt; 1
</description>
<seealso>1+</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>+</title>
<type>Function</type>
<arguments>&amp;rest NUMBERS</arguments>
<package>lisp</package>
<description>
引数を全て加算して返します。

使用例：  
  (+ 1 2 3)
  =&gt; 6
  (+ 1.2 4 -2)
  =&gt; 3.2
</description>
<seealso>-</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>-</title>
<type>Function</type>
<arguments>NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数が一つの場合にはその数値をマイナスにしたものを返します。
引数が二つ以上の場合には一つ目の引数からその他の引数を減算した数値を返します。

使用例：
  (- 3)
  =&gt; -3
  (- 3 2 1)
  =&gt; 0
</description>
<seealso>+</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*</title>
<type>Function</type>
<arguments>&amp;rest NUMBERS</arguments>
<package>lisp</package>
<description>
引数を全て剰算した数値を返します。

使用例：  
  (* 1 2 3)
  =&gt; 6
</description>
<seealso>/</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>/</title>
<type>Function</type>
<arguments>NUMBER &amp;rest MORE-NUMBERS</arguments>
<package>lisp</package>
<description>
引数が一つの場合には 1 を引数で除算した数値を返します。
引数が二つ以上の場合には一つ目の引数を二つ目の引数全てで除算した数値を返します。
  
使用例：  
  (/ 2)
  =&gt; 1/2  
  (/ 3 2 1)
  =&gt; 3/2
  (/ 4 3 2)
  =&gt; 2/3
</description>
<seealso>*</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>gcd</title>
<type>Function</type>
<arguments>&amp;rest INTEGERS</arguments>
<package>lisp</package>
<description>
引数の最大公約数を返します。

使用例：
  (gcd 91 70)
  =&gt; 7
  (gcd 63 -42 35)
  =&gt; 7
  (gcd -3)
  =&gt; -3
  (gcd 35 8)
  =&gt; 1
</description>
<seealso>lcm</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>lcm</title>
<type>Function</type>
<arguments>INTEGER &amp;rest MORE-INTEGERS</arguments>
<package>lisp</package>
<description>
引数の最小公倍数を返します。

使用例：  
  (lcm 14 35)
  =&gt; 70
  (lcm 0 5)
  =&gt; 0
  (lcm 1 2 3 4 5 6)
  =&gt; 60
</description>
<seealso>gcd</seealso>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>floor</title>
<type>Function</type>
<arguments>NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
NUMBERを負の無限大方向に丸めます。
DIVISORを省略した場合にはNUMBERを越えない最大の整数になります。

使用例：  
  (floor 2.2)
  =&gt; 2
  (floor 2.8)
  =&gt; 2
  (floor -2.4)
  =&gt; -3  
  (multiple-value-list (floor 2.2))
  =&gt; (2 0.2)
</description>
<section>数値</section>
<seealso>ceiling</seealso>
<seealso>truncate</seealso>
<seealso>round</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ceiling</title>
<type>Function</type>
<arguments>NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
NUMBERを正の無限大方向に丸めます。
DIVISORを省略した場合にはNUMBER以上の最小の整数になります。

使用例：  
  (ceiling 2.2)
  =&gt; 3
  (ceiling 2.8)
  =&gt; 3
  (ceiling -2.2)
  =&gt; -2  
  (multiple-value-list (ceiling 2.2))
  =&gt; (3 -0.8)
</description>
<section>数値</section>
<seealso>floor</seealso>
<seealso>truncate</seealso>
<seealso>round</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>truncate</title>
<type>Function</type>
<arguments>NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
NUMBERを0の方向に丸めます。

使用例：
  (truncate 2.8)
  =&gt; 2
  (truncate -2.8)
  =&gt; -2
  (multiple-value-list (truncate 2.8))
  =&gt; (2 0.8)
</description>
<section>数値</section>
<seealso>floor</seealso>
<seealso>ceiling</seealso>
<seealso>round</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>round</title>
<type>Function</type>
<arguments>NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
NUMBERを近い方の整数に丸めます。
ちょうど0.5の場合には偶数方向に丸められます。

使用例： 
  (round 2.5)
  =&gt; 2
  (round 2.6)
  =&gt; 3
  (round 3.5)
  =&gt; 4
  (round -2.5)
  =&gt; -2
  (round -2.6)
  =&gt; -3
  (multiple-value-list (round 2.5))
  =&gt; (2 0.5)
</description>
<section>数値</section>
<seealso>floor</seealso>
<seealso>ceiling</seealso>
<seealso>truncate</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>mod</title>
<type>Function</type>
<arguments>NUMBER DIVISOR</arguments>
<package>lisp</package>
<description>
(floor NUMBER DIVISOR)の戻り値の二つ目を返します。

使用例：
  (mod 13 4)
  =&gt; 1
  (mod -13 4)
  =&gt; 3
</description>
<section>数値</section>
<seealso>floor</seealso>
<seealso>rem</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rem</title>
<type>Function</type>
<arguments>NUMBER DIVISOR</arguments>
<package>lisp</package>
<description>
(truncate NUMBER DIVISOR)の戻り値の二つ目を返します。

使用例：  
  (rem 13 4)
  =&gt; 1
  (rem -13 4)
  =&gt; -1
</description>
<section>数値</section>
<seealso>truncate</seealso>
<seealso>mod</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ffloor</title>
<type>Function</type>
<arguments>NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
floorと同じですが浮動小数点数を返します。
</description>
<section>数値</section>
<seealso>floor</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fceiling</title>
<type>Function</type>
<arguments>NUMBER &amp;optional DIVISOR</arguments>
<package>lisp</package>
<description>
ceilingと同じですが浮動小数点数を返します。
</description>
<section>数値</section>
<seealso>ceiling</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ftruncate</title>
<type>Function</type>
<arguments>number &amp;optional divisor</arguments>
<package>lisp</package>
<description>
truncateと同じですが浮動小数点数を返します。
</description>
<section>数値</section>
<seealso>truncate</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fround</title>
<type>Function</type>
<arguments>number &amp;optional divisor</arguments>
<package>lisp</package>
<description>
roundと同じですが浮動小数点数を返します。
</description>
<section>数値</section>
<seealso>round</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>upper-case-p</title>
<type>Function</type>
<arguments>CHARACTER</arguments>
<package>lisp</package>
<description>
CHARACTERが大文字ならt、そうでなければnilを返します。

使用例：  
  (upper-case-p #\A)
  =&gt; t
  (upper-case-p #\a)
  =&gt; nil
  (upper-case-p #\RET)
  =&gt; nil
</description>
<section>文字</section>
<seealso>lower-case-p</seealso>
<seealso>both-case-p</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>lower-case-p</title>
<type>Function</type>
<arguments>CHARACTER</arguments>
<package>lisp</package>
<description>
CHARACTERが小文字ならt、そうでなければnilを返します。

使用例：
  (lower-case-p #\a)
  =&gt; t
  (lower-case-p #\A)
  =&gt; nil
  (lower-case-p #\RET)
  =&gt; nil
</description>
<section>文字</section>
<seealso>upper-case-p</seealso>
<seealso>both-case-p</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>both-case-p</title>
<type>Function</type>
<arguments>CHARACTER</arguments>
<package>lisp</package>
<description>
CHARACTERが大文字小文字のある文字ならt、そうでなければnilを返します。

使用例：  
  (both-case-p #\a)
  =&gt; t
  (both-case-p #\A)
  =&gt; t
  (both-case-p #\RET)
  =&gt; nil
</description>
<section>文字</section>
<seealso>lower-case-p</seealso>
<seealso>upper-case-p</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>digit-char-p</title>
<type>Function</type>
<arguments>CHARACTER</arguments>
<package>lisp</package>
<description>
CHARACTERが数字ならt、そうでなければnilを返します。

使用例：  
  (digit-char-p #\1)
  =&gt; t
  (digit-char-p #\a)
  =&gt; nil
  (digit-char-p #\RET)
  =&gt; nil
</description>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char=</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字がすべて等しければt、そうでなければnilを返します。

使用例：  
  (char= #\a #\a #\a)
  =&gt; t
  (char= #\a #\d)
  =&gt; nil
  (char= #\a #\A)
  =&gt; nil

参考：
  case-sensitive        case-insensitive
  ----                  ----
  char=                 char-equal
  char/=                char-not-equal
  char&lt;                 char-lessp
  char&gt;                 char-greaterp
  char&lt;=                char-not-greaterp
  char&gt;=                char-not-lessp
</description>
<section>文字</section>
<seealso>char-equal</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char/=</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て等しくなければt、そうでなければnilを返します。

使用例：  
  (char/= #\a #\b #\c)
  =&gt; t
  (char/= #\a #\b #\a)
  =&gt; nil
  (char/= #\a #\A)
  =&gt; t
</description>
<section>文字</section>
<seealso>char-not-equal</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char&lt;</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<description>
引数の文字が全て昇順ならt、そうでなければnilを返します。

使用例：  
  (char&lt; #\a #\b #\c)
  =&gt; t
  (char&lt; #\a #\b #\b)
  =&gt; nil
  (char&lt; #\A #\b)
  =&gt; t
  (char&lt; #\a #\B)
  =&gt; nil
</description>
<section>文字</section>
<seealso>char-lessp</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char&gt;</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て降順ならt、そうでなければnilを返します。

使用例：  
  (char&gt; #\c #\b #\a)
  =&gt; t
  (char&gt; #\c #\b #\d)
  =&gt; nil
  (char&gt; #\b #\A)
  =&gt; t
  (char&gt; #\a #\B)
  =&gt; t
</description>
<section>文字</section>
<seealso>char-greaterp</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char&lt;=</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<description>
隣り合った引数の関係がすべて昇順か等しければt、そうでなければnilを返します。

使用例：  
  (char&lt;= #\a #\b #\b #\c)
  =&gt; t
  (char&lt;= #\a #\b #\c #\b)
  =&gt; nil
</description>
<section>文字</section>
<seealso>char-not-greaterp</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char&gt;=</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
隣り合った引数の関係がすべて降順か等しければt、そうでなければnilを返します。

使用例：  
  (char&gt;= #\c #\b #\b #\a)
  =&gt; t
  (char&gt;= #\c #\b #\d)
  =&gt; nil
</description>
<section>文字</section>
<seealso>char-not-lessp</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-equal</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数がすべて大文字小文字関係なく等しければt、そうでなければnilを返します。

使用例：  
  (char-equal #\A #\a)
  =&gt; t
</description>
<section>文字</section>
<seealso>char=</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-not-equal</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数がすべて大文字小文字関係なく等しくなければt、そうでなければnilを返します。

使用例：
  (char-not-equal #\a #\b #\c)
  =&gt; t
  (char-not-equal #\a #\A)
  =&gt; nil
</description>
<section>文字</section>
<seealso>char/=</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-lessp</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て大文字小文字関係なく昇順ならt、そうでなければnilを返します。

使用例：  
  (char-lessp #\a #\b #\c)
  =&gt; t
  (char-lessp #\a #\b #\b)
  =&gt; nil
  (char-lessp #\A #\b)
  =&gt; t
  (char-lessp #\a #\B)
  =&gt; t
</description>
<section>文字</section>
<seealso>char&lt;</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-greaterp</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て大文字小文字関係なく降順ならt、そうでなければnilを返します。

使用例：
  (char-greaterp #\c #\b #\a)
  =&gt; t
  (char-greaterp #\c #\b #\b)
  =&gt; nil
  (char-greaterp #\b #\A)
  =&gt; t
  (char-greaterp #\B #\a)
  =&gt; t
</description>
<section>文字</section>
<seealso>char&gt;</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-not-greaterp</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て大文字小文字関係なく昇順か等しければt、そうでなければnilを返します。

使用例：  
  (char-not-greaterp #\a #\B #\c)
  =&gt; t
</description>
<section>文字</section>
<seealso>char&lt;=</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-not-lessp</title>
<type>Function</type>
<arguments>CHARACTER &amp;rest MORE-CHARACTERS</arguments>
<package>lisp</package>
<description>
引数の文字が全て大文字小文字関係なく降順か等しければt、そうでなければnilを返します。

使用例：  
  (char-not-lessp #\c #\B #\a)
  =&gt; t
</description>
<section>文字</section>
<seealso>char&gt;=</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-code</title>
<type>Function</type>
<arguments>CHARACTER</arguments>
<package>lisp</package>
<description>
CHARACTERの文字コードを返します。
文字コードとキャラクタの間の相互変換には、code-charを使います。

使用例：
  (char-code #\a)
  =&gt; 97
  (code-char (char-code #\a))
  =&gt; #\a
</description>
<section>文字</section>
<seealso>code-char</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>code-char</title>
<type>Function</type>
<arguments>CODE</arguments>
<package>lisp</package>
<description>
文字コードがCODEの文字を返します。
キャラクタと文字コードとの間の相互変換には、char-codeを使います。

使用例：  
  (code-char 110)
  =&gt; #\n
</description>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-upcase</title>
<type>Function</type>
<arguments>CHAR</arguments>
<package>lisp</package>
<description>
CHARを大文字にして返します。

使用例：  
  (char-upcase #\x)
  =&gt; #\X
</description>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-downcase</title>
<type>Function</type>
<arguments>CHAR</arguments>
<package>lisp</package>
<description>
CHARを小文字にして返します。

使用例：  
  (char-downcase #\A)
  =&gt; #\a
</description>
<section>文字</section>
<seealso>char-upcase</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>digit-char</title>
<type>Function</type>
<arguments>WEIGHT &amp;optional (RADIX 10)</arguments>
<package>lisp</package>
<description>
RADIXを基数とした場合のWEIGHTの表示上の文字を返します。
下の例ですと、(digit-char 12 16)は16進表記した場合の12は、
#\Cになります。WEIGHTがRADIX以上になるとnilが返ります。

使用例：
  (digit-char 7)
  =&gt; #\7
  (digit-char 12)
  =&gt; nil
  (digit-char 12 16)
  =&gt; #\C
  (digit-char 6 2)
  =&gt; nil
  (digit-char 1 2)
  =&gt; #\1
</description>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>character</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTを可能ならばcharacterに変換して返します。

  (character 'x) == (coerce 'x 'character)

使用例：
  (character 'x)        =&gt; #\x
  (character "A")       =&gt; #\A
  (character "1")       =&gt; #\1
  (character "10")      =&gt; 文字への変換はサポートされていません: "10"
</description>
<section>文字</section>
<seealso>coerce</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>write-char</title>
<type>Function</type>
<arguments>CHARACTER &amp;optional OUTPUT-STREAM</arguments>
<package>lisp</package>
<description>
OUTPUT-STREAMにCHARACTERを出力し、そのCHARACTERを返します。
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>terpri</title>
<type>Function</type>
<arguments>&amp;optional OUTPUT-STREAM</arguments>
<package>lisp</package>
<description>
OUTPUT-STREAMに改行(#\LFD)を出力してnilを返します。
</description>
<section>入出力</section>
<seealso>fresh-line</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fresh-line</title>
<type>Function</type>
<arguments>&amp;optional OUTPUT-STREAM</arguments>
<package>lisp</package>
<description>
OUTPUT-STREAMが行の先頭ではないときだけ改行(#\LFD)を出力します。
</description>
<section>入出力</section>
<seealso>terpri</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>directory-namestring</title>
<type>Function</type>
<arguments>PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのディレクトリ部分を返します。

使用例：  
  (directory-namestring "C:/xyzzy/xyzzy.exe")
  =&gt; "C:/xyzzy/"
  (directory-namestring "~/test.txt")
  =&gt; "C:/HOME/"
  (directory-namestring "/usr/local/bin")
  =&gt; "C:/usr/local/"
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-exist-p</title>
<type>Function</type>
<arguments>PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEが存在すればt、そうでなければnilを返します。

使用例：  
  (file-exist-p "C:/xyzzy/xyzzy.exe")
  =&gt; t
  (file-exist-p "~/")
  =&gt; t
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-readable-p</title>
<type>Function</type>
<arguments>PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEが読み取り可能ならt、そうでなければnilを返します。

使用例：
  (file-readable-p "C:/xyzzy/xyzzy.exe")
  =&gt; t
  (file-readable-p "~/")
  =&gt; nil
</description>
<seealso>file-writable-p</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-writable-p</title>
<type>Function</type>
<arguments>PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEが書き込み可能ファイルならt、そうでなければnilを返します。

使用例：  
  (file-writable-p "C:/xyzzy/xyzzy.exe")
  =&gt; t
  (file-writable-p "~/")
  =&gt; nil
</description>
<seealso>file-readable-p</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-directory-p</title>
<type>Function</type>
<arguments>PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEがディレクトリならt、そうでなければnilを返します。

使用例：  
  (file-directory-p "C:/xyzzy/")
  =&gt; t
  (file-directory-p "C:/xyzzy/xyzzy.exe")
  =&gt; nil
  (file-directory-p "~/")
  =&gt; t
</description>
<seealso>file-exist-p</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>path-equal</title>
<type>Function</type>
<arguments>PATHNAME1 PATHNAME2</arguments>
<package>lisp</package>
<description>
PATHNAME1とPATHNAME2が同じパスを指していればt、そうでなければnilを返します。

使用例：
  (path-equal "C:/Windows/" "c:/windows")
  =&gt; t
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sub-directory-p</title>
<type>Function</type>
<arguments>DIRECTORY PARENT</arguments>
<package>lisp</package>
<description>
DIRECTORYがPARENTのサブディレクトリならt、そうでなければnilを返します。

使用例： 
  (sub-directory-p "c:/windows/system" "c:/windows")
  =&gt; t
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>check-valid-pathname</title>
<type>Function</type>
<arguments>PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEが存在すればt、そうでなければnilを返します。

使用例：
  ;;; 存在するC:/xyzzy/と存在しないC:/xyzzzy/を比べてみる。
  (check-valid-pathname "C:/xyzzy/")
  =&gt; t
  (check-valid-pathname "C:/xyzzzy/")
  =&gt; nil
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>user-homedir-pathname</title>
<type>Function</type>
<arguments></arguments>
<package>lisp</package>
<description>
ユーザーのホームディレクトリを返します。

find-fileしたときに"~/"で参照可能なディレクトリです。
起動時に、このディレクトリに格納されている.xyzzyを読み込みます。
同一PCを複数人で使用していたり、ネットワーク共有されたフォルダに
xyzzyを格納した場合には、ユーザ毎にホームディレクトリの設定して
.xyzzyを切り替えることができます。

ユーザのホームディレクトリは、以下の順番で決定されます。

  1)iniファイル内の[init]homeDir
  2)環境変数 XYZZYHOME
  3)環境変数 HOME
  4)環境変数 HOMEDRIVE + HOMEPATH
  5)iniファイル内の[init]logDir
  6)xyzzy.exeのpath

使用例：
  (user-homedir-pathname)
  =&gt; "C:/HOME/"
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-file</title>
<type>Function</type>
<arguments>FILE &amp;key :IF-DOES-NOT-EXIST :IF-ACCESS-DENIED :RECYCLE</arguments>
<package>lisp</package>
<description>
ファイルを削除します。

  FILE               : 削除するファイル名を指定します。
  :IF-DOES-NOT-EXIST : ファイルが存在しない場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
  :IF-ACCESS-DENIED  : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :force          強制的に削除を試みます。

削除できたかどうかで戻り値が変わります。

  t   削除に成功
  nil 削除に失敗

使用例：  
  (delete-file "C:/xyzzy/test.txt")
  =&gt; t
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rename-file</title>
<type>Function</type>
<arguments>FILE NEW-NAME &amp;key :IF-EXISTS :IF-ACCESS-DENIED</arguments>
<package>lisp</package>
<description>
ファイル名を変更します。
  
  FILE              : 変更前のファイル名を指定します。
  NEW-NAME          : 変更後のファイル名を指定します。
  :IF-EXISTS        : ファイルが存在する場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :overwrite      強制的にファイル名の変更を試みます。
  :IF-ACCESS-DENIED : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。

変更できたかどうかで戻り値が変わります。

  t   変更に成功
  nil 変更に失敗

使用例：
  (rename-file "C:/xyzzy/test.txt" "C:/xyzzy/test2.txt")
  =&gt; t
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-directory</title>
<type>Function</type>
<arguments>DIRNAME &amp;key :IF-EXISTS</arguments>
<package>lisp</package>
<description>
ディレクトリを作成します。

  DIRNAME    : 作成対象のディレクトリ
  :IF-EXISTS : ディレクトリが存在していたときの動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。

戻り値は作成できたかどうかによります。

  t   ディレクトリの作成に成功
  nil ディレクトリの作成に失敗

使用例：
  (create-directory "C:/xyzzy/testdir")
  =&gt; t
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-directory</title>
<type>Function</type>
<arguments>DIRNAME &amp;key :IF-DOES-NOT-EXIST :IF-ACCESS-DENIED</arguments>
<package>lisp</package>
<description>
ディレクトリを削除します。

  DIRNAME            : 削除するディレクトリ名を指定します。
  :IF-DOES-NOT-EXIST : ディレクトリが存在しない場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
  :IF-ACCESS-DENIED  : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :force          強制的に削除を試みます。

削除できたかどうかで戻り値が変わります。

  t   削除に成功
  nil 削除に失敗

使用例：
  (delete-directory "C:/xyzzy/testdir")
  =&gt; t
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>open</title>
<type>Function</type>
<arguments>FILENAME &amp;key :DIRECTION :IF-EXISTS :IF-DOES-NOT-EXIST :ENCODING :SHARE</arguments>
<package>lisp</package>
<description>
ファイルへのストリームを作成して返します。ストリームのクローズには close 
を使いますが、 with-open-stream を使えば close の手間が省ける上に安全です。

  FILENAME           : ストリームを作成するファイル名を指定します。
  :DIRECTION         : ストリームの入出力の方向を指定します。
        :input          入力（省略時）
        :output         出力
        :io             入出力
        :probe          ファイルテスト？
                        戻り値のストリームは無効になっています。
  :IF-EXISTS         : ファイルが存在する場合の動作を指定します。
        :error          エラーを出力します。（省略時）
        :skip           エラーは出力せず、nilを返します。
        :append         既存ファイルに追加します。
                        ストリームの位置はファイル終端になります。
        :overwrite      上書きします。
        :new-version    ファイルを作成します。
                        既にあれば上書きされます。
        ---- 以下詳細不明 ----
        :supersede      更新？
        :rename         リネーム用にストリームを開く？
        :rename-and-delete  リネーム用にストリームを開く？
  :IF-DOES-NOT-EXIST : ファイルが存在しない場合の動作を指定します。
        :error          エラーを出力します。（省略時）
        :create         エラーは出力せず、入力ファイルを作成します。
  :ENCODING          : エンコーディングのモードを指定します。
        :binary         バイナリモードです。
        :text           テキストモードです。（省略時は:text）
                        改行がコードが*default-fileio-encoding*に依存します。
        :canonical      :text と同じ意味になります。
        :raw            改行コードの扱いが、LF のみになります。
                        それ以外は :text と同じです。
  :SHARE             : ファイルの共有モードを指定します。
        省略時　　　　　:direction が :input または :probe なら :read に、
                        それ以外は共有不可になります。
        :read           読み取りの共有が可能になります。
        :write          書き込みの共有が可能になります。
        :read-write     読み書きの共有が可能になります。

使用例：
  ;;; ストリーム経由でファイルに書き出してみる。
  (setq foo (open "abc.txt" :direction :output))
  =&gt; #&lt;file-output stream: C:/applications/xyzzy/abc.txt&gt;
  (princ "test" foo)
  =&gt; "test"
  (close foo)
  =&gt; t
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-position</title>
<type>Function</type>
<arguments>FILE-STREAM &amp;optional POSITION</arguments>
<package>lisp</package>
<description>
FILE-STREAM上の現在位置を取得・変更します。
POSITIONを省略すると、FILE-STREAMの現在位置を返します。
POSITIONを指定すると、FILE-STREAMの現在位置を変更します。

  FILE-STREAM : 入出力するストリームを指定します。
  POSITION    : ストリームの先頭からの位置を指定します。
                0を基底とするインデックスです。

POSITIONには負の数値を指定することはできません。
また、ストリームの終端を越えた数値を指定すると、
その間はNUL文字が詰められます。

使用例：
  ;;; "01234567"と出力後、移動して"abc"と出力します。
  (setq foo (open "abc.txt" :direction :output))
  =&gt; #&lt;file-output stream: C:/applications/xyzzy/abc.txt&gt;
  (princ "0123456" foo)         =&gt; "0123456"
  (file-position foo 10)        =&gt; t
  (princ "abc" foo)             =&gt; "abc"
  (close foo)                   =&gt; t
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-broadcast-stream</title>
<type>Function</type>
<arguments>&amp;rest STREAMS</arguments>
<package>lisp</package>
<description>
ブロードキャスト用の出力ストリームを作成します。
STREAMSに指定した複数のストリームに対して同時に出力することができます。

参考：
                        OUTPUT━━┓
                    ┌→┃STREAM1 ┠→
                    │  ┗━━━━┛
        BROADCAST ┓│  OUTPUT━━┓
    ─→┃STREAM  ┠┼→┃STREAM2 ┠→
        ┗━━━━┛│  ┗━━━━┛
                    │  OUTPUT━━┓
                    └→┃STREAM3 ┠→
                        ┗━━━━┛
使用例：
  ;;; fooとbarという出力ストリームを作ってから、
  ;;; hogeというブロードキャスト用ストリームを作り一括して出力
  (with-open-stream (foo (open "foo.txt" :direction :output))
    (with-open-stream (bar (open "bar.txt" :direction :output))
      (with-open-stream (hoge (make-broadcast-stream foo bar))
        (princ "abc" hoge))))
  =&gt; "abc"
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-concatenated-stream</title>
<type>Function</type>
<arguments>&amp;rest STREAMS</arguments>
<package>lisp</package>
<description>
STREAMSに指定した複数の入力ストリームをくっつけて、順番に読み出すための
一つの入力ストリームを作ります。

参考：
                        INPUT ━━┓    
                      ┌┨STREAM1 ┃←─
                      │┗━━━━┛    
        CONCAT━━┓  │INPUT ━━┓    
    ←─┨STREAM  ┃←┼┨STREAM2 ┃←─
        ┗━━━━┛  │┗━━━━┛    
                      │INPUT ━━┓    
                      └┨STREAM3 ┃←─
                        ┗━━━━┛    

使用例：
  ;;; 文字列の入力ストリームを二本作った後、一本に連接してみる。
  (with-open-stream (foo (make-string-input-stream "foo"))
    (with-open-stream (bar (make-string-input-stream "bar"))
      (with-open-stream (hoge (make-concatenated-stream foo bar))
        (while (setq in (read-char hoge nil))
          (write-char in)))))
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-two-way-stream</title>
<type>Function</type>
<arguments>INPUT-STREAM OUTPUT-STREAM</arguments>
<package>lisp</package>
<description>
入力をINPUT-STREAM、出力をOUTPUT-STREAMにする入出力ストリームを作成します。

参考：
        TWO WAY
          STREAM━┓    INPUT ━━┓
    ←─┨←───┨←─┨STREAM  ┃←─
        ┃        ┃    ┗━━━━┛
        ┃        ┃    OUTPUT━━┓
    ─→┠───→┠─→┃STREAM  ┠─→
        ┗━━━━┛    ┗━━━━┛
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-echo-stream</title>
<type>Function</type>
<arguments>INPUT-STREAM OUTPUT-STREAM</arguments>
<package>lisp</package>
<description>
INPUT-STREAMからの入力をOUTPUT-STREAMに出力するストリームを作成します。
make-two-way-streamと異なり、INPUT-STREAMから入力された内容は、全て
OUTPUT-STREAMにエコーされます。

参考：

     ECHO STREAM━┓    INPUT ━━┓
    ←─┨←───┨←─┨STREAM  ┃←─
        ┃    ┌─┨    ┗━━━━┛
        ┃    └→┃    OUTPUT━━┓
    ─→┠───→┠─→┃STREAM  ┠─→
        ┗━━━━┛    ┗━━━━┛
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-string-input-stream</title>
<type>Function</type>
<arguments>STRING &amp;optional START END</arguments>
<package>lisp</package>
<description>
文字列からの入力用ストリームを作成します。
以後、このストリームからは文字列の内容を順番に取得可能です。

  STRING : 対象の文字列を指定します。
  START  : 入力ストリームとする開始位置です。
  END    : 入力ストリームとする終了位置です。

複数の入力ストリームを使用するのでなければ、with-input-from-string を使
用する方が簡単です。

使用例：
  ;;; 文字列の入力用ストリームからひとつ読み出してみる。
  (with-open-stream (foo (make-string-input-stream "abc def"))
    (read foo))
  =&gt; abc  

  ;;; with-input-from-stringを使って同じ事をしてみる。
  (with-input-from-string (foo "abc def")
    (read foo))
  =&gt; abc  
</description>
<seealso>with-input-from-string</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>close</title>
<type>Function</type>
<arguments>STREAM &amp;key :ABORT</arguments>
<package>lisp</package>
<description>
指定されたストリームをクローズします。

  STREAM : クローズするストリームを指定します。
  :ABORT : 異常終了時に指定します。
        t       ストリームに対する副作用を取り消そうとします。
        nil     ストリーム普通に終了します。
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>broadcast-stream-streams</title>
<type>Function</type>
<arguments>BROADCAST-STREAM</arguments>
<package>lisp</package>
<description>
make-broadcast-streamで作られたBROADCAST-STREAMの出力先のストリームのリ
ストを返します。

使用例：
  ;;; hogeの出力先をリストで得る。
  (with-open-stream (foo (open "foo.txt" :direction :output))
    (with-open-stream (bar (open "bar.txt" :direction :output))
      (with-open-stream (hoge (make-broadcast-stream foo bar))
        (broadcast-stream-streams hoge))))
  =&gt; (#&lt;file-output stream: C:/applications/xyzzy/foo.txt&gt;
      #&lt;file-output stream: C:/applications/xyzzy/bar.txt&gt;)
</description>
<seealso>make-broadcast-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>concatenated-stream-streams</title>
<type>Function</type>
<arguments>CONCATENATED-STREAM</arguments>
<package>lisp</package>
<description>
make-concatenated-streamで作られたCONCATENATED-STREAMの入力元のストリームのリ
ストを返します。

使用例：
  ;;; hogeの入力元をリストで得る。
  (with-open-stream (foo (make-string-input-stream "foo"))
    (with-open-stream (bar (make-string-input-stream "bar"))
      (with-open-stream (hoge (make-concatenated-stream foo bar))
        (concatenated-stream-streams hoge))))
  =&gt; (#&lt;string-input stream 48042632&gt;
      #&lt;string-input stream 48042544&gt;)
</description>
<seealso>make-concatenated-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>echo-stream-input-stream</title>
<type>Function</type>
<arguments>ECHO-STREAM</arguments>
<package>lisp</package>
<description>
make-echo-streamで作られたECHO-STREAMの入力元のストリームを返します。
</description>
<seealso>make-echo-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>echo-stream-output-stream</title>
<type>Function</type>
<arguments>ECHO-STREAM</arguments>
<package>lisp</package>
<description>
make-echo-streamで作られたECHO-STREAMの出力先のストリームを返します。
</description>
<seealso>make-echo-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>two-way-stream-input-stream</title>
<type>Function</type>
<arguments>TWO-WAY-STREAM</arguments>
<package>lisp</package>
<description>
make-two-way-streamで作られたTWO-WAY-STREAMの入力元のストリームを返します。
</description>
<seealso>make-two-way-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>two-way-stream-output-stream</title>
<type>Function</type>
<arguments>TWO-WAY-STREAM</arguments>
<package>lisp</package>
<description>
make-two-way-streamで作られたTWO-WAY-STREAMの出力先のストリームを返します。
</description>
<seealso>make-two-way-stream</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read</title>
<type>Function</type>
<arguments>&amp;optional INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P</arguments>
<package>lisp</package>
<description>
INPUT-STREAMからLispのオブジェクトを読み込んで返します。

  INPUT-STREAM : 入力元のストリーム
  EOF-ERROR-P  : EOFの状態でread-charしたときにどうするか？
        t               エラーとする。
        nil             エラーとせず、nilを返します。
  EOF-VALUE    : EOFの状態でreadしたときにnilの代わりに返す文字を指定します。
  RECURSIVE-P  : （詳細不明）
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unread-char</title>
<type>Function</type>
<arguments>CHARACTER &amp;optional INPUT-STREAM</arguments>
<package>lisp</package>
<description>
入力ストリームに一文字戻します。

  CHARACTER    : 入力ストリームに戻す文字
  INPUT-STREAM : 入力ストリーム
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>listen</title>
<type>Function</type>
<arguments>&amp;optional INPUT-STREAM</arguments>
<package>lisp</package>
<description>
指定された入力ストリームに何か入力がある状態ならばt、ないならばnilを返します。
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-char-no-hang</title>
<type>Function</type>
<arguments>&amp;optional INPUT-STREAM EOF-ERROR-P EOF-VALUE</arguments>
<package>lisp</package>
<description>
read-charと同じです。ただし、入力がなければ待たずにnilを返します。
</description>
<seealso>read-char</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>clear-input</title>
<type>Function</type>
<arguments>&amp;optional INPUT-STREAM</arguments>
<package>lisp</package>
<description>
入力ストリームにバッファリングされている入力をクリアします。
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-symbol</title>
<type>Function</type>
<arguments>STRING &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
パッケージ中にシンボルが登録されているかを調べます。

  STRING  : シンボルの名前
  PACKAGE : パッケージの名前

戻り値は多値で返されます。

  nil     シンボルが見つからなかった場合はnilを返します。
  nil以外 シンボルが見つかった場合はそのシンボルをそのまま返します。

使用例：
  ;;; find-fileとfind-file-internalというシンボルを調べてみる。
  (find-symbol "find-file" "lisp")
  =&gt; nil
     nil
  (find-symbol "find-file" "editor")
  =&gt; find-file
     :external
  (find-symbol "find-file-internal" "editor")
  =&gt; editor::find-file-internal
     :internal
</description>
<seealso>intern</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unintern</title>
<type>Function</type>
<arguments>SYMBOL &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
パッケージにシンボルがあれば削除してtを、なければnilを返します。
</description>
<seealso>intern</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unexport</title>
<type>Function</type>
<arguments>SYMBOLS &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
シンボルのリストを指定して、その全てのシンボルをパッケージに登録します。
</description>
<seealso>export</seealso>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>import</title>
<type>Function</type>
<arguments>SYMBOLS &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
シンボルのリストを指定して、その全てのシンボルをパッケージ内でパッケージ
名指定なしでアクセスできるようにします。シンボルが既にパッケージ内に存在
する場合は例外を発生します。
</description>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>random</title>
<type>Function</type>
<arguments>NUMBER &amp;optional STATE</arguments>
<description>
0以上NUMBER未満の乱数を返します。
</description>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>gc</title>
<type>Function</type>
<arguments>&amp;optional NO-MESSAGE</arguments>
<description>
（多分）ゴミ集めをします。
</description>
<section></section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-decoded-time</title>
<type>Function</type>
<arguments></arguments>
<description>
現在の時間を多値で返します。
  
  (get-decoded-time) == (decode-universal-time (get-universal-time))
  
使用例：
  (multiple-value-list (get-decoded-time))
  =&gt; (55 35 14 17 11 1999 2 nil -9)
</description>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-universal-time</title>
<type>Function</type>
<arguments></arguments>
<description>
現在の時間を返します。

使用例：
  (get-universal-time)
  =&gt; 3151806404
</description>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-internal-real-time</title>
<type>Function</type>
<arguments></arguments>
<description>
PC内部時間(?)を返します？内部時間って？

使用例：  
  (get-internal-real-time)
  =&gt; -1525195135
</description>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>software-type</title>
<type>Function</type>
<arguments></arguments>
<description>
ソフト名を返します。

使用例：  
  (software-type)
  =&gt; "xyzzy"
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>software-version</title>
<type>Function</type>
<arguments></arguments>
<description>
xyzzyのバージョンを返します。

使用例：
  (software-version)
  =&gt; "0.2.2.228"
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:base64-decode</title>
<type>Function</type>
<arguments>INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM</arguments>
<description>
Base64でデコードします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     デコードの結果はbase64-decodeの戻り値となります。
        nil以外 デコードの結果はOUTPUT-STREAMに出力されます。

使用例：
  (si:base64-decode "gtmCsILZgrA=")
  =&gt; "ほげほげ"
</description>
<seealso>si:base64-encode</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:base64-encode</title>
<type>Function</type>
<arguments>INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM</arguments>
<description>
Base64エンコードします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     エンコードの結果はbase64-encodeの戻り値となります。
        nil以外 エンコードの結果はOUTPUT-STREAMに出力されます。

使用例：  
  (si:base64-encode "ほげほげ")
  =&gt; "gtmCsILZgrA="
</description>
<seealso>si:base64-decode</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:uuencode</title>
<type>Function</type>
<arguments>INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM</arguments>
<description>
uuencodeします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     エンコードの結果はuuencodeの戻り値となります。
        nil以外 エンコードの結果はOUTPUT-STREAMに出力されます。
</description>
<seealso>si:uudecode</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:uudecode</title>
<type>Function</type>
<arguments>input-string-or-stream &amp;optional output-stream</arguments>
<description>
uudecodeします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     デコードの結果はuudecodeの戻り値となります。
        nil以外 デコードの結果はOUTPUT-STREAMに出力されます。
</description>
<seealso>si:uuencode</seealso>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:quoted-printable-decode</title>
<type>Function</type>
<arguments>INPUT-STRING-OR-STREAM &amp;optional OUTPUT-STREAM</arguments>
<description>
Quoted-Printableデコードします。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。
  OUTPUT-STREAM          : 出力のストリームを指定します。
        nil     デコードの結果はquoted-printable-decodeの戻り値となります。
        nil以外 デコードの結果はOUTPUT-STREAMに出力されます。
</description>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>machine-name</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
マシン名を返します。

使用例：
  ;;; マシン名を返します。
  (machine-name)
  =&gt; "WS4849"

  ;;; PCによって、den8やdiffのインストールディレクトリが違っているので、
  ;;; 切り替えたりできます。
  (defun my-directory-setup ()
    (let ((x (machine-name)))
      (setq *diff-command-name*
            (cond ((string= x "TOMOYO") "c:/Cygnus/diff")
                   (t "c:/z/tools/diff")))
      (setq *den8-directory*
            (cond ((string= x "KANA") "D:/1gou-ki/den8_321")
                   (t "c:/z/den8_321")))))
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>os-major-version</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
OSのメジャーバージョンを返します。

使用例：
  (os-major-version)
  =&gt; 4
</description>
<seealso>machine-name</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>os-minor-version</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
OSのマイナーバージョンを返します。

使用例：
  (os-minor-version)
  =&gt; 0
</description>
<seealso>machine-name</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>os-platform</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
OSの種類を返します。OSが95とNTで動作を変えたいときなどに使います。返され
る値は文字列ではなくシンボルです。

参考：
  OS            シンボル
  ----          ----
  Windows???    win32s
  Windows95     windows-95
  Windows98     windows-98
  WindowsMe     windows-me
  WindowsNT     windows-nt
  Windows2000   windows-2000
  WindowsXP     whistler

使用例：
  (os-platform)
  =&gt; windows-nt
</description>
<seealso>machine-name</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-local-variable</title>
<type>Function</type>
<arguments>SYMBOL</arguments>
<package>editor</package>
<description>
SYMBOLを現在のバッファで独自の値を持てるようにローカル変数にします。
make-variable-buffer-localとは異なり、現在のバッファだけです。

使用例：
  ;;; 現在のバッファは自動保存しないようにする。
  (make-local-variable 'auto-save)
  =&gt; t  
  (setq auto-save nil)
  =&gt; nil
</description>
<seealso>kill-local-variable</seealso>
<seealso>make-variable-buffer-local</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-variable-buffer-local</title>
<type>Function</type>
<arguments>SYMBOL</arguments>
<package>editor</package>
<description>
SYMBOLを個々のバッファで独自の値を持てるようにローカル変数にします。
make-local-variableとは異なり、全てのバッファが対象です。
余程のことが無い限りdefvar-localを使えば良いと思います。
</description>
<seealso>make-local-variable</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kill-all-local-variables</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
全てのローカル変数が現在のバッファで独自の値を持てないようにします。
setq-defaultされていなかったローカル変数は参照できなくなります。

使用例：
  ;;; defvar-localした変数の値を設定してからkillしてみる。
  (defvar-local abc 123)        =&gt; abc
  (setq abc 456)                =&gt; 456
  abc                           =&gt; 456
  (kill-all-local-variables)    =&gt; t
  abc                           =&gt; 123
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kill-local-variable</title>
<type>Function</type>
<arguments>SYMBOL</arguments>
<package>editor</package>
<description>
SYMBOLが現在のバッファで独自の値を持てない様にします。
kill-local-variableを実行した後では、SYMBOLの値はグローバルなSYMBOLの値
になります。setq-defaultされていなかったローカル変数は参照できなくなります。

使用例：
  ;;; defvar-localした変数の値を設定してからkillしてみる。
  (defvar-local abc 123)        =&gt; abc
  (setq abc 456)                =&gt; 456
  abc                           =&gt; 456
  (kill-local-variable 'abc)    =&gt; t
  abc                           =&gt; 123
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>command-execute</title>
<type>Function</type>
<arguments>COMMAND &amp;optional HOOK</arguments>
<package>editor</package>
<description>
エディタのコマンドを実行します。HOOKは何でしょうか？

使用例：
  ;;; (command-execute "^X^F")と書いてfind-fileを実行してみる。
  (command-execute "^X^F")
</description>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>interactive-p</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
実行中の関数がinteractiveに呼ばれていればt、そうでなければnilを返します。

使用例：
  ;;; fooとbarという関数を定義して、fooをinteractiveに呼び出してみる。
  ;;; fooはinteractive扱いされているが、barはそうでない。
  (defun foo () (interactive) (msgbox "foo: ~A" (interactive-p)) (bar))
  =&gt; foo
  (defun bar () (interactive) (msgbox "bar: ~A" (interactive-p)))
  =&gt; bar
  M-x: foo
  =&gt; [foo: t]
     [bar: nil]
</description>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>os-build-number</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
Windows NT 4.00.13811 + Service Pack 3 の場合

使用例：  
  (os-build-number)
  =&gt; 1381
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>os-csd-version</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
Windows NT 4.00.1381 + Service Pack 3 の場合

使用例：
  (os-csd-version)
  =&gt; "Service Pack 3"
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>erase-buffer</title>
<type>Function</type>
<arguments>BUFFER</arguments>
<package>editor</package>
<description>
バッファの内容を削除します。
以下の内容がクリアされます。
  ・バッファ上のテキスト
  ・変更フラグ
  ・修正日付
  ・restriction
  ・UNDO情報
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-lines</title>
<type>Function</type>
<arguments>&amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの物理行数を返します。

使用例：  
  (buffer-lines)
  =&gt; 5014
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-new-buffer</title>
<type>Function</type>
<arguments>NAME</arguments>
<package>editor</package>
<description>
名前がNAMEのバッファを作成して返します。もしその名前のバッファが存在すれ
ば、name&lt;1&gt;, name&lt;2&gt;...と番号を付けた名前になります。

使用例：
  (create-new-buffer "test")
  =&gt; #&lt;buffer: test&gt;
  (create-new-buffer "test")
  =&gt; #&lt;buffer: test&lt;2&gt;&gt;
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>deleted-buffer-p</title>
<type>Function</type>
<arguments>BUFFER</arguments>
<package>editor</package>
<description>
バッファが削除されているかどうかを調べます。
BUFFERにはバッファ型のものしか指定できません。

  t   指定されたバッファは既に削除されています。
  nil 指定されたバッファは未だ削除されていません。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>next-buffer</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
次のバッファに切替えます。エディタ上で現在選択されているウィンドウの
中のバッファが変わるだけです。

バッファタブの順番にそってnext-bufferしたいのならば、
*next-buffer-in-tab-order*を参照して下さい。
</description>
<seealso>previous-buffer</seealso>
<seealso>*next-buffer-in-tab-order*</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>previous-buffer</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
一つ前のバッファに切替えます。next-bufferの反対です。
</description>
<seealso>next-buffer</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-file-buffer</title>
<type>Function</type>
<arguments>FILENAME</arguments>
<package>editor</package>
<description>
ファイルを表示しているバッファを返します。
なければnilを返します。

使用例：  
  (get-file-buffer "not-documented.xml")
  =&gt; #&lt;buffer: not-documented.xml&gt;
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-file-buffer</title>
<type>Function</type>
<arguments>FILENAME</arguments>
<package>editor</package>
<description>
ファイルを参照するバッファを作成して返します。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-buffer</title>
<type>Function</type>
<arguments>BUFFER</arguments>
<package>editor</package>
<description>
バッファを削除しますが、kill-bufferと違い対話的に削除するかどうかは聞き
ません。kill-bufferも内部的にはdelete-bufferを使っています。

delete-bufferでは以下の二つのフックが順番に実行されます。

  *before-delete-buffer-hook*
        delete-bufferを継続するかどうかを制御します。登録された関数が一
        つでもnilを返すとdelete-bufferを中止します。

  *delete-buffer-hook*
        delete-bufferされるバッファで何か処理を行う場合に使用します。
</description>
<seealso>*before-delete-buffer-hook*</seealso>
<seealso>*delete-buffer-hook*</seealso>
<seealso>kill-buffer</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-buffer</title>
<type>Function</type>
<arguments>BUFFER-NAME</arguments>
<package>editor</package>
<description>
名前がBUFFER-NAMEなバッファが存在すればそのバッファを返します。
存在しなければnilを返します。

使用例：
  (find-buffer "*scratch*")
  =&gt; #&lt;buffer: *scratch*&gt;
  (find-buffer "*hoge hoge*")
  =&gt; nil
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>other-buffer</title>
<type>Function</type>
<arguments>&amp;optional BUFFER</arguments>
<package>editor</package>
<description>
最近(?)表示されていたバッファに切替えます。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-text-color</title>
<type>Function</type>
<arguments>FROM TO &amp;optional FOREGROUND BACKGROUND CHAR EXTEND-P</arguments>
<package>editor</package>
<description>
指定された領域を装飾します。

  FROM       : 開始位置を指定します。
  TO         : 終了位置を指定します。
  FOREGROUND : 文字の色を番号で指定します。以下を参照
  BACKGROUND : 文字の色を番号で指定します。以下を参照
  CHAR       : （詳細不明）
  EXTEND-P   : （詳細不明）

参考：
  ;;; 番号と色の対応
         R   G   B
       ------------
   0     0   0   0
   1   255   0   0
   2     0 255   0
   3   255 255   0
   4     0   0 255
   5   255   0 255
   6     0 255 255
   7   255 255 255
   8     0   0   0
   9   128   0   0
  10     0 128   0
  11   128 128   0
  12     0   0 128
  13   128   0 128
  14     0 128 128
  15   128 128 128
</description>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-default-fold-width</title>
<type>Function</type>
<arguments>WIDTH</arguments>
<package>editor</package>
<description>
テキストの折り返し方法を制御します。[ツール]-[共通設定]-[表示]の"テキス
トの折り返し"と同じで、全体に影響します。

  WIDTH : 折り返しの方法を指定します。
        nil     折り返しません。
        t       ウィンドウの幅で折り返します。
        数値    折り返し位置を指定します。
</description>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-width</title>
<type>Function</type>
<arguments>WIDTH &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
テキストの折り返し方法を制御します。[ツール]-[ローカル設定]-[表示]の"テ
キストの折り返し"と同じで、現在のバッファだけに影響します。

  WIDTH  : 折り返しの方法を指定します。
        nil     折り返しません。
        t       ウィンドウの幅で折り返します。
        数値    折り返し位置を指定します。
  BUFFER : ローカル設定するバッファを指定します。
</description>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-macro-character</title>
<type>Function</type>
<arguments>char function &amp;optional non-terminating-p readtable</arguments>
<package>lisp</package>
<description>
（詳細不明）

使用例：
  (set-macro-character #\? 'read-test)
  (defun read-test (stream ch)
    (list '*question* (read stream)))
</description>
<section></section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>行番号等のON/OFF</title>
<type>Tips</type>
<arguments></arguments>
<description>
こんなに簡単にポップアップメニューから実行できます。

使用例：
  ;;; C-RBtnUpで独自のポップアップメニューにします。
  (global-set-key #\C-RBtnUp 'my-apps-popup)
  (defun my-apps-popup ()
    (interactive)
    (track-popup-menu  
     (define-popup-menu
              (:item nil "行番号(&amp;L)"
               'toggle-line-number)
              (:item nil "スクロールバー(&amp;B)"
               'toggle-vscroll-bar)
              (:item nil "モードライン(&amp;M)"
               'toggle-mode-line)
              (:item nil "ファンクションキー(&amp;F)"
               'toggle-function-bar)
              (:item nil "折り返し(&amp;T)"
               'toggle-fold-line)
              (:item nil "リードオンリー(&amp;R)"
               'toggle-read-only))))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>si:*load-library</title>
<type>Function</type>
<arguments>FILENAME &amp;key :NO-SUFFIX :IF-DOES-NOT-EXIST :NO-MESSAGE</arguments>
<description>
ライブラリをロードします。普通はload-libraryでいいと思いますが、
どんなときにsi:*load-libraryを使うのでしょうか？

  :no-suffix           non-nil なら指定されたファイル名をそのままロードする。
                       nil なら *load-path* を考慮する。

  :if-does-not-exist   :no-suffix が nil でファイルが存在しない場合、
                       :error ならエラー、それ以外なら nil を返す。

  :no-message          non-nil ならロード中のメッセージを出さない。
</description>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>eval-when</title>
<type>Special Form</type>
<arguments>({SITUATION}*) {FORM}*</arguments>
<package>lisp</package>
<description>
ひとことで言うと、フォームをいつ評価するかってことです。

今回の例だと、define-dll-entry などのマクロはコンパイル時に展開
されなければならないのですが、define-dll-entry は foreign で定
義されているので、foreign がロードされていないとマクロであるこ
とが認識できません。(eval-when ...) がなく、単に (require 
"foreign") だけだと、コンパイル時には単なる関数コールだとみなさ
れてしまうため、マクロが展開されなくなってしまいます。そのため
に、eval-when でコンパイルするときも foreign をロードしろと指定
しているわけです。


          ソース                       ソース（左と同一）
            ↓  (eval)                   ↓  (compile)
      Lispインタープリタ           Lispコンパイラ
                                         ↓
                                        *.lc
                                         ↓   (load)
                                   Lispインタープリタ

C言語だと maxというのがマクロですよね。

#define max(a,b)   ((a&gt;b)?a:b)

こんなん。

int foo(int x, int y)
{
   return max(x, y);
}
と書いたら、
int foo(int x, int y)
{
   return ((x&gt; y) ? x : y);
}

こう書いたのと等価ですよね。
Ｃの入門書だとプリプロセッサがいったん展開してから、コンパイル
すると書かれていると思います。

lispだとこんなんになるんですが

----    test.l ---------

(defmacro macro-max (a b)
  `(if (&gt; ,a ,b) ,a ,b))

(defun foo (x y)
  (macro-max x y))

------------------------

M-x byte-compile-fileってやったときに、
(defmacro macro-maxっていう文は、コンパイルするんでなくって
eval(インタープリタが評価する）しとかないといけない。

でないとfooのところで、コンパイル前にソースを展開できない。

だから eval-when (compile)なんです。
よくわからなかったら、３つ全部つけておけば大丈夫という説もある^^;

(eval-when (:compile-toplevel :load-toplevel :execute)

Common Lispの仕様書では、たしか eval, load, compile
だけ,だったと思います。

eval        --- インタープリタにロードするときeval
compile     --- compile時にeval
load        --- compileした*.lc をロードするときeval

(eval-when (:compile-toplevel :load-toplevel :execute)
って、今まで、xyzzyオリジナルかと思ってました。

でもallegloのhelpをみていたら、
(eval-when (:compile-toplevel :load-toplevel :execute)
ってありますね。^^;
知りませんでした。

| Common Lispの仕様書では、たしか eval, load, compile
| だけ,だったと思います。

CLtL1 ではそうだったんですが、CLtL2 で変わりました。
</description>
<section>評価</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:unpack-string</title>
<type>Function</type>
<arguments>CHUNK OFFSET SIZE &amp;optional ZERO-TERMINATING-P</arguments>
<description>
チャンクをlispの文字列に変換します。

  CHUNK              : make-chunkで作られたチャンク
  OFFSET             : 文字列化する位置を指定します。
  SIZE               : OFFSETの位置から文字列化する長さを指定します。
  ZERO-TERMINATING-P : （詳細不明）
</description>
<seealso>si:make-chunk</seealso>
<section>チャンク</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:make-string-chunk</title>
<type>Function</type>
<arguments>STRING</arguments>
<description>
引数に指定された文字列の内容がコピーされたチャンクを作成します。

使用例：
  ;;; WIN32APIのMessageBoxを使ってみる。
  (let ((s (si:make-string-chunk "hello"))
        (r (si:make-string-chunk "title")))
    (MessageBox 0 s r MB_OK))     ; define-dll-entryで定義する事
</description>
<section>チャンク</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:make-chunk</title>
<type>Function</type>
<arguments>TYPE SIZE &amp;optional SRC-CHUNK OFFSET</arguments>
<description>
チャンクを作成します。チャンクとは外部とのやりとりをするための領域で、
外部DLLの呼び出しをする場合等に使用します。C言語的にはchar[]に相当するよ
うに思います。

  TYPE      : チャンクの型です。現状では使用していないようです。
  SIZE      : チャンクの長さです。
  SRC-CHUNK : 作成するチャンクの元ネタとなるチャンクです。
  OFFSET    : 作成するチャンクの元ネタとなるチャンクの開始位置です。

SRC-CHUNKとOFFSETの組み合わせでチャンクに関連付けされるメモリの取り方が
変わるようです。他のチャンクの内容を使用したい場合等にはを付けましょう。

  ┏━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━┓  
  ┃                  ┃OFFSET                                            ┃  
  ┃                  ┠────────────┬────────────┨  
  ┃                  ┃指定有                  │nil                     ┃  
  ┣━━━━━┯━━━╋━━━━━━━━━━━━┿━━━━━━━━━━━━┫  
  ┃SRC-CHUNK │指定有┃SRC-CHUNK + OFFSETを参照│SRC-CHUNKを共有         ┃  
  ┃          ├───╂────────────┼────────────┨  
  ┃          │nil   ┃OFFSETのアドレスを参照  │新しいメモリを確保      ┃  
  ┗━━━━━┷━━━┻━━━━━━━━━━━━┷━━━━━━━━━━━━┛  

SRC-CHUNK が nil で OFFSET が指定されていた場合には、 OFFSET をアドレス
と見なすのが特殊です。

補足説明：
  si:make-chunkはDLLを呼び出すとき、C言語に渡せるメモリ割り当てを行いま
  す。例えば以下のC言語のコードは
  ┌───────────────────────────────────┐
  │char buf[300];                                                        │
  │DWORD rc = GetCurrentDirectory(300, buf);                             │
  └───────────────────────────────────┘
  xyzzy lispで書くと、以下のようになります。
  ┌───────────────────────────────────┐
  │(let ((s (si:make-chunk nil 300))) ; C言語互換メモリの割り当て        │
  │   (GetCurrentDirectory 300 s)     ; define-dll-entryで定義しておく事 │
  │   (si:unpack-string s 0))         ; lispの文字列に変換               │
  └───────────────────────────────────┘
</description>
<section>チャンク</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>other-window</title>
<type>Function</type>
<arguments>&amp;optional (ARG 1 F) NO-ERROR</arguments>
<package>editor</package>
<description>
分割されたウィンドウの中を移動します。

  ARG      : ARG番目のウィンドウに移動します。
             負数であれば、ARG番前のウィンドウに移動します。
  NO-ERROR : (count-windows)以上の数値を指定した場合の動作を制御します。
        nil     (count-windows)以上の数値を指定するとエラーを発生します。
        t       (count-windows)以上の数値を指定してもtを返す。
</description>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>concat</title>
<type>Function</type>
<arguments>&amp;rest SEQ</arguments>
<package>editor</package>
<description>
指定された文字列を連結します。

使用例：
  ;;; concatを使ってみる。
  (setq foo "It's ")            =&gt; "It's "
  (setq bar "show time!!!")     =&gt; "show time!!!"
  (concat foo bar)              =&gt; "It's show time!!!"
(concat "It's " "show " "time!!!")
"It's show time!!!"
</description>
<section>文字列</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>unless</title>
<type>Macro</type>
<arguments>test &amp;body BODY</arguments>
<package>lisp</package>
<description>
条件が成立しない場合に実行します。whenの逆です。

  (unless 条件式  本体 ....)
</description>
<seealso>when</seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>shell-execute</title>
<type>Function</type>
<arguments>FILENAME &amp;optional DIRECTORY PARAMS</arguments>
<package>editor</package>
<description>
何かを行います。URLであればそれを開き、実行ファイルであれば実行したり、
拡張子に応じてアプリケーションを実行します。

  FILENAME  : 何か？URLもOK？
  DIRECTORY : どこでそれを実行するかを指定します。
        t       (cwd)の返されるディレクトリで実行されるみたいです。
        nil     特に指定がないのでFILENAMEのディレクトリで実行されます。

質問：

  | http://java.sun.com/products/jdk/1.2/docs/api/index.html
  | とかをF3キー一発で開けたらって思ってるんです。

  こんなかんじでどうぞ。

  (defun foo ()
    (interactive)
    (shell-execute "http://java.sun.com/products/jdk/1.2/docs/api/index.html" t))
</description>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>do-completion</title>
<type>Function</type>
<arguments>do-completion FROM TO TYPE &amp;optional COMPL WORD LAST-CHAR (POPUP-P *POPUP-COMPLETION-LIST-DEFAULT*)</arguments>
<package>editor</package>
<description>
テキストの補完をします。
詳細は*do-completionを参照して下さい。

使用例：
  ;;; カーソルの直前のパスを補完します。
  (do-completion (point) 
                 (progn (skip-syntax-spec-backward "^ ") (point))
                 :file-name)
</description>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>complete.l</file>
</chapter>

<chapter>
<title>si:*builtin-function-p</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<description>
オブジェクトがビルトイン関数かどうかを調べます。

使用例：
  ;;; carを調べてみる。
  (si:*builtin-function-p #'car)
  =&gt; t
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*do-completion</title>
<type>Function</type>
<arguments>STRING TYPE &amp;optional WORDP LIST</arguments>
<package>editor</package>
<description>
指定した文字列を条件に従い補完します。

  STRING : 補完したい文字列
  TYPE   : 補完する型
        :symbol-name
        :function-name
        :command-name
        :variable-name
        :non-trivial-symbol-name
        :exist-file-name
        :file-name
        :file-name-list
        :directory-name
        :buffer-name
        :exist-buffer-name
        :list
        :list-ignore-case
  WORD   : nilでなければ単語ごとの補完
  LIST   : TYPE が :list か :list-ignore-case の場合の補完リスト

戻り値は以下のとおりです。

  多値で3つの値が戻ってきますので、multiple-value-bind で受け取るといい
  でしょう。complete.lの中にある do-completion-internal を参考にしてくだ
  さい。以下は場合分けをしています。

        [1] 補完の候補が存在しない場合          :no-completions と nil
        [2] マッチする候補がなかった場合        :no-match と nil
        [3] 与えられた文字列がすでに候補の
            いずれかと一致していて
            補完する必要がない場合
            [3.1] 一致した候補が一つだけ        :solo-match と list と prefix
            [3.2] 複数と一致した場合            :not-unique と list と prefix
        [4] 補完した場合                        補完した結果の文字列と list と prefix

  list は、一致した候補のリスト。
  prefix は、例えばファイル名の補完のときのディレクトリ名とか。
</description>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>with-open-file</title>
<type>Macro</type>
<arguments>(STREAM FILENAME &amp;rest OPTIONS) &amp;body BODY</arguments>
<package>lisp</package>
<description>
--- 原文 ---
Description: evaluates the forms of the body as an implicit progn. stream 
is bound to a stream that is the result of applying open
 to filename and the options. If the stream cannot be opened, stream may 
be bound to nil. The file is automatically closed if the body is exited, 
even in error.

--- 意訳 ---
prognがあるかのようにBODYのフォームを順番に評価します。STREAMは、FILEと
OPTIONにopenを適用した結果のストリームに束縛されます。もしストリームの
openに失敗したら、STREAMはnilに束縛されます。FILEはBODYから抜けた場合に
自動的にクローズされます。たとえそれがエラーの場合であっても。

使用例：
  (with-open-file (fp (merge-pathnames "lisp/henmi/c++-kwd.txt" (si:system-root)))
    (let ((line nil))
      (while (setq line (read-line fp nil nil nil))
        (push line *kekka*))))
</description>
<section>入出力</section>
<seealso>open</seealso>
<file>stream.l</file>
</chapter>

<chapter>
<title>read-line</title>
<type>Function</type>
<arguments>&amp;optional INPUT-STREAM EOF-ERROR-P T EOF-VALUE RECURSIVE-P</arguments>
<package>lisp</package>
<description>
--- 原文 ---
Description: is usually used to read text from the keyboard. It reads 
characters from input-stream until the #\newline character is encountered, 
and collects them into a string without the #\newline character. This 
function returns two values. The first is the string collected.  The 
second is non-nil if the operation is terminated on end of file and nil 
otherwise. If end of file is encountered immediately, operation of read-line 
is determined by the eof-error-p and eof-value arguments.

--- 意訳 ---
read-lineはキーボードからテキストを読み込むのに使われます。#\LFDが出てく
るまでINPUT-STREAMから文字を読み込みます。そして、#\LFD以外を集めて文字
列にします。read-lineは二つの値を返します。最初の値は集めた文字列そのも
のです。二つ目の値は、ファイルの終端まできてしまったらnon-nilを返します。
そうでなければnilを返します。もしファイルの終端が直ぐに現れたら、
read-lineはEOF-ERROR-PとEOF-VALUEにより終了させられます。
</description>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>si:system-root</title>
<type>Function</type>
<arguments></arguments>
<description>
xyzzyがインストールされているパスを返します。

※userパッケージもeditorパッケージもsystemをuse-packageしていないので、
  呼び出すときはsi:を付けて、(si:system-root)としなければいけません。

使用例：
  (load (merge-pathnames "lisp/henmi/foo.l" (si:system-root)))
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>special</title>
<type>Misc</type>
<arguments></arguments>
<package>lisp</package>
<description>
declare をごらんください。
</description>
<section>変数と定数</section>
<seealso>declare</seealso>
<file></file>
</chapter>

<chapter>
<title>declare</title>
<type>Misc</type>
<arguments></arguments>
<package>lisp</package>
<description>
Common Lispの機能で、「変数を動的に bind しろ」と宣言する事です。
Emacs Lispではそもそも動的にしか bind できないので存在しません。

  (declare (special 変数名))

違いを図示します。

  ;;; 大域変数 x          ┏大域変数━━━━━━┓    Common Lisp/xyzzy lisp：
  (setq x 0)              ┃x │0             ←╂─┐大域変数のxを参照する。
                          ┠─┴────────┨  │(+ 0 12)となる
  ;;; 関数 bar            ┃                    ┃  │
  (defun bar (x)          ┃┏(bar 34)━━━━┓┃  │    Emacs Lisp：
    (foo 12))             ┃┃x │34        ←╂╂─│─┐呼び出しスタックの
                          ┃┠─┴──────┨┃  │  │深いところのxを参照する。
  ;;; 関数 foo            ┃┃                ┃┃  │  │(+ 34 12)となる。
  (defun foo (y)          ┃┃┏(foo 12)━━┓┃┃  │  │
     (+ x y))    ... ※   ┃┃┃y │12      ┃┃┃  │  │
                          ┃┃┠─┴────┨┃┃  │  │
                          ┃┃┃(+ x y)   ─╂╂╂─┴─┘

とあったときに(bar 34)と呼び出すと、古いLispでは(Emacs Lispを含む）
※の時点で x = 34, y = 12と見えます。ところが、Common Lispやxyzzy lispでは
※の時点で x = 0,  y = 12と見えます。

昔Lispはインタープリタだったので、動的バインディングでもよかったんだけど、
コンパイラを作る時に、効率上なにかと問題があってCommon Lisp
では、静的バインディングに変更になりました。

でも、そうすると、古いコードを移植するのが大変になるので、

                          ┏大域変数━━━━━━┓    
                          ┃x │0               ┃
                          ┠─┴────────┨
  ;;; 関数 bar            ┃                    ┃    
  (defun bar (x)          ┃┏(bar 34)━━━━┓┃    Common Lisp/xyzzy lisp：
    (declare (special x)) ┃┃x │34        ←╂╂─┐大域変数ではなく
    (foo 12))             ┃┠─┴──────┨┃  │スタック上のxを参照する。
                          ┃┃                ┃┃  │(+ 34 12)となる。
                          ┃┃┏(foo 12)━━┓┃┃  │
                          ┃┃┃y │12      ┃┃┃  │
                          ┃┃┠─┴────┨┃┃  │
                          ┃┃┃(+ x y)   ─╂╂╂─┘

と書いてやると古いLisp(Emacs Lisp)のように動くという訳。
</description>
<seealso>special</seealso>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>with-input-from-selected-buffer</title>
<type>Macro</type>
<arguments>&amp;rest BODY</arguments>
<package>editor</package>
<description>
現在のバッファを標準入力にして読み込みます。

使用例：
  ;;; 現在のバッファから読み込んで変数に入れる。
  (with-input-from-selected-buffer
    (setq name (read) count (read) exp (read)))
</description>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>return-from</title>
<type>Special Form</type>
<arguments>"NAME [RESULT]"</arguments>
<package>lisp</package>
<description>
ブロックから脱出します。
--- 原文 ---
Description: used to terminate the evaluation of the block construct with 
name NAME. The name argument is not evaluated and must be a symbol. When 
return-from is encountered the result-form is evaluated if present and 
evaluation of the block is terminated. The block returns the value returned 
by the result-form or nil if no result-form is present. If name is nil, 
return-from can be used to terminate the evaluation of do  and prog 
constructs that automatically create a block called nil to enclose their 
argument forms.

Example:

(block fred
  (setq x 10)
  (loop (incf x) (if (&gt; x 20) (return-from fred x))))
 21
</description>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pushnew</title>
<type>Macro</type>
<arguments>ITEM PLACE &amp;rest KEYS &amp;environment ENV</arguments>
<package>lisp</package>
<description>
pushとほぼ同じですが、リストの最上位に現れている要素でなければリストの先
頭に追加されます。追加するかどうかは、:TESTもしくは:TEST-NOTで指定される
比較テストを使ってリストの全要素についてチェックして決められます。

  ITEM      : 登録する内容です。
  PLACE     : 登録する場所です。
  :TEST     : 比較関数です。標準では#'eql？
  :TEST-NOT : 比較関数をです。
  :KEY      : キー判定用の関数です。標準では#'identity？

使用例：
  (setq *a* nil)                ;; この時 *a* の値は nil
  (pushnew 'a *a*)  =&gt; (a)      ;; この時 *a* の値は (a)
  (pushnew 'b *a*)  =&gt; (b a)    ;; この時 *a* の値は (b a)
  (pushnew 'a *a*)  =&gt; (b a)    ;; この時 *a* の値は (b a)

互換性：
  Common Lispとxyzzyにあり。
  muleは無さそう。
</description>
<section>リスト</section>
<seealso>adjoin</seealso>
<file>setf.l</file>
</chapter>

<chapter>
<title>push</title>
<type>Macro</type>
<arguments>ITEM PLACE &amp;environment ENV</arguments>
<package>lisp</package>
<description>
リストの先頭に要素を追加します。

  ITEM  : リストに追加する要素です。
  PLACE : pushする場所はsetfに適用できるものでなければなりません。

使用例：
  ;;; リストの途中にpushしてみる。
  (setq x '(a (b c d) e f))     =&gt; (a (b c d) e f)
  (push 99 (cdr (second x)))    =&gt; (99 c d)
  x                             =&gt; (a (b 99 c d) e f)

互換性：
  Common Lispとxyzzyにあり。
  muleは無さそう。
</description>
<section>リスト</section>
<file>setf.l</file>
</chapter>

<chapter>
<title>pop</title>
<type>Macro</type>
<arguments>PLACE &amp;environment ENV</arguments>
<package>lisp</package>
<description>
リストの先頭要素を取り除きます。取り除いた要素を返します。

  PLACE : setfに適用できるものでなければなりません。

使用例：
  (setq x '(a (b c d) e f))     =&gt; (a (b c d) e f)
  (pop (cdr (second x)))        =&gt; c
  x                             =&gt; (a (b d) e f)

互換性：
  Common Lispとxyzzyにあり。
  muleはなさそう。
</description>
<section>リスト</section>
</chapter>

<chapter>
<title>values</title>
<type>Function</type>
<arguments>&amp;rest args</arguments>
<package>lisp</package>
<description>
多値で値を返します。

C言語では関数は1つの値しか返すことができませんが、Common Lispでは複数の
値を返す事ができます（リストとは違います）。これを多値（関数）と呼びます。
複数の値を返したい時は、 (values 値1 値2 ..)という構文を使います。

多値関数を呼び出す場合には、複数の戻り値を受け取れるように 
multiple-value-bind または multiple-value-listを使って受け取ります。

Description: evaluates each of its argument forms in turn, then returns 
as multiple values the first value returned by each of the forms. If the 
form that calls a values form does not expect the number of values returned, 
any excess values are discarded. values is used to return multiple values 
from a form that would otherwise return a single value. There are a number 
of Lisp forms, defined using values, that return multiple values. values 
can also be used to restrict the number of values such forms return. For 
example, the Lisp function decode-float returns three values. However, 
the form below returns only the first value returned by the decode-float 
form, since values has one argument and it returns a single value for 
each of its arguments. The advantage is increased efficiency provided 
that the second and third value are not required.

(values (decode-float floating-point-number))

The form (values) returns zero values since it has zero arguments. 
Therefore, each of the values the calling form expects to receive are nil 
by default.

互換性：
  Common Lispとxyzzyにはあり。
  muleにはなさそう。
</description>
<seealso>multiple-value-bind</seealso>
<seealso>multiple-value-list</seealso>
<seealso>multiple-value-setq</seealso>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>multiple-value-bind</title>
<type>Macro</type>
<arguments>multiple-value-bind ({VAR}*) VALUES-FORM {declaration}* {FORM}*</arguments>
<package>lisp</package>
<description>
フォームが返す多値を受け取ります。広井さんの"xyzzy Lisp Programming"の
解説が分かり易いので掲載の許可を頂きました。以下を参照して下さい。

--- 引用開始  ---
複数の値を受け取るには、マクロ multiple-value-bind を使うと簡単です。 

multiple-value-bind (&amp;rest vars) values-form &amp;rest form

multiple-value-bind は、多値を返す関数 values-form を評価し、その結果を 
vars で定義した変数にセットします。変数は局所変数として設定されるので、
multiple-value-bind を実行している間だけ有効です。簡単な例を示しましょう。
Common Lisp には、整数でない値を整数に変換する関数 floor, ceiling, 
truncate, round が定義されています。これらの関数は２つの値（多値）を返します。

  (truncate 10 3)
  =&gt; 3

  (multiple-value-bind
  (q r)
  (truncate 10 3)
  (format nil "商 ~D, 余り ~D~%" q r))
  =&gt; "商 3, 余り 1"

関数 truncate は割り算を行って商と余りを返します。ふつうに truncate を呼
び出すと商を返すだけですが、multiple-value-bind を使うと、商のほかに余り
も受け取ることができます。q と r は truncate が返す値を受け取る変数です。
次に、truncate を評価して結果を変数にセットします。あとは、残りの form 
を順番に評価していきます。 multiple-value-bind は最後に評価した form の
値を返します。

もしも、返される値よりも変数の個数が多い場合、残りの変数には nil がセッ
トされます。逆に、返される値が変数よりも多い場合、余分な値は捨てられます。
次の例を見てください。

  (multiple-value-bind (q)
  (truncate 10 3)
  (list q))
  =&gt; (3)
  
  (multiple-value-bind (q r s)
  (truncate 10 3)
  (list q r s))
  =&gt; (3 1 nil)

最初の例では、変数 q しか定義されていないので、 q には商がセットされます
が余りは捨てられます。次の例では、変数 s が定義されていますが、truncate 
は２つの値しか返さないので、 s には nil がセットされます。
--- 引用終了 ---

--- 原文 ---
Description: evaluates values-form and binds each of the variables provided 
to the respective value returned. If there are more variables than values 
returned, nil is bound to the excess variables. If there are more values 
returned that variables the excess values are discarded. The form arguments 
are then evaluated as an implicit progn construct. The multiple-value-bind 
form returns the value or values returned by evaluating the last form 
argument. See also let.

 (multiple-value-bind (a b c d e)
    (values 1 2 3 4 5)
  (format nil "~D ~D ~D ~D ~D" a b c d e))
 =&gt; "1 2 3 4 5"
</description>
<seealso>values</seealso>
<seealso>multiple-value-list</seealso>
<seealso>multiple-value-setq</seealso>
<link>http://www.geocities.co.jp/SiliconValley-Oakland/1680/</link>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>multiple-value-list</title>
<type>Macro</type>
<arguments>FORM</arguments>
<package>lisp</package>
<description>
関数が返した多値をリストで返します。

使用例：
  (defun foo () (values 1 2 3))
  =&gt; foo
  (foo)
  =&gt; 1
     2
     3
  (multiple-value-list (foo))
  =&gt; (1 2 3)
</description>
<seealso>values</seealso>
<seealso>multiple-value-bind</seealso>
<seealso>multiple-value-setq</seealso>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>car</title>
<type>Function</type>
<arguments>list</arguments>
<package>lisp</package>
<description>
リストの最初の要素を返します。

コンスセル list の最初のポインタを返します。 list が nil の場合 car は 
nil を返すよう、定義されています。引数がリストでない場合、エラーになります
引数がリスト以外でもエラーになって欲しくない場合には、safe-car を使用します。

使用例：
  (car '(a b c))
  =&gt; a
  (car '())
  =&gt; nil
  (car "string")
  =&gt; 不正なデータ型です: "string": cons
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>cdr</title>
<type>Function</type>
<arguments>list</arguments>
<package>lisp</package>
<description>
リストの二番目以降をリストで返します。

コンスセル list の 2 番目のポインタを返します。 list が nil の場合 cdr 
は nil を返すよう、定義されています。引数がリストでない場合、エラーにな
ります。引数がリスト以外でもエラーになって欲しくない場合には、safe-cdrを
使用します。

使用例：
  (cdr '(a b c))
  =&gt; (b c)
  (cdr '())
  =&gt; nil
  (cdr "string")
  =&gt; 不正なデータ型です: "string": cons
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>cons</title>
<type>Function</type>
<arguments>x y</arguments>
<package>lisp</package>
<description>
新しいリストを返します。

主に、新しくリストを作る際に用いる関数です。これは object1 を car、 
object2 を cdr として、コンスセルを新しく作り、この新しいコンスセルへの
ポインタを返します。 (通常はリストですが) object2 が特定のあるタイプでな
くてはならないという制限はありません。

使用例：
  (cons 1 '(2))
  =&gt; (1 2)
  (cons 1 '())
  =&gt; (1)
  (cons 1 2)
  =&gt; (1 . 2)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nth</title>
<type>Function</type>
<arguments>N LIST</arguments>
<package>lisp</package>
<description>
リストの N 番目の要素を返します。

  N    : リストのインデックスを指定します。0を基底とします。
  LIST : 要素を返すリストです。

N がリストの長さを越えていれば nil を返します。 N が負数であればエラーを
返します。

  (nth n x) == (car (nthcdr n x))

使用例：
  (nth 2 '(1 2 3 4))
  =&gt; 3
  (nth 10 '(1 2 3 4))
  =&gt; nil
  (nth -3 '(1 2 3 4))
  =&gt; 範囲外の値です: -3
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>nthcdr</title>
<type>Function</type>
<arguments>N LIST</arguments>
<package>lisp</package>
<description>
リストの N 番目の cdr を返します。

  N    : リストのインデックスを指定します。0を基底とします。
  LIST : 要素を返すリストです。

N がリストの長さを越えていれば nil を返します。 N が負数であればエラーを
返します。

使用例：
  (nthcdr 1 '(1 2 3 4))
  =&gt; (2 3 4)
  (nthcdr 10 '(1 2 3 4))
  =&gt; nil
  (nthcdr -3 '(1 2 3 4))
  =&gt; 範囲外の値です: -3
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-list</title>
<type>Function</type>
<arguments>SIZE &amp;key :INITIAL-ELEMENT</arguments>
<package>lisp</package>
<description>
指定された長さのリストを作成して返します。

  SIZE             : リストの長さ
  :INITIAL-ELEMENT : リストの要素

使用例：
  (make-list 3)
  =&gt; (nil nil nil)
  (make-list 0)
  =&gt; nil
  (make-list 2 :initial-element 'x)
  =&gt; (x x)
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>append</title>
<type>Function</type>
<arguments>&amp;rest LISTS</arguments>
<package>lisp</package>
<description>
この関数は、LISTS の全要素を含むリストを返します。最後の 1 つを除いた各
リストは全てコピーされ、変更されることはありません。empty シーケンスは結
果に何の影響も及ぼしませんが、最後に置かれた nil はその前の全引数のコピ
ーを作らせることになる点に注意して下さい。

1 つの機能として、 (整数型のシーケンスではなく) LISTS の 1 つが整数型で
ある特別な場合には、最初にその整数型の 10進 print 表現の文字列に変換しま
す。（この機能本当にありますか？）

最後の引数は、どんなオブジェクトであってもかまいません。ただし、通常はリ
ストであり、コピーされたり変換されることはありません。 LISTSが与えられな
い場合には、nil を返します。

使用例：
  ;;; 整数型の変換の機能があるのかどうか不明
  (setq x '(1 2 3))               =&gt; (1 2 3)
  (append x '(4 5))               =&gt; (1 2 3 4 5)
  x                               =&gt; (1 2 3)
  (eq x (append x nil))           =&gt; nil
  (append nil x [4 5] "67" nil)   =&gt; (1 2 3 4 5 54 55)
  (append)                        =&gt; nil
</description>
<seealso>nconc</seealso>
<seealso>copy-sequence</seealso>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>parse-integer</title>
<type>Function</type>
<arguments>STRING &amp;key :START :END :RADIX :JUNK-ALLOWED</arguments>
<package>lisp</package>
<description>
文字列を整数に変換して返します。数値そのものと、元の文字列の有効な桁数を
多値で返します。

--- 原文 ---
Description: examines the characters of string specified by :start and 
:end, and attempts to parse an integer ignoring whitespace characters. 
The keyword :radix defines the base to which the integer is to be parsed 
and must be in the range 2 to 36. If :junk-allowed is non-nil, the first 
value returned is the integer parsed or nil if no acceptable digits were 
found. If :junk-allowed is nil, an error is signaled if the substring is 
not an integer in the appropriate base, with optional sign. Note that 
radix specifiers #o, #b, #x and #nR are not recognized, nor is the decimal 
point.

--- 意訳 ---
parse-integer は :START と :END で示された文字の並びをチェックし、空白
文字を無視して整数の読み込みを試みます。 :RADIX キーワードは数値が読み込
まれるべき基数を定義します。基数は 2 から 36 までの範囲になければなりま
せん。もし、 :JUNK-ALLOWED が nil 以外で読み込めない文字があれば nil と
なります。もし、 :JUNK-ALLOWED が nil で読み込めない文字があればエラーを
発生します。なお、基数として#o #b #x 及び #nR は認識できないので注意する
こと。

# となっていますが、空白は入ってはだめみたい。

使用例：
  (parse-integer "123")
  =&gt; 123
     3
  (parse-integer "123+23")
  =&gt; 不正な数値の形式です: "123+23"
  (parse-integer "123+23" :junk-allowed t)
  =&gt; nil
     3
  (parse-integer "a" :radix 16)
  =&gt; 10
</description>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-difference</title>
<type>Function</type>
<arguments>LIST1 LIST2 &amp;rest REST &amp;key TEST TEST-NOT KEY</arguments>
<package>lisp</package>
<description>
二つのリストの差を返します。

--- 原文 ---
Description: Copies list1 and list2 and returns the 
elements of list1 that do not match any element in list2 using the test 
specified by the :test or :test-not argument. The order of the elements 
in the returned list may not reflect their relative positions within 
list1.

--- 意訳 ---
set-difference は LIST1 と LIST2 をコピーして、LIST2 に一致しない LIST1 
の要素を返します。一致のテストは :TEST 及び :TEST-NOT の引数で指定します。
返されるリストの要素の順番は、LIST1 の順番を保証しません。

使用例：
  (set-difference  '(3 6 9) '(2 4 6 8 10))
  =&gt; (9 3)
</description>
<seealso>nset-difference</seealso>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>mapcar</title>
<type>Function</type>
<arguments>FUNCTION LIST &amp;rest MORE-LISTS</arguments>
<package>lisp</package>
<description>
引数のリストから関数の戻り値のリストを作成して返します。
初回は各リストのcarを、二回目はcadrを、三回目はcaddrを関数に渡します。
リストが複数の場合が分かりにくいので図示します。

  ;;; リストが一つ      ┌──┐┌──┐┌──┐
  (mapcar #'char-name '(│ #\a││ #\b││ #\c│))
                        └─┬┘└─┬┘└─┬┘
                    ┌───┘      │      └───┐
                    ↓              ↓              ↓
  == (list (char-name #\a) (char-name #\b) (char-name #\c))
  == (list "latin_small_letter_a" "latin_small_letter_b" "latin_small_letter_c")
  =&gt; ("latin_small_letter_a" "latin_small_letter_b" "latin_small_letter_c")

  ;;; リストが複数   ┌─┐┌─┐┌─┐
  (mapcar #'+      '(│ 1││ 2││ 3│ 4)
                   '(│ 1││ 3││ 5│  )
                   '(│ 1││ 4││ 9│16)
                   '(│ 1││ 8││27│  )) 
                     └┬┘└┬┘└┬┘
             ┌────┘┌─┘    │   
             ↓          ↓        ↓         
  == (list (+ 1 1 1 1) (+ 2 3 4 8) (+ 3 5 9 27))
  == (list 4 17 44)
  =&gt; (4 17 44)

--- 原文 ---
Description: passes successive, corresponding top level elements of each 
of the lists to function. function should thus be able to accept as many 
arguments as there are lists. The value returned by mapcar is a list of 
the values returned by each function call. If the argument lists are not 
of equal length, evaluation of the mapcar form is terminated when the 
last element of the shortest list has been passed to function. Any elements 
in the other lists that have not been processed are ignored.

--- 意訳 ---
mapcar は各リストの最上位の対応する要素群を FUNCTION に引き渡します。
FUNCTION はリストのような多くの引数を受け入れられなければなりません。
mapcar が返す値は、FUNCTION のそれぞれの呼び出した値のリストです。もし、
引数のリストが同じ長さでなかったら、mapcar の評価は一番短いリストで終わ
ります。

使用例：
  (mapcar #'+ '(1 2 3 4) 
              '(1 3 5) 
              '(1 4 9 16) 
              '(1 8 27)) 
  =&gt; (4 17 44)
</description>
<seealso>maplist</seealso>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>maplist</title>
<type>Function</type>
<arguments>FUNCTION LIST &amp;rest MORE-LISTS</arguments>
<package>lisp</package>
<description>
引数のリストから関数の戻り値のリストを作成して返します。
初回は各リストを、二回目はcdrを、三回目はcddrを関数に渡します。

--- 原文 ---
Description: similar to mapcar but passes successive, corresponding tails 
of the argument lists to function. So, on the first call to function, the 
argument lists are passed in their entirety. On the second call the cdr 
of each argument list is passed. On the third, the cddr of each argument 
list is passed, and so on. This process is repeated until the tail of an 
argument list is a null list. The value returned by maplist is a list of 
the values returned by each call to function.

--- 意訳 ---
maplist は、FUNCTION に対応するテイルの部分を FUNCTION に渡すことを除い
て、mapcar に良く似ている。FUNCTION の最初の呼び出しで、引数のリストは完
全に渡されます。二度目の呼び出しでは各引数の、 cdr  が渡されます。

使用例：
  (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))
  =&gt; ((foo a . #1=(b . #2=(c . #3=(d)))) (foo . #1#) (foo . #2#) (foo . #3#))
</description>
<seealso>mapcar</seealso>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>mapcan</title>
<type>Function</type>
<arguments>function list &amp;rest more-lists</arguments>
<package>lisp</package>
<description>
引数の渡し方はmapcarによく似ていますが、関数の呼び出し結果のリストをくっ
つけたものを返します。

--- 原文 ---
Description: similar to mapcar except that the values returned by calls 
to function are combined using the destructive function nconc rather than 
the non-destructive function list. As such, mapcan can potentially destroy 
its arguments.

--- 意訳 ---
mapcanはFUNCTIONによって返された値が（non-destructiveな関数listではなく、
destructiveな関数nconcによって）結合されることを除いて、mapcarに良く似て
いる。そのため、mapcanはその定義から引数を破壊することになっている。

使用例：
  ;;; mapcanとmapcarとの違い
  (mapcan #'(lambda (x) (and (characterp x) (list (char-name x))))
          '(456 #\A 789 #\b #\c 123))
  =&gt; ("latin_capital_letter_a" "latin_small_letter_b" "latin_small_letter_c")
  (mapcar #'(lambda (x) (and (characterp x) (list (char-name x))))
          '(456 #\A 789 #\b #\c 123))
  =&gt; (nil ("latin_capital_letter_a") nil ("latin_small_letter_b") ("latin_small_letter_c") nil)
</description>
<seealso>mapcar</seealso>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>mapcon</title>
<type>Function</type>
<arguments>mapcon FN LISTS &amp;rest MORE-LISTS</arguments>
<package>lisp</package>
<description>
引数の渡し方はmaplistによく似ていますが、関数の呼び出し結果のリストをくっ
つけたものを返します。
</description>
<seealso>maplist</seealso>
<link></link>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>mapc</title>
<type>Function</type>
<arguments>function list &amp;rest more-lists</arguments>
<package>lisp</package>
<description>
引数の渡し方はmapcarとよく似ていますが、戻り値には与えられたリストをその
まま返します。

--- 原文 ---
Description: similar to mapcar except that the value returned is list 
rather than a list of values returned by the calls to function. As such, 
a mapc form is evaluated for its side effects rather than the value it 
returns.

--- 原文 ---
mapcはFUNCTIONによって返された値が、多値ではなくlistである点を除いて、
macpcarに良く似ている。そのため、mapcは戻り値ではなく副作用を目的として
評価される。
</description>
<seealso>mapcar</seealso>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>mapl</title>
<type>Function</type>
<arguments>mapl FUNCTION LIST &amp;rest MORE-LISTS</arguments>
<package>lisp</package>
<description>
引数の渡し方はmaplistとよく似ていますが、戻り値には与えられたリストをそ
のまま返します。
</description>
<seealso>maplist</seealso>
<link></link>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>setq-default</title>
<type>Macro</type>
<arguments>setq-default VAR VAL</arguments>
<package>editor</package>
<description>
シンボルがローカルでない場合のデフォルトの値を設定します。

この関数は、各 symbol のデフォルト値を、(それに対応する) value に設定し
ます。(symbol は評価しませんが) value は評価します。最初の value を返し
ます。 

デフォルト値は、固有のバッファローカル値を持たないバッファで見られます。 

カレントバッファで symbol がバッファローカルでない場合、これは (この)カ
レントバッファで setq を行なうのと同じことになります。 symbol がカレント
バッファでバッファローカルである場合、カレントバッファで見える値ではなく、
他のバッファがまだバッファローカルな値を持たない場合にそこで見える値を設
定します。

使用例：
  (make-variable-buffer-local 'local)
  =&gt; local
  ;; バッファ foo 中:
  (setq local 'foo)
  =&gt; foo
  ;; バッファ bar 中:
  local
  =&gt; nil
  (setq-default local 'default)
  =&gt; default
  local
  =&gt; default
  (setq local 'bar)
  =&gt; bar
  ;; バッファ baz 中:
  local
  =&gt; default
  ;; バッファ foo 中:
  (setq local 'foo)
  =&gt; foo
  (default-value 'local)
  =&gt; default
</description>
<section>変数と定数</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>setq</title>
<type>Function</type>
<arguments>setq {VAR FORM}*</arguments>
<package>lisp</package>
<description>
変数に値を設定します。

  (setq 変数1 値1 変数2 値2 ... 変数N 値N)

上記の様に変数と値の組を任意の数だけ並べることができます。

  (setq foo '(1 2 3)) = (set 'foo '(1 2 3))

使用例：
  ;;; setとsetqで同じことをしてみる。
  (set 'foo '(2 3 4))   =&gt; (2 3 4)
  foo                   =&gt; (2 3 4)
  (setq foo '(1 2 3))   =&gt; (1 2 3)
  foo                   =&gt; (1 2 3)
</description>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-default</title>
<type>Function</type>
<arguments>set-default SYMBOL VALUE</arguments>
<package>lisp</package>
<description>
この関数は、ただ 1つの symbol と 1 つの value のみを許す点と、その両方を
評価する点とを除き setq-default と同じです (setq-default 参照)。

使用例：
  (set-default (car '(a b c)) 23)
  =&gt; 23
</description>
<seealso>setq-default</seealso>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>global-set-key</title>
<type>Function</type>
<arguments>KEY COMMAND</arguments>
<package>editor</package>
<description>
グローバルなキーマップにキーを登録します。

使用例：
 (global-set-key #\C-r          'previous-page)
 (global-set-key #\S-Left       'selection-backward-char)
 (global-set-key #\S-C-Left     'selection-backward-word)
</description>
<seealso>global-unset-key</seealso>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>define-key</title>
<type>Function</type>
<arguments>KEYMAP KEY COMMAND</arguments>
<package>editor</package>
<description>
キーマップのキーにコマンドを割り当てます。

  KEYMAP  : キーマップ
  KEY     : 登録するキー
  COMMAND : 実行するコマンド

使用例：
  ;;; Ctrl-X fのキー割り当てを変える
  (define-key ctl-x-map #\f 'my-find-file)
  =&gt; t 
  ;;; Esc-f のキー割り当てを変える
  (define-key esc-map #\f 'my-find-file)
  =&gt; t
  ;;; Ctrl-C aのキー割り当てを変える
  (define-key spec-map #\a 'my-find-file)
  =&gt; t
</description>
<seealso>undefine-key</seealso>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>undefine-key</title>
<type>Function</type>
<arguments>KEYMAP KEY</arguments>
<package>editor</package>
<description>
キーマップのキーの割り当てを解除します。

  KEYMAP : キーマップ
  KEY    : 削除するキー

使用例：
  ;;; C-lをfiler-reloadに割り当てて、解除してみる
  (define-key filer-keymap #\C-l 'filer-reload)
  =&gt; t
  (undefine-key filer-keymap #\C-l)
  =&gt; t
</description>
<seealso>define-key</seealso>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>各種言語キーマップ</title>
<type>Tips</type>
<arguments></arguments>
<description>
プログラム言語毎（というか、モード毎）にキーマップを変更することができます。

  ;;; 言語用キーマップ一覧
  *basic-mode-map*              ; BASIC用
  *csharp-mode-map*             ; C#用
  *c-mode-map*                  ; C言語用
  *c++-mode-map*                ; C++用
  *css-mode-map*                ; CSS用
  *html-mode-map*               ; HTML用
  *idl-mode-map*                ; IDL用
  *java-mode-map*               ; java用
  *LaTeX-mode-map*              ; LaTeX用
  *lisp-mode-map*               ; lisp用
  *pascal-mode-map*             ; PASCAL用
  *perl-mode-map*               ; Perl用
  *sql-mode-map*                ; SQL用

  ;;; その他キーマップ一覧
  *box-drawings-mode-map*       ; 罫線描画モード用
  *buffer-menu-mode-map*        ; buffer-menu用
  *calc-mode-map*               ; calc用
  *calendar-mode-map*           ; calendar用
  *den8-view-mode-map*          ; 電信八号のメール表示用
  *den8-summary-mode-map*       ; 電信八号のメール一覧表示用
  *den8-draft-mode-map*         ; 電信八号の下書き用
  *diff-mode-map*               ; diff用
  *async-grep-mode-map*         ; 非同期grep用
  *lisp-interaction-mode-map*   ; *scratch*というかlisp-interaction-mode用
  *fundamental-mode-map*        ; モードが無いとき用
  *log-summary-mode-map*        ; niftyのログ一覧用
  *log-article-mode-map*        ; niftyのログ用
  *command-output-mode-map*     ; 外部コマンド実行時用
  *shell-mode-map*              ; shellモード用
  *tail-f-mode-map*             ; tail-f用
  *text-mode-map*               ; テキスト用
  *view-mode-map*               ; テキスト表示用

使用例：
  ;;; c++-modeでのキー割り当てを変える
  (define-key ed::*c++-mode-map* #\C-s 'foo)

  ;;; lisp-modeでのキー割り当てを変える
  (define-key ed::*lisp-mode-map*  #\TAB 'lisp-complete-symbol)

  ;;; Lispインタラクションモードでのキー割り当てを変える
  (define-key ed::*lisp-interaction-mode-map* #\TAB 'lisp-complete-symbol)
</description>
<seealso>define-key</seealso>
<section>キーマップ</section>
</chapter>

<chapter>
<title>set-function-bar-label</title>
<type>Function</type>
<arguments>CHAR LABEL</arguments>
<package>editor</package>
<description>
ファンクションバーのラベルを変更します。

  CHAR  : 各ファンクファンクションバーに対応したキャラクタ
  LABEL : 表示するラベル

使用例
  (global-set-key #\F3 'search-forward-again)
  =&gt; t
  (set-function-bar-label #\F3 "次検索")
  =&gt; t
</description>
<seealso>set-number-of-function-bar-labels</seealso>
<section>キーマップ</section>
</chapter>

<chapter>
<title>find-file</title>
<type>Function</type>
<arguments>FILENAME &amp;optional NOMSG</arguments>
<package>editor</package>
<description>
指定されたファイルを開きます。

--- mule の説明 ---
Command: find-file filename

この関数は、 filename という名前のファイルを(ユーザーが)エディットできる
ようにします。 find-file-noselect を呼んでファイルに対するバッファを選択
(訳 注: select)します。 

インタラクティブに呼ばれた場合、 filename を求め(ミニバッファに)プロンプ
トを出します。 
</description>
<seealso>find-other-file</seealso>
<seealso>find-file-other-window</seealso>
<seealso>ed::find-file-internal</seealso>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>ed::find-file-internal</title>
<type>Function</type>
<arguments>find-file-internal FILENAME &amp;optional NOWARN (KANJI-CODE nil SVAR) NEWLINE-CODE NOMSG</arguments>
<description>
ファイルを開きます。find-fileはfind-file-internalを用いて実装されています。
find-fileは複数のファイルを開く機能がありますが、一つのファイルを開くの
であれば、こちらの方が高速です。

  FILENAME : ファイル名
</description>
<seealso>find-file</seealso>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>find-other-file</title>
<type>Function</type>
<arguments>find-other-file FILENAME &amp;optional NOMSG</arguments>
<package>editor</package>
<description>
現在のバッファを閉じて指定されたファイルを開きます。

互換性：
  muleにはなさそう。
</description>
<seealso>find-file</seealso>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>find-file-other-window</title>
<type>Function</type>
<arguments>filename &amp;optional nomsg</arguments>
<package>editor</package>
<description>
指定されたファイルを別のウィンドウで開きます。

--- mule の説明 ---
Command: find-file-other-window filename

この関数は、 (別のウィンドウで)ファイル filename をエディットします。 2
つもしくはそれ以上のウィンドウが画面上に存在する場合、選択されていない(
訳注: non-selected)ウィンドウを用います。 1つしかウィンドウが存在しない
場合、それを分割します。 nil を返します。 

インタラクティブに呼ばれた場合、 filename を求め(ミニバッファに)プロンプ
トを出します。 
</description>
<seealso>find-file</seealso>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>insert-file</title>
<type>Function</type>
<arguments>filename</arguments>
<package>editor</package>
<description>
指定されたファイルをカーソルの位置に読み込みます。

--- mule の説明 ---
Command: insert-file filename

この関数は、ファイル filename の内容をカレントバッファのポイントの後に挿
入します。 filename が読み込み可能なファイルでない場合、エラーになります。
これはインタラクティブに用いるためのもので insert-file-contents 以外のこ
とは (ほとんど)何も行ないません。 
</description>
<seealso>find-file</seealso>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>defvar</title>
<type>Macro</type>
<arguments>name &amp;optional (initial-value nil sv) doc</arguments>
<package>lisp</package>
<description>
グローバルなスペシャル変数を宣言します。ダイナミックなスコープを持ちます。

--- 以下muleの説明 ---

Special Form: defvar symbol [value [doc-string]]

この特殊フォームは、コードを読む人に対し、 symbol が変数として (通常)ロ
ーカルにバインドされずに用いられることを知らせます。 (通常) symbol には、
様々なプログラムで変更される値を与えます。 symbol は評価しません。 

上記の宣言に加え、 defvar は(この他に)いくつかの働きをします。 

オプショナルなアーギュメントを与えると、 defvar はアーギュメント var を
評価し、 symbol が(そうしなければ) unbound である場合、その結果を symbol
のグローバル値に設定します。 symbolがバインドされている場合、 value は評
価も行ないません。 

doc-string が存在する場合、それは、 (Emacs のヘルプシステムが見る) symbol 
のプロパティーリスト indicator (??)の variable-documentation の下に置か
れます。 doc-string の最初の文字が `*' である場合、この変数は (通常)ユー
ザーが変更を行なうユーザーオプションであるとされます。 user-variable-p 
がこれを見ます。 doc-string は評価されません。 

defvar はその値として symbol を返します。 

以下に示す最初の例では、(ユーザーに対し) foo を宣言します。このフォーム
は foo の値セルは設定しません。 2 番目のフォームは bar の値に 23 を設定
し、ドキュメンテーションストリングを与えます。 bar はユーザーオプション
ではありません。 4 番目のフォームは bar のドキュメンテーションストリング
を変更し、 bar をユーザーオプションにしますが、値は変えません(加算 (1+ 
23) は実行されません)。 

  (defvar foo)
  =&gt; foo
  (defvar bar 23 "The normal weight of a bar.")
  =&gt; bar
  (user-variable-p 'bar)
  =&gt; nil
  (defvar bar (1+ 23) "*The normal weight of a bar.")
  =&gt; bar
  bar
  =&gt; 23
  (user-variable-p 'bar)
  =&gt; t

次のフォームは、defvar に等価なものを示しています。 

  (defvar symbol value doc-string)
  ==
  (progn
    (if (not (boundp symbol))
        (setq symbol value))
    (put 'symbol 'variable-documentation 'doc-string)
    'symbol)
</description>
<section>変数と定数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>boundp</title>
<type>Function</type>
<arguments>symbol</arguments>
<package>lisp</package>
<description>
シンボルに値が設定されているかどうかを返します。

使用例：
  (boundp 'test)          =&gt; nil
  (defvar test "string")  =&gt; test
  (boundp 'test)          =&gt; t
</description>
<seealso>fboundp</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fboundp</title>
<type>Function</type>
<arguments>symbol</arguments>
<package>lisp</package>
<description>
シンボルに関数が定義されているかどうかを返します。

使用例：
  (fboundp 'car)
  =&gt; t
  (fboundp 't)
  =&gt; nil
</description>
<seealso>boundp</seealso>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>defun</title>
<type>Special Form</type>
<arguments>name (&amp;rest lambda-list) &amp;body body</arguments>
<package>lisp</package>
<description>
関数を定義します。

--- muleの説明 ---
defun は、新しく lisp 関数を定義する場合の(通常の)方法です。 defun は、 
symbol をこのフォームの残りの部分が示す関数の名前として定義します。 (こ
れは)このシンボルの関数セルが、 parameter-list と forms から作られるラム
ダ式 (lambda parameter-list . forms) を指すようにすることで行なわれます。
値セルは関数セルとは独立しているため、同じシンボルをグローバル変数として
用いてもかまいません。 

(上で述べたように) forms 中の最初の 2つのフォームは、ドキュメンテーショ
ンストリングや宣言であることができます。 defun は関数の再定義をチェック
してはいないため、 (car のような) primitive を何も知らせず(再)定義してし
まうことさえありえます。 defun は symbol を返します。 

  (defun foo () 5)
  =&gt; foo
  (foo)
  =&gt; 5
  (defun bar (a &amp;optional b &amp;rest c)
      (list a b c))
  =&gt; bar
  (bar 1 2 3 4 5)
  =&gt; (1 2 (3 4 5))
  (bar 1)
  =&gt; (1 nil nil)
  (bar)
  -&gt; ERROR: Wrong number of arguments.
  (defun capitalize-backwards ()
      "This function makes the last letter of a word upper-case."
      (interactive)
      (backward-word 1)
      (forward-word 1)
      (backward-char 1)
      (capitalize-word 1))
  =&gt; capitalize-backwards
</description>
<section>関数</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>let</title>
<type>Special Form</type>
<arguments>"({VAR|(VAR [VALUE])}*) {declaration}* {FORM}*"</arguments>
<package>lisp</package>
<description>
ローカルな変数を定義してフォームを評価します。

--- muleの説明 ---
この関数は、 binding-list に従い変数をバインドし、 forms 中の全てのフォ
ームを順に評価します。 let は (forms 中の)最後のフォームの値を返します。 

binding-list の各要素は、シンボル(この場合、そのシンボルは nil にバイン
ドされる)か、フォーム (symbol value-form) のリスト(この場合、let は value- 
form を評価した結果を symbol にバインドする) です。 

フォーム(の全て)を評価する前に let フォームを exit した場合、 (訳注：バ
インドされた)シンボルのローカルバインディングを取り去ります。 

value-form はシンボルのバインディングを行なう前に (全て)、現われた順に評
価されます(これにたよることができる??)。次の例において、Z は Y の前の値
(2)にバインドされ、新しい値にはバインドされません。 

  (setq Y 2)
  =&gt; 2
  (let (X
        (Y 1)
        (Z Y))
    (list X Y Z))
  =&gt; (nil 1 2)
</description>
<section>変数と定数</section>
<seealso>let*</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-namestring</title>
<type>Function</type>
<arguments>PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのファイル名の部分を返します。
  
使用例：
  (file-namestring "C:/xyzzy/xyzzy.exe")
  =&gt; "xyzzy.exe"
  (file-namestring "C:/Windows/")
  =&gt; ""

須田さんの場合：
  ;;; 須田さんは、こんなのを定義しているらしい。
  (defun file-name-directory (filename)
    (directory-namestring filename))

  (defun file-name-nondirectory (filename)
    (file-namestring filename))

  (defun file-name-sans-versions (name)
    "Return FILENAME sans backup versions or strings.
  This is a separate procedure so your site-init or startup file can
  redefine it."
    (substring name 0
             (or (string-match "\\.~[0-9]+~\\'" name)
                 (string-match "~\\'" name)
                 (length name))))
</description>
<seealso>directory-namestring</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>point-min</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
カレントバッファの一番小さなポイント値を返します。narrow-to-region等で、
clipping 制限が用いられてない限り 0 になります。 

使用例：
  (point-min)
  =&gt; 0
</description>
<section>ポジション</section>
<seealso>point-max</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>point-max</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
カレントバッファの一番大きなポイント値を返します。narrow-to-region等で、
clipping 制限が用いられてない限り、カレントバッファの大きさになります。 

使用例：
  (point-max)
  =&gt; 189568
</description>
<seealso>point-min</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>forward-line</title>
<type>Function</type>
<arguments>&amp;optional (arg 1)</arguments>
<package>editor</package>
<description>
次行に移動します。

--- muleの説明 ---
Command: forward-line &amp;optional count

この関数は、ポイントを今の位置から count 行下の行の先頭に動かします。 
count が負の場合、上に動かします。 

バッファ(もしくは clipped 領域)中に十分な行が存在しない場合、ポイントを
バッファ(もしくは clipped 領域) の先頭(もしくは終端)に動かします。 

count と実際に動いた行数との差を返します。 3 行しかないバッファの頭から 
5 行下に動かすよう指示すると、ポイントをその最後の行の終りに位置付け、2 
を返すことになります。 

インタラクティブに呼ばれた場合、 count は数値のプレフィックスアーギュメ
ントになります。 
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>save-excursion</title>
<type>Special Form</type>
<arguments>"{FORM}*"</arguments>
<package>editor</package>
<description>
処理の前後でカレントバッファとポイントを保存します。ウィンドウのレイアウ
トは保存しないので注意してください。

ウィンドウのレイアウトも保存したい場合には、save-window-excursionを使います。

--- muleの説明 --- 
この特殊フォームは、カレントバッファのポイントとマークをセーブし、 forms 
を評価し、ポイントとマークをリストアします。 (throw や error による) 異
常 exit の場合もポイントとマークの値をリストアします。マーカーはバッファ
中のポジションとともにそのバッファも指しているため、マークをリストアする
ことは (Emacs の) カレントバッファの notion (訳注：??) もリストアするこ
とになります。 

カレントバッファの notion を変更しなくてはいけない場合や、カレントバッフ
ァのポイントを動かさなくてはいけない場合、カレントバッファとポイントをリ
ストアできるようにするのは (標準的な)方法です。 

別のバッファのポイントやマークはセーブされません。このため(それらの)ポイ
ントやマークに対する変更は save-excursion の exit 後も保持されます。 

save-excursion は、switch-to-buffer のような関数で破壊されたウィンドウと 
バッファの対応はリストアしません。 selected ウィンドウをリストアする方法
の 1つは save-excursion 中で save-window-excursion を用いることです(セク
ショ ン 25.11 [save-window-excursion]、ページ 248 参照)。 

返される値は(最後に)評価されたフォームの返す値か、フォームが与えられてい
ない場合 nil になります。
</description>
<section>ポジション</section>
<seealso>save-window-excursion</seealso>
<seealso>save-restriction</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-vector</title>
<type>Function</type>
<arguments>length &amp;key (element-type t) (initial-element nil ies-p) (initial-contents nil ics-p) fill-pointer adjustable displaced-to (displaced-index-offset 0)</arguments>
<package>lisp</package>
<description>
指定した長さのベクタを返します。

使用例：
  ;;; 長さが10のベクタを作ります。
  (make-vector 10)
  =&gt; #(nil nil nil nil nil nil nil nil nil nil)

  ;;; :element-typeにcharacterを指定すると文字列が作成できる
  (make-vector 10 :element-type 'character)
  =&gt; "^@^@^@^@^@^@^@^@^@^@"
</description>
<section>配列</section>
<file>array.l</file>
</chapter>

<chapter>
<title>length</title>
<type>Function</type>
<arguments>シーケンス</arguments>
<package>lisp</package>
<description>
sequence(文字列や、リスト、配列)の長さを求めます。
配列にfill-pointerがある場合は、そこまでの長さになります。

使用例：
  (length "abcd")               =&gt; 4
  (length (list 1 2 3))         =&gt; 3
  (length (make-array 7))       =&gt; 7
  (length (make-array 7 :fill-pointer 4))
                                =&gt; 4
</description>
<section>シーケンス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list</title>
<type>Function</type>
<arguments>&amp;rest objects</arguments>
<package>lisp</package>
<description>
この関数は、 objects を要素とするリストを作ります。結果として返されるリ
ストは(常に) nil でターミネート(訳注：終端)されています。 objects が与え
られない場合、 empty リストを返します。 

  (list 1 2 3 4 5)
  =&gt; (1 2 3 4 5)
  (list)
  =&gt; nil
</description>
<section>リスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dolist</title>
<type>Macro</type>
<arguments>(var listform &amp;optional (resultform ''nil)) &amp;body body</arguments>
<package>lisp</package>
<description>
リストの長さ分だけ繰り返しを行います。

  (dolist (&lt;変数&gt; &lt;リスト式&gt; &lt;値&gt;)
    &lt;式1&gt; ... &lt;式n&gt;)

まず&lt;リスト式&gt;を評価する。その後リストの要素ごとに変数をその要素に
バインドして，本体の&lt;式1&gt;～&lt;式n&gt;までを評価する。本体式の評価
が全ての要素に対して終わると，&lt;値&gt;を評価し，dolistの値として返す。
また&lt;値&gt;は省略でき，その場合はdolistの値はnilである。

dolist式の一般形は，
  
  (do* ((temp &lt;リスト式&gt; (cdr temp))
        (&lt;変数&gt; (car temp) (car temp)))
      ((endp temp) &lt;値&gt;)
    &lt;式1&gt;
    ...
    &lt;式n&gt;)
  
と同値である。

使用例：
  (let ((result nil))
    (dolist (item '("Lois" "Charley" "David") (nreverse result))
      (push (length item) result))))
  =&gt; (4 7 5)
</description>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>kill-region</title>
<type>Function</type>
<arguments>from to</arguments>
<package>editor</package>
<description>
リージョンをkill ringに入れます。

--- kill ringのいい加減な説明 ---
kill-regionした文字列は、*kill-ring*の先頭に追加されます。*kill-ring*は
最大で*kill-ring-max*（標準で16）まで保持できます。最大を越えたら古いも
のから破棄されます。

        *kill-ring*
        ┌─────┐  ─┐
        │"defun"   ←─── kill-regionした内容
        ├──↓──┤    │
        │"length"  │    │
        ├──↓──┤    ├最大*kill-ring-max*個
        │"test"    │    │
        ├──↓──┤    │
        │...       │    │
        └─────┘  ─┘

普通はkill[C-k]してyank[C-y]したら、*kill-ring*の先頭のものしか貼り付け
られませんが、killした直後にyank-pop[M-y]を繰り返すと、*kill-ring*の要素
を順次貼り付けてくれます。
</description>
<section>テキスト</section>
<file>region.l</file>
</chapter>

<chapter>
<title>point</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
この関数は、ポイントの位置を integer として返します。 
goto-char でその位置に飛ぶことが出来ます。バッファの先頭ではpoint-minに
等しく、バッファの最後ではpoint-maxに等しいです。

使用例：
  (point)
  =&gt; 175
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>prog1</title>
<type>Special Form</type>
<arguments>"{FORM}*"</arguments>
<package>lisp</package>
<description>
フォームを順番に評価して最初のフォームの結果を返します。

使用例：
  (progn (print "The first form")
         (print "The second form")
         (print "The third form"))
  -&gt; "The first form"
  -&gt; "The second form"
  -&gt; "The third form"
  =&gt; "The first form"
</description>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>progn</title>
<type>Special Form</type>
<arguments>"{FORM}*"</arguments>
<package>lisp</package>
<description>
フォームを順番に評価して最後のフォームの結果を返します。

使用例：
  (progn (print "The first form")
         (print "The second form")
         (print "The third form"))
  -&gt; "The first form"
  -&gt; "The second form"
  -&gt; "The third form"
  =&gt; "The third form"
</description>
<section>制御構造</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>end-of-line</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
現在行の終りに移動します。
</description>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>キー表現使用可能文字</title>
<type>Tips</type>
<arguments></arguments>
<description>
#\aや#\C-bのように表現します。ただし、"'(),;`\| の9文字は、
lispの構文上の特別な意味があるので、それを抑制するために
'\'を前置します。

  #\a           ; a
  #\;           ; ;
  #\C-b         ; Ctrl+b
  #\C-\;        ; Ctrl+;
  #\M-\;        ; Alt+;
  #\C-M-\;      ; Ctrl+Alt+;

Ctrl、Alt、Shiftの同時押しも表現できます。C-、M-、S-の順番は何でも良いです。

  #\C-          ; Ctrl同時押し
  #\S-          ; Shift同時押し
  #\C-S-        ; Ctrl+Shift同時押し
  #\M-          ; Alt同時押し
  #\M-C-        ; Alt+Ctrl同時押し
  #\M-S-        ; Alt+Shift同時押し
  #\M-C-S-      ; Alt+Ctrl+Shift同時押し


キーによっては同時押しできるキーに制限があります。
例えばS-TABは普通のやり方ではできません。どうしてもやりたければ、
set-extended-key-translate-table を参照して下さい。

  ┌─────────────┬─────────────┐
  │キー                      │同時押しできるキー        │
  │                          ├─┬─┬─┬─┬─┬─┬─┤
  │                          │M │C │M │S │C │M │M │
  │                          │  │  │C │  │S │S │C │
  │                          │  │  │  │  │  │  │S │
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │ !"#$%&amp;'()*+,-./          │○│○│○│Ｘ│Ｘ│Ｘ│Ｘ│
  │0123456789:;&lt;=&gt;?          │  │  │  │  │  │  │  │
  │@ABCDEFGHIJKLMNO          │  │  │  │  │  │  │  │
  │PQRSTUVWXYZ[\]^_          │  │  │  │  │  │  │  │
  │`abcdefghijklmno          │  │  │  │  │  │  │  │
  │pqrstuvwxyz{|}~           │  │  │  │  │  │  │  │
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │SPC       スペースキー    │○│○│Ｘ│Ｘ│Ｘ│Ｘ│Ｘ│
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │TAB       Tabキー         │○│Ｘ│Ｘ│Ｘ│Ｘ│Ｘ│Ｘ│
  │LFD                       │  │  │  │  │  │  │  │
  │RET       Enterキー       │  │  │  │  │  │  │  │
  │ESC       Escキー         │  │  │  │  │  │  │  │
  │DEL                       │  │  │  │  │  │  │  │
  │NUL                       │  │  │  │  │  │  │  │
  ├─────────────┼─┼─┼─┼─┼─┼─┼─┤
  │PageUp    Page Upキー     │○│○│○│○│○│○│○│
  │PageDown  Page Downキー   │  │  │  │  │  │  │  │
  │End       Endキー         │  │  │  │  │  │  │  │
  │Home      Homeキー        │  │  │  │  │  │  │  │
  │Left      ←キー          │  │  │  │  │  │  │  │
  │Up        ↑キー          │  │  │  │  │  │  │  │
  │Right     →キー          │  │  │  │  │  │  │  │
  │Down      ↓キー          │  │  │  │  │  │  │  │
  │Select    どのキー?       │  │  │  │  │  │  │  │
  │Print     どのキー?       │  │  │  │  │  │  │  │
  │Execute   どのキー?       │  │  │  │  │  │  │  │
  │Snapshot  どのキー?       │  │  │  │  │  │  │  │
  │Insert    Insertキー      │  │  │  │  │  │  │  │
  │Delete    Deleteキー      │  │  │  │  │  │  │  │
  │Help      どのキー?       │  │  │  │  │  │  │  │
  │F1～F24   F1～F24キー     │  │  │  │  │  │  │  │
  │LBtnDown  左ボタン押し    │  │  │  │  │  │  │  │
  │LBtnUp    左ボタン離し    │  │  │  │  │  │  │  │
  │LBtnMove  左ボタンドラッグ│  │  │  │  │  │  │  │
  │RBtnDown  右ボタン押し    │  │  │  │  │  │  │  │
  │RBtnUp    右ボタン離し    │  │  │  │  │  │  │  │
  │RBtnMove  右ボタンドラッグ│  │  │  │  │  │  │  │
  │MBtnDown  中ボタン押し    │  │  │  │  │  │  │  │
  │MBtnUp    中ボタン離し    │  │  │  │  │  │  │  │
  │MBtnMove  中ボタンドラッグ│  │  │  │  │  │  │  │
  └─────────────┴─┴─┴─┴─┴─┴─┴─┘

例えば、RETとC-mは内部的には同じキーと見なされます。このようなキーは以下
のとおりです。

    TAB         ; #\C-i
    LFD         ; #\C-j
    RET         ; #\C-m
    ESC         ; #\C-[
    DEL         ; #\C-?
    NUL         ; #\C-@
    #\C-SPC     ; #\C-@
</description>
<seealso>global-set-key</seealso>
<seealso>define-key</seealso>
<section>キーマップ</section>
<file></file>
</chapter>

<chapter>
<title>set-extended-key-translate-table</title>
<type>Function</type>
<arguments>key c</arguments>
<package>editor</package>
<description>
通常は同時押しができないキーを別のキーに振り向けるテーブルです。

| c-modeでシフトを押しながらTABを押した時に
| インデントしてもらおうと思ったんですが、
| #\TABを#\S-TABにしたらSHIFTは使えませんとのことで。

残念ながらまともな手段では Shift+Tab は使えません。が、まともでない手
段が用意されています。

  (set-extended-key-translate-table exkey-S-tab #\F20)

このようにしておくと、Shift+Tab が押されたときに F20 が押されたふりをするので

  (global-set-key #\F20 'foo)

とすればお望み通り(^^

exkey-... に指定できるのは以下の通り。

  exkey-space
  exkey-S-space
  exkey-C-space
  exkey-S-C-space
  exkey-M-space
  exkey-S-M-space
  exkey-C-M-space
  exkey-S-C-M-space
                   
  exkey-backspace
  exkey-S-backspace
  exkey-C-backspace
  exkey-S-C-backspace
  exkey-M-backspace
  exkey-S-M-backspace
  exkey-C-M-backspace
  exkey-S-C-M-backspace
  
  exkey-tab
  exkey-S-tab
  exkey-C-tab
  exkey-S-C-tab
  
  exkey-return
  exkey-S-return
  exkey-C-return
  exkey-S-C-return
  exkey-M-return
  exkey-S-M-return
  exkey-C-M-return
  exkey-S-C-M-return
  
  exkey-escape
  exkey-S-escape

  exkey-zenkaku
  exkey-S-zenkaku
  exkey-C-zenkaku
  exkey-S-C-zenkaku
  exkey-S-M-zenkaku
</description>
<section>キーマップ</section>
<file>keyboard.l</file>
</chapter>

<chapter>
<title>*kbd-translate-table*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
多分、入力された物理的なキーを論理的なキーに変換するためのものです。
この論理的なキーは、F13～F24などのように存在しないキーに振り向けることが
出来ます。例えば、キートップのラベルに別の文字のラベルを貼り付けるような
ものだと思います。

  ・物理的なキーから論理的なキーへの変換
  ・ローカルキーマップに論理的なキーの設定があればコマンド実行
  ・グローバルキーマップに論理的なキーの設定があればコマンド実行

使用例：
  ;;; C-[ と ESC を別物にする
  (setf (svref *kbd-translate-table* (char-code #\C-[)) #\F15)
  (global-set-key #\F15 'xxxx)

  ;;; BSとCtrl-hを別物にする
  (setf (svref *kbd-translate-table* (char-code #\C-h)) #\F13)
  (global-set-key #\F13 'replace-dialog)
</description>
<section>キーマップ</section>
<file>keyboard.l</file>
</chapter>

<chapter>
<title>interactive</title>
<type>Special Form</type>
<arguments>"{INTERACTIVE-STRING {PARAMETER}*|LIST}"</arguments>
<package>editor</package>
<description>
対話的なマクロ関数の定義は、必ずinteractiveを指定する必要があります。
以下の場面で使われるマクロ関数は対話的でなければなりません。

  1) M-x から呼び出す場合
  2) define-key, global-set-key でキーバインドする場合
  3) ツールバーに登録する場合

以下のように引数を対話的に渡すことも可能です。

  ;;; 引数が何もない時
  (defun foo ()
    (interactive) ... )

  ;;; 引数がある時
  (defun foo (n)
    (interactive "nPercent: ") ... )

nPercent:のうち最初の１文字(ここではn）だけが以下のような意味を持ちます。
２文字目以降(Percent:)は,ミニバッファに表示される説明の文字列になります。

  b   既に存在するバッファの名前
  f   既に存在するファイルの名前
  n   数字（整数）
  s   文字列
  B   バッファの名前（存在しなくてもよい）
  F   ファイルの名前  （存在しなくてもよい）
  N   数字。ただし、コマンドがプレフィックス付きで起動された場合は、
      それを用いる
  S   シンボル
  D   ディレクトリ
  l（エル）  ファイルの複数選択です。ファイル名のリストが取れます。

  :title0 "mojiretsu"
  :default0 "bar"
                  :default0 , :default1, :default2というように指定できます
  :history0 'execute

--99/08/23追加
 1. (interactive "0C \n1s \n2b") みたいに、
    制御文字(って言うのでしょうか？)の前に数字を
    いれられるようなのですが、これはどういう意味
    を持つのでしょうか？
    # misc.l の execute-extended-command に実例
    # がありますけど、さっぱ分かりまへん。(^^;

0 のとき、プロンプトに数引数がつきます。それ以外の場合
は無視されます。結局、たいした意味はありません(^^;

|  2. (interactive "s何？ : " :history0 "ん？") と
|     いった、:history[01]? とその組みになる引数は、
|     どういう働きをするんでしょうか？

ミニバッファを初期化する際に呼ばれる *enter-minibuffer-hook* 
(minibuf.l の prologue-minibuffer)の引数に使われます。
ちなみに、minibuffer-initialize の設計はたぶん間違って
ます。


--------------以下muleの説明---------------------------
Special Form: interactive [arg-descriptors]

この特殊フォームは、(これを持つ)関数がコマンドであること、(つまり) "M-x 
か、それにバインドされたキーを入力することでインタラクティブに呼び出すこ
とができる" こと、を宣言します。 arg-descriptors は、"(対象とする)関数を
インタラクティブに呼ぶ場合、どのようにアーギュメントを与えるか" を示しま
す。 interactive は(呼ばれた場合)何も行ないません。 arg-descriptors の評
価も行なわず、(常に) nil を返します。 arg-descriptors が与えられない場合、 
(対象とする)関数はアーギュメントを持たずに呼ばれます。もちろん、(対象と
する)関数が 1 つ以上のアーギュメントを必要とする場合、エラーになります。 

arg-descriptors がストリングでない場合、それは、評価によって (対象とする) 
関数に渡されるアーギュメントのリストが得られるフォームでなくてはいけませ
ん。 

arg-descriptor がストリングの場合、このストリングは (そのコード文字が必
要とする場合) プロンプトを後に続けたコード文字で構成されてなくてはいけま
せん。プロンプトは、ストリングの終りかニューラインで終ります。ニューライ
ンの後 (次のアーギュメント用の) 2 番目のコード文字とプロンプトとを与える
ことができます(以下同様)。 

ストリングの最初の文字が * の場合、バッファがリードオンリーである場合エ
ラーを出し(訳注：signal)ます。この場合、(その)次の文字を最初のコード文字
として用います。 

コード文字の多くは、(その)アーギュメントが既存の何か (バッファ、関数、フ
ァイル名、等) の名前でなくてはいけないことを指示します。このような場合、 
(Emacs により)デフォルトのものが与えられるとともに、正しくない (訳注：条
件に合わない)名前は受け入れられなくなります (Emacs は `[No Match]' と文
句を言い、プロンプトを出し、再び名前を求めます)。 TAB, SPC, RET は、関数 
completing-read に従い名前の completion を行ないます。 

以下のテーブルにおいて、"completion" とマークされたコード文字は completion 
を行ないます。 "existing" とマークされたものは(既存の)名前を要求します。 
"default" とマークされたものはデフォルトを持ちます。 "prompt" はプロンプ
トを持たなくてはいけません。 

a 

  関数名(i.e., fboundp である(訳注：fboundp を満たす)シンボル)。
  existing, completion, prompt
  b
  バッファ名。existing, completion, prompt
  B
  バッファ名。completion, prompt
  c
  文字。prompt
  C
  コマンド名(i.e. インタラクティブ関数)。existing, completion,
  prompt
  d
  ポイントのポジションを数値として用います。No I/O
  D
  ディレクトリ名。existing, completion, default, prompt
  f
  関数名。existing, completion, default, prompt
  F
  関数名。existing, default, prompt
  k
  キーシーケンス。 (カレントなキーマップで) コマンドか undefined さ
  れたコマンドが見つかるまで文字を読み込み、そのキーシーケンスをスト
  リングとして関数に渡します。カーソルはエコーエリアに移動しません。
  prompt
  m
  (数値としての)マークのポジション。No I/O
  n
  数値。数値を必要とします。prompt
  N
  未処理のプレフィックスアーギュメントを関数に渡します。プレフィック
  スアーギュメントが nil の場合、 (n におけるように)数値を読み込みま
  す。数値を必要とします。prompt
  p (小文字のp)
  処理されたプレフィックスアーギュメントを関数に渡します。No I/O
  P (大文字のP)
  未処理のプレフィックスアーギュメントを関数に渡します。No I/O
  r
  ポイントとマークを、関数に対する 2つの(数値の) アーギュメントとし
  て(小さい方を先にして)渡します。 No I/O
  s
  ストリングを読み込み、LFD か RET でターミネートします。このどちら
  も(訳注：LFD も RETも) C-q を用いることでストリングに含めることは
  できます。 prompt
  S
  ストリングを読み込み、空白(訳注：whitespace) 文字のどれかでターミ
  ネートします。読み込まれたものは、シンボルとして intern されます。
  C-q を用いることで空白文字をストリングに含めることはできます。通常
  シンボルをターミネートする文字(e.g., ()[])は (訳注：ここではこのス
  トリングを)ターミネートしません。 prompt
  v
  ユーザーオプションとして宣言された変数(i.e., user-variable-p)。
  existing, completion, prompt
  x
  Lisp フォームを読み込み、LFD か RET でターミネートします。
  読み込まれるストリングが閉じのダブルクォートをタイプする前にターミ
  ネートされた場合、閉じのダブルクォートを追加します。リストやベクト
  ルを読み込んでいて、最後の閉じの ) や ] の前にターミネートされた場
  合、エラーを出します。 (訳注：読み込んだ)フォームは評価しません。
  prompt
  X
  (x におけるように)フォームを読み込んだ後、評価し、その結果を関数に
  渡します。 prompt
  (defun foo1 ()                    ;foo1 はアーギュメントを取らず、
      (interactive)                 ;2 word 先に移動させるだけ。
      (forward-word 2))
  =&gt; foo1
  (defun foo2 (n)                   ;foo2 はアーギュメントを 1つ取り、
      (interactive "p")             ;それは 処理されたプレフィックスである。
      (forward-word (* 2 n)))
  =&gt; foo2
  (defun foo3 (n)                 ;foo3 はアーギュメントを 1つ取り、
      (interactive "nCount:")     ;それは ミニバッファから読み込まれる。
      (forward-word (* 2 n)))
  =&gt; foo3
  (defun three-b (b1 b2 b3)
    "Select three existing buffer (prompting for them in the Minibuffer)
  Put them into three windows, selecting the last one."
      (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
      (delete-other-windows)
      (split-window (selected-window) 8)
      (switch-to-buffer b1)
      (other-window 1)
      (split-window (selected-window) 8)
      (switch-to-buffer b2)
      (other-window 1)
      (switch-to-buffer b3)
    )
  =&gt; three-b
  (three-b "*scratch*" "declarations.texinfo" "*mail*")
  =&gt; nil

  参照 commandp
=================
以下、花井 達さん作

===制御文字リスト 凡例===

(書式)
制御文字 {属性}[最終変換値]     入力値

{属性}
 E: Existing     存在するモノを入力しない限り終わらない
 C: Completion   入力候補表示・補完あり
 P: Prompt       ミニバッファでユーザー入力
 D: Dialog       ダイアログ表示することも

[最終変換値]
{xx}    - 関数には xxx 型の値がくる
{xx/yy} - 入力値が省略又は未定義値だと、yy型がくる。
{xx|yy} - 入力値が多重値だと、yy の型でくる
{*****} - なんでもあり

===制御文字リスト===
a       {ECP }[symbol]          関数名。
b       {ECP }[buffer]          バッファ名。
B       { CP }[buffer/string]   バッファ名。
c       {  P }[character]       キー入力キャラクタ。
C       {ECP }[symbol]          インタラクティブコマンド。
d       {    }[integer]         選択バッファ上での位置。
D       {ECPD}[string]          ディレクトリ。
e       { CP }[string]          実行可能ファイル。
f       { CPD}[string]          ファイル。
F       { CP }[string]          ファイル。
k       {  P }[character|cons]  キーシーケンス。
l       {ECPD}[string|cons]     ファイル。複数可。
m       {    }[integer]         マーク。
M       {    }[integer]         選択開始位置。
n       {  P }[integer/nil]     数値。
N       {  P }[integer/nil]     数値。前置引数(c-u)を優先採用。
p       {    }[integer]         前置引数による数値。
P       {    }[integer/nil]     前置引数による数値。
r       {    }[integer]         リージョン。マークが先に来る。
R       {    }[integer]         選択範囲。開始位置が先に来る。
s       {  P }[string]          文字列。
S       { CP }[symbol]          シンボル。
v       {ECP }[symbol]          変数。
x       {  P }[*****]           lisp式。
X       {  P }[*****]           lisp式。関数には評価後の値が渡る

AgGhHiIjJKoOqQtTuUVwWyYzZ       いまのところ使えない

===その他===
*       interactive 文字列の先頭がこれになってるときは、
        選択バッファが ReadOnly だとエラーにしちゃう。
          (interactive "*fFiles : ")   ;;; こんな感じ
\n      複数の制御文字を使う場合、これで区切る
          (interactive "*fFiles : \np")::: こんな感じ
0       各制御文字の前に置いておくと、プロンプトに
        前置引数(C-u)が挿入されて表示される。
          (interactive "0fFiles : ")   ::: こんな感じ
1-9     各制御文字の前に置けるけど、とりあえず意味無し。
</description>
<section>関数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>commandp</title>
<type>Function</type>
<arguments>object</arguments>
<package>editor</package>
<description>
関数がinteractive宣言されていれば tを返し、そうでなければnilを返します。
</description>
<section>関数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-char</title>
<type>Function</type>
<arguments>point</arguments>
<package>editor</package>
<description>
指定された位置にカーソルを移動します。この位置はpoint, point-min, 
point-max等のポイントを返す関数を使用することで得ることが可能です。

--- muleの説明 ---
この関数は、カレントバッファのポイントを(カレントバッファの) position に
設定します。 position が 1 以下の場合、ポイントをバッファの先頭に設定し
ます。バッファの長さ以上の場合、ポイントをバッファの終端に設定します。 

clipping 制限が用いられた場合も、この position は(以前として)そのバッフ
ァの先頭から計られますが、 clipped 領域の外に示された position は clipped 
領域の先頭か終端の位置となります。 

インタラクティブに呼ばれた場合、(それが与えれている場合) position はプレ
フィックスアーギュメントになり、(与えられてない場合) ミニバッファから読
み込みます。 
goto-char は position を返します。 
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-line</title>
<type>Function</type>
<arguments>line</arguments>
<package>editor</package>
<description>
指定された行番号にジャンプします。折り返しを有効にしていて表示行にジャン
プしたい場合には、goto-virtual-lineを使用します。

この関数は、(バッファの先頭を 1 行目と数え) line 行目の行の先頭にポイン
トを設定します。 line が 1 より小さい場合、ポイントをバッファの先頭に置
きます。バッファ中の行数より大きい場合、バッファ最後の行の終りに設定しま
す。 

clipping 制限が用いられた場合、 line は(まだ)そのバッファの先頭から数え
ますが、clipped 領域の外に line が指定されると、ポイントは clipped 領域
の先頭か終りに位置付けられることになります。 

インタラクティブに呼ばれた場合、(与えられている場合) line は数値のプレフ
ィックスアーギュメントになります。そうでない場合、 line をミニバッファか
ら読み込みます。 
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-column</title>
<type>Function</type>
<arguments>COL</arguments>
<package>editor</package>
<description>
指定された桁位置に移動します。移動した後の桁位置を返します。
current-line-columnsが返す値よりも大きな値を指定した場合には、行の終端に
位置します。負の数を指定した場合には、行の先頭に位置します。

  COL : 桁数
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>forward-char</title>
<type>Function</type>
<arguments>&amp;optional (count 1)</arguments>
<package>editor</package>
<description>
指定された文字数だけ右に移動します。改行があれば次行に移動します。

この関数は、ポイントを右に count 文字動かします(count が負の場合、左に動
かします)。バッファ(もしくは clipped 領域)の先頭や終端を越えてしまう場合、 
beginning-of-buffer か end-of-buffer エラーを出します。 

インタラクティブに呼ばれた場合、 count は数値のプレフィックスアーギュメ
ントになります。 

互換性： 
  Emacsではバッファの先頭ではエラーが発生します。xyzzyではエラーは発生し
  ません。その代わり、動けたときは t、動けなければ nil を返します。
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>backward-char</title>
<type>Function</type>
<arguments>&amp;optional (n 1)</arguments>
<package>editor</package>
<description>
指定された文字数だけ後方に移動します。行頭ならば前行の終端に位置します。

互換性：
   Emacsではバッファの先頭ではエラーが発生します。xyzzyではエラーは発生
  しません。その代わり、動けたときは t、動けなければ nil を返します。
</description>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>goto-bol</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
行頭に移動します。

互換性：
  xyzzyオリジナルのようです。
  効率がいいのでこれを使うのが推奨されているみたい。
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-eol</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
行末に移動します。

互換性：
  xyzzyオリジナルのようです。
  効率がいいのでこれを使うのが推奨されているみたい。
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>bolp</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
カーソルが行頭にあればt、そうでなければnilを返します。
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-region</title>
<type>Function</type>
<arguments>from to</arguments>
<package>editor</package>
<description>
指定された範囲を削除します。
</description>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert</title>
<type>Function</type>
<arguments>insert &amp;rest STRING-OR-CHAR</arguments>
<package>editor</package>
<description>
文字列をバッファに挿入します。

  STRING-OR-CHAR : 挿入する文字列を指定します。
                   &amp;restで受けられているので何個でもOKです。

履歴：
  xyzzyのバージョン0.0.0.45.1よりまえのバージョンでは
  Emacsとinsertの仕様が、やや異なっていました。

  ;;; Emacsの場合
  (insert "abc" "def" "ghi")
  =&gt; "abcdefghi"が挿入される

  ;;; xyzzyの場合
  (insert "ab" 4)
  =&gt; "abababab"が挿入される

  xyzzyのバージョン0.0.0.45.1以降、Emacsとのinsert互換性が高まって
  います。

  (insert "foo")         =&gt; foo          ; 今までと同じ
  (insert "foo" 2)       =&gt; foofoo       ; 今までと同じ
  (insert "foo" "bar")   =&gt; foobar       ; Emacsと同じ
  (insert "foo" "bar" 2) =&gt; foobarfoobar
  (insert #\f "o" #\o)   =&gt; foo          ; Emacsと同じ
  (insert #\f "o" #\o 2) =&gt; foofoo
  (insert 2)             =&gt; エラー
  (insert "foo" 2 "bar") =&gt; エラー
  (insert 102 111 111)   =&gt; エラー       ; Emacsは  =&gt; foo
</description>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-substring</title>
<type>Function</type>
<arguments>from to</arguments>
<package>editor</package>
<description>
バッファの指定された範囲の文字列を返します。
</description>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-mode</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
カレントバッファのモードを格納しています。

使用例：
  ;;; list-interaction-modeの場合
  buffer-mode
  =&gt; lisp-interaction-mode
</description>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>make-backup-files</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
バックアップファイルを作るかどうかを指定する変数です。

  t   : バックアップファイルを作る
  nil : バックアップファイルを作らない

使用例：
  ;;; 現在開いているファイルをバックアップとらないようにする。
  (make-local-variable 'make-backup-files)
  =&gt; t
  (setq make-backup-files nil)
  =&gt; nil
</description>
<section>バッファ</section>
</chapter>

<chapter>
<title>lock-file</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
ロックファイルを作るかどうかを指定する変数です。

  t   : ロックファイルを作る。
  nil : ロックファイルを作らない。

使用例：
  ;;; 現在開いているファイルではロックファイルを作らないようにする。
  (make-local-variable 'lock-file)
  =&gt; t
  (setq lock-file nil)
  =&gt; nil 
</description>
<section>バッファ</section>
</chapter>

<chapter>
<title>kept-undo-information</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
undoできるようにするかどうかを指定する変数です。

  t   : undoできるようにする。
  nil : undoするための情報を保持しません。

使用例：
  ;;; 現在開いているファイルではundoできないようにします。
  (make-local-variable 'kept-undo-information)
  =&gt; t
  (setq kept-undo-information nil)
  =&gt; nil
</description>
<section>バッファ</section>
</chapter>

<chapter>
<title>mode-line-format</title>
<type>BufferLocal</type>
<arguments></arguments>
<package>editor</package>
<description>
モードラインのフォーマットを設定します。
タイトルバーのフォーマットと同様ですので、title-bar-formatを参照して下さい。
</description>
<seealso>title-bar-format</seealso>
<section>ウィンドウ</section>
</chapter>

<chapter>
<title>*default-buffer-mode*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
新しくバッファを作成した場合のモードを指定します。
例えば、lisp-modeを指定しておけば、新しく作成したバッファは全てlisp-mode
になります。

使用例：  
  (setq *default-buffer-mode* 'lisp-mode)
  =&gt; lisp-mode
  (switch-to-buffer "*new*")
  =&gt; #&lt;buffer: *new*&gt;
  buffer-mode
  =&gt; lisp-mode
</description>
<section>バッファ</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>set-buffer</title>
<type>Function</type>
<arguments>buffer</arguments>
<package>editor</package>
<description>
バッファを選択します。

--- muleの説明 ---
この関数は、 buffer をカレントバッファにしますが、このバッファを今 
select されているウィンドウに表示することはしません。これは(Emacs が)コ
マンドレベルに戻ると(すぐに) select されているウィンドウのバッファが(再
び)カレントになることを意味しています。 

この関数は、(カレントバッファ以外のバッファでエディットを行なう)コマンド
を書く際に用いられます。 buffer で示されるバッファを返します。 

buffer が(既存の)バッファを指さない場合、エラーになります。 
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-modified-p</title>
<type>Function</type>
<arguments>FLAG &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファが変更されたかどうかのフラグを設定します。

  FLAG   : フラグを指定します。
        t       変更されている状態にします。
        nil     変更が存在しない状態にします。
  BUFFER : 対象のバッファ

使用例： 
  ;;; 変更フラグの設定・クリア
  (set-buffer-modified-p t)
  (set-buffer-modified-p nil)
</description>
<seealso>buffer-modified-p</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-colors</title>
<type>Function</type>
<arguments>COLORS &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの色を設定します。設定した色は現状のバッファにだけ適用されます。

  COLORS : BGRを表す数値をベクタで指定します。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-file-name</title>
<type>Function</type>
<arguments>FILE-NAME &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファと結び付けられているファイルをFILE-NAMEにします。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-fileio-encoding</title>
<type>Function</type>
<arguments>CODE &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの漢字コードをCODEにします。設定した漢字コードは
buffer-fileio-encodingで参照することができます。

  CODE   : 漢字コードを指定します。
  BUFFER : 変更するバッファを指定します。

使用例：
  (set-buffer-fileio-encoding *encoding-sjis*)
  (set-buffer-fileio-encoding *encoding-euc-jp*)
  (set-buffer-fileio-encoding *encoding-jis*)
  (set-buffer-fileio-encoding *encoding-utf8*)

参照：
  kanji.l
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-fileio-encoding</title>
<type>Function</type>
<arguments>&amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファの漢字コードを返します。変更する場合には、
set-buffer-fileio-encodingを使用します。

使用例：
  (buffer-fileio-encoding)
  =&gt; #.(make-iso2022-encoding "jis" ... )

参照：
  kanji.l
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-can-redo-p</title>
<type>Function</type>
<arguments>buffer</arguments>
<package>editor</package>
<description>
バッファがredo可能な状態ならt、そうでなければnilを返します。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-can-undo-p</title>
<type>Function</type>
<arguments>buffer</arguments>
<package>editor</package>
<description>
bufferがundo可能ならt、そうでなければnilを返します。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-list</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
全バッファをリストで返します。

--- muleの説明 ---
この関数は、(全ての)バッファのリストを返します。 

  (buffer-list)
  =&gt; (#&lt;buffer buffers.texinfo) #&lt;buffer  *Minibuf-1*&gt;
      $&lt;buffer buffers.c&gt; #&lt;buffer *Help*&gt; #&lt;buffer TAGS&gt;)
  ;;ミニバッファの名前はスペースで始まる点に注意
  (mapcar (function buffer-name) (buffer-list))
  =&gt; ("buffers.texinfo" " *Munibuf-1" "buffer.c" "*Help*"
      "TAGS")
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>バッファの内部構造</title>
<type>Tips</type>
<arguments></arguments>
<description>
各々のバッファは、(プログラマが直接アクセスすることのできない) 変数の集合を
持っています。 (どのような形であれ)それらに与えられた名前をプログラマが用いる
ことはできませんが、それらの値をアクセスし変更を行なう関数がしばしば存在して
います。 (Emacs 18 において)それらは、

  name 
    バッファ名は、バッファを名指すストリングです。これは一意であることが保
    証されています。セクション 24.1 [buffer-name]、ページ 224 参照。

  save-modified 
    この変数は、バッファが(最後に)セーブされた時間を持ちます。xref??

  modtime 
    この変数は、visit されたファイルの modification time を持ちます。これ
    はそのファイルが書かれるか読まれるかした時に設定されます。バッファが
    ファイルに書かれるたびに、この変数は(その) ファイルの modification と
    比較されます。セクション 22.3 [verify-visited-file-modtime]、ページ
    204 参照

  auto-save-modified 
    この変数は、バッファが(最後に)オートセーブされた時間を持ちます。

  last-window-start 
    この変数は、(最後に)バッファがウィンドウに表示された際、その表示を開始
    したバッファ中のポジションを持ちます。

  undodata 
    この変数は、バッファに対し(最後に)行なわれたいくつかの(訳注：set of)変
    更を undo するための方法を、(Emacs に)示す記録を持ちます。セクション
    24.8 [undo]、ページ 233 参照。

  syntax_table_v 
    この変数は、バッファに対するシンタックステーブルを持ちます。セクション
    37.3 [シンタックステーブル]、ページ 354 参照。

  markers 
    この変数は、バッファの中を指す(全ての)マーカーのリストを持ちます。バッ
    ファの内容を変更する際は、これらのマーカーは(常に) アップデートされな
    くてはいけません。チャプター 28 [マーカー]、ページ 267

  backup_up 
    この変数は、 visit されたファイルがバックアップされているか否かを示す
    フラグです。

  mark 
    この変数は、バッファに対するマークを持ちます。マークはマーカーですか
    ら、マークはリスト markers にも含まれます。

  local_var_alist 
    この変数は、ローカル変数(の全て)とそれに対応する値とを含む association
    リストを持ちます。関数 buffer-local-variables は、このリストのコピーを
    返します。

--- 追加分 ---
  mode-line-format 
    モードラインのフォーマットです。

  title-bar-format
    タイトルバーのフォーマットです。
</description>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>buffer-local-value</title>
<type>Function</type>
<arguments>BUFFER SYMBOL</arguments>
<package>editor</package>
<description>
指定されたバッファのローカル変数の値を返します。

  BUFFER : ローカルな値を取得したいバッファ
  SYMBOL : ローカル変数

使用例：
  (buffer-local-value (selected-buffer) 'mode-name)
  =&gt; "xmldoc"
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-menu</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファ一覧を表示します。
一覧の中ではバッファの選択、削除などができます。
</description>
<section>バッファ</section>
<file>buf-menu.l</file>
</chapter>

<chapter>
<title>buffer-modified-p</title>
<type>Function</type>
<arguments>&amp;optional buffer</arguments>
<package>editor</package>
<description>
バッファが変更を加えられているかどうかを返します。

  t   : バッファは変更されている。
  nil : バッファは変更されていない。

--- muleの説明 ---
この関数は、このバッファが最後にファイルから読み込まれたかセーブされた後、
変更が行なわれている場合 t を返します。そうでない場合 nil を返します。 
buffer が与えられない場合、カレントバッファを調べます。 (これはここにあ
るべできはない!!) 
</description>
<seealso>set-buffer-modified-p</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-process</title>
<type>Function</type>
<arguments>buffer</arguments>
<package>editor</package>
<description>
バッファに結び付けられているプロセスを返します。
プロセスはmake-processで作成します。
</description>
<seealso>make-process</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-selector</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファ選択ウィンドウを表示します。
バッファ選択されればそのバッファを、そうでなければnilを返します。
</description>
<seealso>select-buffer</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-size</title>
<type>Function</type>
<arguments>&amp;optional buffer</arguments>
<package>editor</package>
<description>
バッファのサイズを返します。2バイト文字があるので buffer-size の返す値とファイルサイズは一致しません。

使用例：
  (buffer-size)
  =&gt; 200170
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>bufferp</title>
<type>Function</type>
<arguments>OBJECT</arguments>
<package>editor</package>
<description>
OBJECTがバッファならばt、そうでないならnilを返します。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>bury-buffer</title>
<type>Function</type>
<arguments>&amp;optional buffer-name</arguments>
<package>editor</package>
<description>
（詳細不明）
--- muleの説明 ---
この関数は、リスト上の他のバッファの順を変更することなく、バッファリスト
の終りに buffer-name を置きます。それは、other-buffer が(最も)返さないバ
ッファになります。 buffer-name が与えられない場合、デフォルトはカレント
バッファになります。 

buffer-name がカレントバッファの場合、それが selected ウィンドウで表示さ
れている場合、 other-buffer で選択されるバッファで置き換えます。 selected 
ウィンドウ以外のウィンドウで表示されている場合、それはそのままにします。 

インタラクティブに呼ばれた場合、 buffer-name はデフォルトでカレントバッ
ファになります。 
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rename-buffer</title>
<type>Function</type>
<arguments>buffer-name &amp;optional buffer</arguments>
<package>editor</package>
<description>
ファイル名は変えずにバッファ名だけを変更します。

--- muleの説明 ---
この関数は、カレントバッファを buffer-name にリネームします。 

buffer-name がストリングでなかったりその名前のバッファがすでに存在している場
合、エラーになります。 nil を返します。 
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>rename</title>
<type>Function</type>
<arguments>filename &amp;optional nowarn</arguments>
<package>editor</package>
<description>
バッファに関連づけられたファイル名を変更します。バッファ名も同時に変更されます。
変更に成功したらnil以外の値を、失敗したらnilを返します。

使用例：
  ;;; カレントバッファのファイル名が"c:/foo.baz"に変更されます。
  ;;; 同時に、バッファ名も"foo.baz"になります。
  (rename "c:/foo.baz")
</description>
<seealso>rename-buffer</seealso>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>scan-buffer</title>
<type>Function</type>
<arguments>pattern &amp;key :no-dup :case-fold :reverse :tail :regexp :left-bound :right-bound</arguments>
<package>editor</package>
<description>
バッファを検索します。
  
  :no-dup        non-nilならポイントの次の文字から探し始める
  :case-fold     non-nilなら大文字小文字を区別しない
  :reverse       non-nilならポイントからバッファの先頭に向かって
  :word-search   non-nilなら単語単位で
  :tail          barをサーチしたとき、:tailがnilなら
                    foo bar baz qux quux ...
                        ^ ポイントはここに移動する
                 :tailがnon-nilなら
                    foo bar baz qux quux ...
                           ^ ポイントはここに移動する
  :limit N       文字数では*なく*、ポイント位置の制限
                 n文字探す場合は N = (+ (point) n)
  :regexp        non-nilなら正規表現
                 ただし、patternがregexp型なら:regexpの値は無視

使用例：
  (scan-buffer  検索文字列 :regexp t) 
  (scan-buffer 検索文字列 :tail t) 
  (scan-buffer 検索文字列 :limit 3000)
  (scan-buffer 検索文字列 :reverse t)
  (scan-buffer  検索文字列 :regexp t :no-dup t)

検索文字列には、コンパイルした正規表現を渡すこともできます。多少スピード
アップが期待できるようです。この際はscan-bufferの引数の:case-foldは無視
され、compile-regexpの第２引数の指定が使われます。
</description>
<seealso>compile-regexp</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>match-beginning</title>
<type>Function</type>
<arguments>REGNUM</arguments>
<package>editor</package>
<description>
正規表現を使った検索後に一致した先頭のポイントを取得できます。

  REGNUM : 取得したい文字列を指定
        0の場合         正規表現全体に一致する文字列を取得
        1-9の場合       正規表現中のREGNUM番目の括弧に対応した文字列を取得
</description>
<seealso>match-end</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>match-end</title>
<type>Function</type>
<arguments>REGNUM</arguments>
<package>editor</package>
<description>
正規表現を使った検索後に一致した最後のポイントを取得できます。

  REGNUM : 取得したい文字列を指定
        0の場合         正規表現全体に一致する文字列を取得
        1-9の場合       正規表現中のREGNUM番目の括弧に対応した文字列を取得
</description>
<seealso>match-beginning</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>looking-for</title>
<type>Function</type>
<arguments>string &amp;optional case-fold</arguments>
<package>editor</package>
<description>
現在のカーソル位置から前方向にマッチしたらt、しなかったらnilを返します。
後方向にマッチしたければlooking-backを、正規表現でマッチしたければ
looking-atを使用します。

使用例：
  (looking-for "^")
  (looking-for "define")
  (looking-for "::")
</description>
<seealso>looking-at</seealso>
<seealso>looking-back</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>looking-back</title>
<type>Function</type>
<arguments>string &amp;optional case-fold</arguments>
<package>editor</package>
<description>
現在のカーソル位置から後方向にマッチしたらt、しなかったらnilを返します。

使用例：
  (looking-back "::")
  (looking-back "\\")
  (looking-back "#'")
</description>
<seealso>looking-for</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>looking-at</title>
<type>Function</type>
<arguments>regexp &amp;optional case-fold</arguments>
<package>editor</package>
<description>
現在のカーソル位置で前方向に正規表現でマッチしたらt、しなかったらnilを返します。

使用例：
  ;;; 行頭が(とマッチするか?
  (defun rrr ()
    (interactive)
    (if (looking-at "^(")
      (message "ok") (message "bad")))

  ;;; 空白やタブや全角スペースがあれば削除する
  (if (looking-at "[ \t　]*")
      (delete-region (match-beginning 0) (match-end 0)))
</description>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>正規表現の表記</title>
<type>Tips</type>
<arguments></arguments>
<description>
正規表現の表記方法です。以下は 
  Toy's xyzzy memo - Data Library -
  http://www.carabiner-systems.com/xyzzy/data.html)
からの引用です。

--- 引用 ---
正規表現
regular expression 1999/12/29　Written by Tetsuya Kamei [xyzzy:03768] 

  ^         行頭にマッチ
  $         行末にマッチ
  .         改行文字を除く任意の 1 文字にマッチ
  [...]     文字クラスのどれか 1 文字にマッチ
  [^...]    文字クラスの補集合のどれか 1 文字にマッチ
  *         直前の正規表現の 0 回以上の繰り返しにマッチ (={0,})
  +         直前の正規表現の 1 回以上の繰り返しにマッチ (={1,})
  ?         直前の正規表現の 0 回か 1 回の繰り返しにマッチ (={0,1})
  \{M,N\}   直前の正規表現の M 回以上 N 回以下の繰り返しにマッチ
  \{M,\}    直前の正規表現の M 回以上の繰り返しにマッチ
  \{,N\}    直前の正規表現の N 回以下の繰り返しにマッチ
  \{N\}     直前の正規表現の N 回の繰り返しにマッチ
  \( \)     グルーピング
  \|        選択
  \1 ～ \9  後方参照
  \&lt;        単語の開始にマッチ
  \&gt;        単語の終了にマッチ
  \b        単語の境界にマッチ
  \B        単語の境界以外にマッチ
  \w        英数字にマッチ
  \W        英数字以外にマッチ
  \sc       シンタックスが c の 1 文字にマッチ
  \Sc       シンタックスが c 以外の 1 文字にマッチ
  \`        バッファの先頭にマッチ
  \'        バッファの最後にマッチ
  \         メタキャラクタのエスケープ

  [たぶん xyzzy 0.2.1.186 から]
  *?        直前の正規表現の 0 回以上の最短の繰り返しにマッチ
  +?        直前の正規表現の 1 回以上の最短の繰り返しにマッチ
  ??        直前の正規表現の 0 回か 1 回の最短の繰り返しにマッチ

            (let ((str "aAaaa"))
              (string-match "Aa?" str)
              (format t "[Aa? ] ... ~S: ~D-~D~%"
                      (match-string 0) (match-beginning 0) (match-end 0))
              (string-match "Aa??" str)
              (format t "[Aa??] ... ~S: ~D-~D~%"
                      (match-string 0) (match-beginning 0) (match-end 0)))
            -&gt;[Aa? ] ... "Aa": 1-3
              [Aa??] ... "A": 1-2

  \{M,N\}?  直前の正規表現の M 回以上 N 回以下の最短の繰り返しにマッチ
  \{M,\}?   直前の正規表現の M 回以上の最短の繰り返しにマッチ
  \{,N\}?   直前の正規表現の N 回以下の最短の繰り返しにマッチ
  \(?:regexp\)
            部分正規表現のグルーピングを行うが，後方参照を行わない
            (すなわち\1，\2とかを使って参照できない，と)

  [さらに xyzzy 0.2.2.202 から]
  \_&lt;       シンボルの開始位置にマッチ 
  \_&gt;       シンボルの終了位置にマッチ 
  \_b       シンボルの境界にマッチ 
  \_B       シンボルの境界以外にマッチ 
  \_s       シンボル文字にマッチ 
  \_S       シンボル文字以外にマッチ 
</description>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>Emacs 互換ではない正規表現は結構あるのでしょうか？</title>
<type>Tips</type>
<arguments></arguments>
<description>
\'  \`  \=  \c  \C これだけです。
</description>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>perform-replace</title>
<type>Function</type>
<arguments>pattern replacement query regexp interactive-p noerror</arguments>
<package>editor</package>
<description>
バッファを検索して文字列を置換します。特に判断がいらないのならば
scan-bufferするよりも簡単です。replace-bufferを使って実装されています。
  
  pattern       : 置換前文字列です。
  replacement   : 置換後文字列です。\1, \2 ... \9も使用できます。
  query         : 確認あり？
  regexp        : 正規表現？
  interactive-p : 対話的かどうか？
                  undoの記録の仕方と、メッセージの出し方が違うだけ
  noerror       : 文字列が見つからないときエラーを出す？

互換性：
  muleにはなさそう。
</description>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>replace-string</title>
<type>Function</type>
<arguments>pattern replacement &amp;optional noerror</arguments>
<package>editor</package>
<description>
バッファを検索して文字列で置換します。perform-replaceを使って実装されて
います。

  pattern     : 置換前文字列です。
  replacement : 置換後文字列です。
  noerror     : 文字列が見つからないときにエラーを出す？

replace系の関数の系譜：
  replace-string         ：interactiveな関数として宣言されている。
    └perform-replace    ：普通はこれで十分の筈
        └replace-buffer ：いろいろと細かく設定したければこれで行う。

使用例：
  (defun test-proc ()
    (interactive)
    (replace-string "aaa" "xxx"))   ;; aaaをxxxに置換

--- muleの説明 ---
Command: replace-string string replacement &amp;optional delimited

この関数は、 string の出現部分(訳注：occurrences)を replacement で置き換えます。 
</description>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>replace-match</title>
<type>Function</type>
<arguments>STRING &amp;key LITERAL</arguments>
<package>editor</package>
<description>
直前の検索結果に基づいて、STRINGにあるメタ文字を解釈しつつ文字列を置き換
えます。LITERALがnil以外の場合は、メタ文字を意識しません。

メタ文字：
   \0, \&amp;    一致した文字列全体
   \1 ～ \9  正規表現検索での\(\)に対応する文字列

使用例：
  ;;; &lt;!--文字列--&gt;を[文字列]に置き換える場合
  (when (scan-buffer "&lt;!--\\(.+\\)--&gt;" :regexp t)
    (replace-match "[\\1]"))
  =&gt; t
</description>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>replace-buffer</title>
<type>Function</type>
<arguments>pattern replacement :case-fold :tail :regexp :left-bound :right-bound :once :literal</arguments>
<package>editor</package>
<description>
バッファ中の文字列を検索して置換します。replace-stringもperform-replace
もこれを使って実装されています。

使用例：
 ;;;  英字と漢字の間に空白を１つあける
 (replace-buffer "\\([A-Za-z0-9_]\\) *\\([\X8200-\X9fff\Xe000-\Xfcff]\\)"
    "\\1 \\2" :regexp t)
</description>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>count-windows</title>
<type>Function</type>
<arguments>&amp;optional MINIBUF</arguments>
<package>editor</package>
<description>
ウィンドウの数を返します。

  MINIBUF : フラグはミニバッファウィンドウを数えるかどうかです。
        t       ミニバッファを数える。
        nil     ミニバッファを数えない。
</description>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>pop-to-buffer</title>
<type>Function</type>
<arguments>buffer &amp;optional popup-windows</arguments>
<package>editor</package>
<description>
指定されたバッファを表示します。POPUP-WINDOWS が指定された場合画面を分割
してバッファを表示します。ウィンドウが既に分割されていたら、新たに分割せ
ずにそのウィンドウに移動し表示します。

表示幅が指定された場合には、縦分割が指定されていない場合、モード行を表示
している状態で、およそ指定された数値分の行数が表示できる大きさのウィンド
ウができます。
縦分割が指定された場合には、上下ではなく左右に分割し、行番号を表示してい
ない状態で、およそ指定された数値分の列数が表示できる大きさのウインドウが
できます。

  BUFFER        : バッファ、または、バッファの名前を指定します。
  POPUP-WINDOWS : 分割する行数／列数を指定します。
        t             ニ分割します。
        整数          指定行数／列数で分割します。
        nil           ウィンドウが分割されていない場合でも新たに
                      分割しません。
  VERT-P        : 縦方向に分割します。
        non-nil       左右にニ分割します。
        nil           上下にニ分割します。

使用例：
  ;;; den8の場合
  (defvar *den8-summary-window-ratio* 1/4)

  (defun den8-viewer ()
    (let ((view (switch-to-buffer "*Den8 View*")))     ; Viewを作る
      (let ((sum (switch-to-buffer "*Den8 Summary*"))) ; Summaryを作る
           &lt;初期化・省略&gt; ))
    (delete-other-windows)        ; 自分以外の全部のウインドウを消す
    (den8-popup-summary-buffer))  ; ２分割して、上下にサマリと内容を表示

  (defun den8-popup-summary-buffer ()
    (pop-to-buffer den8-summary-buffer
       (truncate (* (screen-height) *den8-summary-window-ratio*))))
</description>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>substring</title>
<type>Function</type>
<arguments>string start &amp;optional end</arguments>
<package>lisp</package>
<description>
指定された文字列の部分文字列を返します。

--- muleの説明 ---
この関数は、 string 中の start の文字から始め end の文字で終るストリング
を (新しく)返します。負の数字は、(ストリングの最後の文字を -1 として) ス
トリングの終りから数えます。 

start と end のどちらかが integer でなかったり、 start が end の後の文字
を指していたり、どちらかの integer がストリングの範囲を出てしまっている
場合、エラーになります。 

  (substring "abcdefg" 0)
  =&gt; "abcdefg"
  (substring "abcdefg" 0 2)
  =&gt; "ab"
  (substring "abcdefg" 5 nil)
  =&gt; "fg"
  (substring "abcdefg" -1 nil)
  =&gt; "g"

互換性：
  Common Lispにはなし(commonではsubseqというらしい）
  muleあり。
</description>
<section>文字列</section>
<file></file>
</chapter>

<chapter>
<title>string-match</title>
<type>Function</type>
<arguments>regexp string &amp;optional start end</arguments>
<package>editor</package>
<description>
指定された文字列が正規表現に一致するかどうかを返します。

  REGEXP : 正規表現
  STRING : チェックする文字列
  START  : 文字列の開始位置
  END    : 文字列の終了位置

--- muleの説明 ---
この関数は、(string 中で)正規表現 regexp に最初にマッチする場所のインデ
ックスか、 (マッチしない場合) nil を返します。 start が non-nil の場合、
サーチは string 中のそのインデックスから行ないます。 

マッチ部分の先の(最初の)文字のインデックスは (match-end 0) で作られます。 
0 でないアーギュメントを持つ match-end と match-beginning はパターン中の
括弧構成(訳注：parenthesis constructs) にマッチするサブストリングのイン
デックスを与えます。 

  (string-match "X[a-z]*Y" "X1 Y Xab cY XabcY")
  =&gt; 12
  (match-end 0)
  =&gt; 17

互換性：
  muleあり。
  Common Lispなし。
</description>
<seealso>string-matchp</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>recenter</title>
<type>Function</type>
<arguments>&amp;optional arg</arguments>
<package>editor</package>
<description>
バッファをスクロールして画面上の表示位置を調整します。
引数を指定しなければ現在行が画面の中央に位置します。
(recenter 0)で現在行がウインドウの一番上に来ます。
</description>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>window-buffer</title>
<type>Function</type>
<arguments>window</arguments>
<package>editor</package>
<description>
ウィンドウが表示しているバッファを返します。
  
使用例：
  (window-buffer (selected-window))
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>window-lines</title>
<type>Function</type>
<arguments>&amp;optional window</arguments>
<package>editor</package>
<description>
ウィンドウの表示行数を返します。

使用例：
  (window-lines)
  =&gt; 18
</description>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>split-window</title>
<type>Function</type>
<arguments>&amp;optional ARG VERTICAL</arguments>
<package>editor</package>
<description>
画面を二分割します。分割行数と分割方向を指定可能です。

  ARG      : 分割する行数を指定します。
  VERTICAL : 縦方向に分割します。
        t       横に二分割します。
        nil     縦に二分割します。

分割後にカレントになるウィンドウには注意が必要です。

  (split-window 20 t)
  =&gt; +20-+---------+    
     |   |         |
     +↑-+---------+
      こちらにカーソルがくる
 
  (split-window -20 t)
  =&gt; +---------+20-+
     |         |   |
     +---------+↑-+
                こちらにカーソルがくる

  (split-window 20 nil)
  =&gt; +-------------+    
     |             ←こちらにカーソルがくる
     +-------------+    
     +-------------+    
      
  (split-window -20 nil)
  =&gt; +-------------+    
     +-------------+    
     |             ←こちらにカーソルがくる
     +-------------+          
</description>
<seealso>split-window-vertically</seealso>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>split-window-vertically</title>
<type>Function</type>
<arguments>&amp;optional arg</arguments>
<package>editor</package>
<description>
多分、split-windowの横に二分割するのと同じです。
</description>
<seealso>split-window</seealso>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>narrow-to-region</title>
<type>Function</type>
<arguments>from to</arguments>
<package>editor</package>
<description>
指定した範囲以外を移動・編集できないようにします。[C-x n]
save-restrictionのブロックが終了するか、widenすると元に戻ります。
point-min, point-maxの値も変わります。

使用例：
  C-SPCでマークを付けて、どっかに移動して、C-x n(narrow-to-region)とする
  と、指定したリージョンの外には移動できなくなります。私は置換のときに置き
  換える範囲を制限したり、キーボードマクロの範囲を制限したりするのによく使
  います。あとは、Lispコードの中で特定の範囲だけいじるときなんかにも使いま
  す。
</description>
<seealso>hide-restricted-region</seealso>
<seealso>save-restriction</seealso>
<seealso>widen</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>widen</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
narrow-to-regionで制限された領域を元に戻します。
</description>
<seealso>narrow-to-region</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>provide</title>
<type>Function</type>
<arguments>module-name</arguments>
<package>lisp</package>
<description>
ある機能を持ったモジュールがロードされた事を示すためにファイルの先頭に書
いておく「おまじない」です。ここに書いたモジュール名が変数*modules*に登
録されます。

requireがモジュールのロードをする際にこの変数がチェックされてロード済だ
ったらもうロードしません。汎用的なモジュールを書く場合には使うようにしま
しょう。

互換性：
  Common Lispにはあり。
  muleにはなさそう。

使用例：
  ;;; lispmode.lより
  (provide "lispmode")
</description>
<seealso>require</seealso>
<section>パッケージ</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>require</title>
<type>Function</type>
<arguments>module-name &amp;optional pathname</arguments>
<package>lisp</package>
<description>
指定したモジュールを読み込みます。既に読込済みであれば何もしません。

--- 原文 ---
Description: the argument module-name, which can be a string or a symbol 
(in which case the print name of the symbol is used), should be the name 
of some Lisp subsystem, which may or may not be already in the Lisp image. 
require checks to see if it has been loaded by looking for it on the list 
which is the value of *modules*. The test is case-sensitive. If the module 
name is not on the *modules* list, require tries to load it into Lisp. 
If pathname is present as a single pathname or a list of pathnames, require 
loads those files in order. If the argument pathname is not present, 
require attempts to load the file named module-name (or the print name 
of module-name if it is a symbol). If the module is already present, 
require returns nil. It is an error if the files cannot be loaded for any 
reason. Note that module-name is typically a symbol and, since symbol 
print names rarely also name files, it is recommended that pathname be 
supplied. 

互換性：
  Common Lispにはあり。
  muleにはなさそう。

使用例：
  (require "foreign")
</description>
<seealso>provide</seealso>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>*package*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
実行中のパッケージを保持しています。
in-packageで別のパッケージに移ることができます。

使用例：
  *package*
  =&gt; #&lt;package: user&gt;
</description>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
</chapter>

<chapter>
<title>list-all-packages</title>
<type>Function</type>
<arguments></arguments>
<package>lisp</package>
<description>
xyzzy内に存在するパッケージ一覧をリストで返します。

使用例：
  (list-all-packages)
  =&gt;  (#&lt;package: win-user&gt; #&lt;package: winapi&gt; #&lt;package: 
     foreign&gt;  #&lt;package: lisp&gt; #&lt;package: system&gt; #&lt;package: 
     keyword&gt; #&lt;package: user&gt; #&lt;package: editor&gt;)
</description>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>find-package</title>
<type>Function</type>
<arguments>find-package NAME</arguments>
<package>lisp</package>
<description>
パッケージを名前で検索して、そのパッケージを返します。

  NAME : パッケージの名前

使用例：
  ;;; lispとsystemパッケージを取得してみる。
  (find-package "lisp")
  =&gt; #&lt;package: lisp&gt;
  (find-package "si")
  =&gt; #&lt;package: system&gt;

  ;;; "baz"という名のパッケージは存在しない
  (find-package "baz")
  =&gt; nil
</description>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>intern</title>
<type>Function</type>
<arguments>STRING &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
文字列からシンボルを作成します。作成したシンボルは指定されたパッケージに
internされます。make-symbolも文字列からシンボルを作り出しますが、パッケ
ージにinternされません。

  STRING  : 文字列
  PACKAGE : 作成したシンボルを登録するパッケージ

使用例：
  ;;; foobarというシンボルが*package*に登録される
  (intern "foobar")
  =&gt; foobar

  ;;; foobazというシンボルがlispパッケージに登録される。
  (intern "foobaz" (find-package "lisp"))
  =&gt; foobaz

--- 原文 ---
Description: Similar to find-symbol but creates a new symbol if a match 
is not found for string. The new symbol with print name string is created 
and is added to package. package becomes the home package of the new 
symbol, and the symbol is returned. The new symbol created is internal 
unless package is the keyword package in which case the symbol is external. 
The second value returned is as for find-symbol , except that nil indicates 
that a new symbol was created. read uses intern to convert symbol names 
into the symbols themselves.
</description>
<seealso>find-symbol</seealso>
<seealso>symbol-name</seealso>
<seealso>unintern</seealso>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>in-package</title>
<type>Macro</type>
<arguments>name</arguments>
<package>lisp</package>
<description>
どのパッケージで実行するかを変更します。変更した後に作られたシンボルは、
指定されたパッケージに登録されます。

使用例：
    ;;; これ以降新しく作られるシンボルは、"editor"パッケージに登録さ
    ;;; れるようになる。
    (in-package "editor")
</description>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>package.l</file>
</chapter>

<chapter>
<title>export</title>
<type>Function</type>
<arguments>symbols &amp;optional package</arguments>
<package>lisp</package>
<description>
シンボルをパッケージの外部から参照できるようにします。

引数で指定された シンボル（変数や関数）はパッケージからエクスポートされ、
別のパッケージから修飾子無しで参照できるようになります。ただし、修飾子無
しで参照するには、別のパッケージからもuse-packageもしておかないといけませ
ん。
                   use  ┌system──┐
                    ┌─┤          │
  ┌lisp───┐←─┘  └─────┘        ┌user───┐
  │          │←────────────┬─┤          │
  └─────┘←─┐  ┌editor──┐    │  └─────┘
                    └─┤          │←─┘
                        └─────┘

上の図はどのパッケージをuse-pakcageしているかを示しています。
パッケージがuseする他のパッケージはpackage-use-listを使って確認すること
ができます。userは、lispとeditorをuse-packageしています。

si:system-rootはsystemからexportされていますが、userがsystemを
use-packageしていないので修飾子が必要です。

  ;;; system-rootがsystemからexportされていることを確認する。
  (find-symbol "system-root" "system")
  =&gt; system:system-root
     :external

このためuserからsystem-rootを使用する場合には(si:system-root)という呼び
出し方になります。

--- 原文 ---
Description: Symbols should be a symbol or a list of symbols which are 
made external symbols of package. Symbols in the list that are already 
external are unaffected whilst those that are internal but not inherited 
become external. If a symbol in the list is inherited and thus internal, 
the symbol is first imported into package, as if by import, and the becomes 
external. By convention, a call to export is placed at the beginning of 
a file to advertise all the symbols that are intended for use by other 
programs. export returns t. package should be a package or the name or 
nickname of a package.

使用例：
    ;;; 引数で指定された aset, file-name-sans-versions, ...は
    ;;; エクスポートされ、別のパッケージから参照できるようになる。
    (export '(aset file-name-directory file-name-nondirectory
          file-name-sans-versions))
</description>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
</chapter>

<chapter>
<title>defpackage</title>
<type>Macro</type>
<arguments>package-name &amp;rest options</arguments>
<package>lisp</package>
<description>
新しくパッケージを作ります。

  :internal-size  内部シンボルのハッシュサイズ
  :external-size  外部シンボルのハッシュサイズ

:internal-size 及び :external-size の大きさは、だいたい登録するシンボル
数の1/3ぐらいの値でいいでしょう。この値が足らないからといって、新しいシ
ンボルが登録できない訳ではないので、たいして気にする必要はないでしょう。
ハッシューがチェーンされて、検索(intern時のみ）がちょっと遅くなるだけで
す。こだわる方は素数を選ぶでしょう。

使用例：

  ;;; henmiというパッケージを作る。
  ;;; lisp, editorをuseしています。
  (defpackage "henmi"
     (:use "lisp" "editor")
     (:internal-size 200)
     (:external-size 10))

互換性:
  :internal-size, :external-size はcommonにはない。
</description>
<seealso>パッケージ</seealso>
<section>パッケージ</section>
<file>package.l</file>
</chapter>

<chapter>
<title>long-operation</title>
<type>Macro</type>
<arguments>&amp;rest body</arguments>
<package>editor</package>
<description>
カーソルを砂時計にします。明らかに処理時間が長いことが見込まれる場合にし
ようすると良いと思います。

使用例：
  (long-operation
     (message "start")
     ;; 何か長い処理
     (message "end"))
</description>
<section>その他</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>get-buffer-window</title>
<type>Function</type>
<arguments>get-buffer-window BUFFER &amp;optional START-WINDOW</arguments>
<package>editor</package>
<description>
バッファを表示しているウィンドウを返します。同じバッファが複数のウィンド
ウに表示されていますので、START-WINDOWから順番に探し始めます。
現在表示されてないバッファはnilが返ります。

  BUFFER       : 検索するバッファ
  START-WINDOW : 検索をし始めるウィンドウ

使用例：
  ;;; window-bufferも使ってみる。
  (selected-buffer)
  =&gt; #&lt;buffer: *scratch*&gt;
  (window-buffer (get-buffer-window (selected-buffer)))
  =&gt; #&lt;buffer: *scratch*&gt;
</description>
<seealso>window-buffer</seealso>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-buffer-create</title>
<type>Function</type>
<arguments>get-buffer-create NAME</arguments>
<package>editor</package>
<description>
指定した名前のバッファを返します。名前を指定しますが、同じ名前のバッファ
が既にあればそれを返します。無ければ新しく作ります。

switch-to-bufferも良く似た動きをしますが、switch-to-bufferは
get-buffer-createを用いて実装されています。

  NAME : バッファの名前

使用例：
  ;;; *calc*がなければ作成する。
  (get-buffer-create "*calc*")
  =&gt; #&lt;buffer: *calc*&gt;
</description>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>selected-buffer</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
現在操作中のバッファ（カレントバッファ）を返します。

使用例：
  (selected-buffer)
  =&gt; #&lt;buffer: reference.xml&gt;

互換性：
  この関数はmuleにはありません。
  muleでのcurrent-bufferに相当します。
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-buffer-file-name</title>
<type>Function</type>
<arguments>get-buffer-file-name &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファが参照しているファイルのフルパスを返します。
ファイルを参照していなければnilを返します。

  BUFFER : ファイルのフルパスを返すバッファを指定します。

使用例：
  ;;; カレントバッファのファイルのフルパスを返します。
  (get-buffer-file-name)
  =&gt; "C:/xyzzy/site-lisp/xmldoc/reference.xml"
</description>
<seealso>set-buffer-file-name</seealso>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-name</title>
<type>Function</type>
<arguments>buffer-name BUFFER</arguments>
<package>editor</package>
<description>
バッファの名前を返します。

  BUFFER : 名前を返すバッファを指定します。

使用例：
  ;;; カレントバッファの名前を返します。
  (buffer-name (selected-buffer))
  =&gt; "reference.xml"
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>alpha-char-p</title>
<type>Function</type>
<arguments>alpha-char-p CHAR</arguments>
<package>lisp</package>
<description>
文字が英字[A-Za-z]かどうかを判定します。

  CHAR : 判定する文字
</description>
<seealso>alphanumericp</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>alphanumericp</title>
<type>Function</type>
<arguments>alphanumericp CHAR</arguments>
<package>lisp</package>
<description>
文字が英数字[A-Za-z0-9]かどうかを判定します。

  CHAR : 判定する文字
</description>
<seealso>alpha-char-p</seealso>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>and</title>
<type>Macro</type>
<arguments>and {FORM}*</arguments>
<package>lisp</package>
<description>
フォームがnilでない間だけ順番に評価します。
フォームが一つでもnilならば、そこで評価を中断してnilを返して終了します。
全てのフォームがnilでなければ、最後に実行したフォームの値を返します。

  ;;; exp1 がnot-nilなら exp2を実行し、
  ;;; exp2 がnot-nilなら exp3を実行し、
  ;;; exp3 がnot-nilなら.......
  (and exp1 exp2 exp3 ...)

例えば、以下の様にチェックを順番に記述するような場合に向いていると思います。
チェックに失敗すれば、以降の処理は実行しません。

  (and (file-exist-p ...) ; 特定のファイルの存在チェック
       (find-file ...)    ; そのファイルを読み込みチェック
       (scan-buffer ...)  ; 正規表現で検索
       (match-string 2)   ; 検索結果のチェック
       ...)       
</description>
<seealso>or</seealso>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>or</title>
<type>Macro</type>
<arguments>{form}*</arguments>
<package>lisp</package>
<description>
フォームがnilの間だけ順番に評価します。
フォームが一つでもnilでなければ、そこで評価を中断してフォームの値を返し
て終了します。全てのフォームがnilならば、nilを返します。

  ;;; exp1 がnilなら、そこで実行を中止しnilを返す。
  ;;; exp2 がnilなら、そこで実行を中止しnilを返す。
  ;;; ...
  ;;; 最後に実行したexpの値を返す。
  (or exp1 exp2 exp3 ...)

ルールに従って一つだけ値を定める場合に向いていると思います。

  (or (get-buffer-file-name) ; バッファにファイル名があればそれを使う。
      *foo*                  ; ファイル名がなければ、変数*foo*の値を使う。
      (read-string "foo: ")) ; *foo*にも値が無ければ入力してもらう。
</description>
<seealso>and</seealso>
<section>制御構造</section>
<file></file>
</chapter>

<chapter>
<title>when</title>
<type>Macro</type>
<arguments>when TEST &amp;body BODY</arguments>
<package>lisp</package>
<description>
条件がnilでなければフォームを連続して実行します。

  TEST : 条件部
  BODY : nilでない場合に実行するフォーム

whenはマクロです。以下の様に展開されます。

 (when exp1 exp2 exp3 ...)
 = (if exp1
      (progn exp2
             exp3
             ...))
</description>
<section>制御構造</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>filer</title>
<type>Function</type>
<arguments>filer &amp;optional PATH ALLOW-MULTIPLE-SELECT-P CAPTION DUAL-WINDOW-P MODELESSP</arguments>
<package>editor</package>
<description>
ファイラーを開きます。

  PATH      : ファイラーが最初に表示するディレクトリを指定します。
  ALLOW-MULTIPLE-SELECT-P
            : ファイルを複数選択可能にするかどうかを指定します。
  CAPTION   : ファイラーのウィンドウのタイトルを指定します。
  DUAL-WINDOW-P
            : 二画面ファイラーで開くかどうかを指定します。
  MODELESSP : モードレスダイアログでファイラーを開くかどうかを指定します。
              モードレスの場合には編集しつつファイラーを表示できます。

選択結果を多値で返します。

  最初の戻り値はユーザが選択したファイルのリストを返します。
  次の戻り値はOKボタンを押したらt、CANCELボタンを押したらnilを返します。

使用例：
  ;;; multiple-value-bindでファイルを受け取る。
  (multiple-value-bind (files bool)
       (filer "c:/" t "title" nil)
       (when bool
         (msgbox "~{~S~%~}" files)))
  =&gt; :ok
</description>
<section>ファイラー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>with-output-to-temp-buffer</title>
<type>Macro</type>
<arguments>with-output-to-temp-buffer (BUFNAME &amp;optional (POPUP t)) &amp;rest BODY</arguments>
<package>editor</package>
<description>
指定されたバッファを作成し、標準出力をそのバッファにリダイレクトします。
同じ名前のバッファがあった場合には、そのバッファの内容は破棄されます。
単に処理結果だけを書き込むような場合に便利です。

  BUFNAME : バッファの名前を指定します。
  POPUP   : バッファを分割表示する際の行数／列数を指定します。
        t       ニ分割します。
        整数    指定行数／列数で分割します。
        nil     バッファを分割表示しません。
  VERT-P  : バッファの分割方法を指定します。
            POPUP が nil の場合は意味を持ちません。
        non-nil 左右にバッファを分割します。
        nil     上下にバッファを分割します。

使用例：
  ;;; *Help*を作ってそこに書き出してみる。
  (with-output-to-temp-buffer ("*Help*")
     (format t "foo~%")
     (format t "bar~%"))

互換性：
   muleにもCommon Lispにもありません。
</description>
<seealso>with-output-to-buffer</seealso>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>with-output-to-selected-buffer</title>
<type>Function</type>
<arguments>with-output-to-selected-buffer &amp;rest BODY</arguments>
<package>editor</package>
<description>
標準出力をカレントバッファにリダイレクトします。
ポイントがある位置から出力されます。
  
使用例：
  ;;; カレントバッファに書き出してみる。
  (with-output-to-selected-buffer
     (format t "foo~%")
     (format t "bar~%"))
</description>
<seealso>with-output-to-buffer</seealso>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>with-output-to-buffer</title>
<type>Macro</type>
<arguments>with-output-to-buffer (BUFFER &amp;optional POINT) &amp;rest BODY</arguments>
<package>editor</package>
<description>
標準出力を指定されたバッファにリダイレクトします。

  BUFFER : 出力するバッファ
  POINT  : 出力をするポイントを指定します。
           指定しない場合には、バッファの先頭から出力されます。
  BODY   : 実行するフォーム

使用例：
  ;;; *scratch*に書き出してみる。
  (with-output-to-buffer ((find-buffer "*scratch*"))
     (format t "foo~%")
     (format t "bar~%"))
</description>
<seealso>with-output-to-selected-buffer</seealso>
<seealso>with-output-to-temp-buffer</seealso>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>message</title>
<type>Function</type>
<arguments>message FMT &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
メッセージをステータスバーに出力します。

  FMT  : format同様の書式が指定できます。
  ARGS : 出力書式へのパラメタとなります。
</description>
<seealso>format</seealso>
<section>入出力</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>save-restriction</title>
<type>Special Form</type>
<arguments>save-restriction {FORM}*</arguments>
<package>editor</package>
<description>
narrow-to-regionする前の状態を保存します。ポイントやバッファの位置は保存
しません。ポイントやバッファの位置を保存したい場合には、save-excursionを
使用します。

特定の処理の前後でrestrictionの状態とポイントの両方を保存したい場合には、
以下の様にします。

  ;;; うまくいく書き方
  (save-excursion (save-restriction ... )) 

以下の様に書いてしまった場合、処理の中でrestrictionを掛けると内側の
save-excursionでのポイントの復元がうまくいかないことがあります。注意しま
しょう。

  ;;; うまくいかないことがある書き方
  (save-restriction (save-excursion ... ))

使用例：
    ;;; この時点では narrow-to-region してないとする。
    (save-restriction
      (narrow-to-region FROM-1 TO-1)             ; FROM-1からTO-1に制限する
      (save-restriction
        (narrow-to-region FROM-2 TO-2)           ; FROM-2からTO-2に制限する
        (msgbox "~A ~A" (point-min) (point-max))
      )                                          ; FROM-1からTO-1に制限されている
                                                 ; 状態に戻る
      (msgbox "~A ~A" (point-min) (point-max))
    )                                            ; 制限されなくなる
    (msgbox "~A ~A" (point-min) (point-max))
</description>
<seealso>narrow-to-region</seealso>
<seealso>save-excursion</seealso>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>save-window-excursion</title>
<type>Special Form</type>
<arguments>save-window-excursion {FORM}*</arguments>
<package>editor</package>
<description>
処理の前後でカレントウィンドウとウィンドウのレイアウトの状態を保存します。
</description>
<seealso>save-excursion</seealso>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>error</title>
<type>Function</type>
<arguments>error DATUM &amp;rest ARGS</arguments>
<package>lisp</package>
<description>
例外を発生します。

発生させた例外は上位の階層でハンドリングすることができます。
ハンドリングの方法はhandler-caseを参照して下さい。
</description>
<seealso>handler-case</seealso>
<section>エラー</section>
<file>handler.l</file>
</chapter>

<chapter>
<title>merge-pathnames</title>
<type>Function</type>
<arguments>merge-pathnames PATHNAME &amp;optional DEFAULTS</arguments>
<package>lisp</package>
<description>
パスとファイル名をくっつけます。

  PATHNAME : ファイル名の部分を指定します。
  DEFUALTS : パスの部分を指定します。
             指定しないと(default-directory)のパスが使用されます。

使用例：
  ;;; "c:/foo"と"bar.l"をくっつける。
  (merge-pathnames "bar.l" "c:/foo")
  =&gt; "c:/foo/bar.l"

  (merge-pathnames "bar.l" "c:/foo/") &lt;--ディレクトリの末尾に/がついているかとか
  =&gt; "c:/foo/bar.l"                      気にしなくていい。
</description>
<seealso>file-namestring</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-write-time</title>
<type>Function</type>
<arguments>file-write-time FILENAME</arguments>
<package>lisp</package>
<description>
ファイルの最終更新日をユニバーサルタイム形式で返します。

  FILENAME : ファイル名を指定します。
             フルパスでなければ(default-directory)からの相対パスになります。

使用例：
  ;;; .xyzzyの最終更新日を返します。
  (file-write-time ".xyzzy")
  =&gt; 3076147256
</description>
<seealso>set-file-write-time</seealso>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>encode-universal-time</title>
<type>Function</type>
<arguments>encode-universal-time SECOND MINUTE HOUR DAY MONTH YEAR &amp;optional TIME-ZONE</arguments>
<package>lisp</package>
<description>
日時からユニバーサルタイム形式の時間に変換します「1900年1月1日0時0分0秒
から指定された日時まで秒数」をユニバーサルタイム形式の時間と呼びます。

  SECOND    : 秒数
  MINUTE    : 分
  HOUR      : 時
  DAY       : 日
  MONTH     : 月
  YEAR      : 年
  TIME-ZONE : タイムゾーンを指定します。GMTからの差分の時間を指定するようです。
              省略すると選択しているタイムゾーンとの差分が使用されます。
              普通はGMTとJSTとの差分の-9(時間)となります。

ユニバーサルタイム形式の時間から日時への変換はdecode-universal-timeを使用します。

使用例：
  (encode-universal-time 0 0 0 1 1 1900)    =&gt; -32400
  (encode-universal-time 0 0 0 1 1 1900 0)  =&gt; 0
  (encode-universal-time 0 0 0 1 1 1900 -9) =&gt; -32400
  (encode-universal-time 0 30 18 24 4 2003) =&gt; 3260165400

--- 原文 ---
Description: returns an integer which represents the number of seconds 
from midnight 1 January 1900 GMT to the time specified by the given 
components of Decoded Time format. If time-zone is unspecified, it defaults 
to the current time zone and the integer is adjusted to take account of 
daylight saving time. If time-zone is specified, the integer is adjusted 
accordingly but no account is taken of daylight saving time.

参照：
  timestmp.l
</description>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>decode-universal-time</title>
<type>Function</type>
<arguments>decode-universal-time UNIVERSAL-TIME &amp;optional TIME-ZONE</arguments>
<package>lisp</package>
<description>
ユニバーサルタイム形式の時間から日時に変換します。

  UNIVERSAL-TIME : ユニバーサルタイム形式の時間を指定します。
  TIME-ZONE      : タイムゾーンを指定します。

変換された日時は多値で返されます。multiple-value-***系のマクロで受け取りましょう。
日時からユニバーサルタイム形式の時間に変換するには、encode-universal-timeを使用します。

使用例：
  ;;; .xyzzyの最終更新日(2003/3/30 9:34:25)を取得する。
  (multiple-value-list
   (decode-universal-time
    (file-write-time ".xyzzy")))
  =&gt; (25 34 9 30 3 2003 6 nil -9)

--- 原文 ---
Description: returns universal-time in Decoded Time format, allowing for 
time-zone. If this is unspecified, the value returned is for the current 
time zone set by *time-zone*. Nine values are returned, as for get-decoded-time.
  (multiple-value-list
    (decode-universal-time 3100393640))
  =&gt; (20 27 13 1 4 1998 2 nil -9)

  (multiple-value-list
    (decode-universal-time (file-write-time "c:/autoexec.bat"))
  =&gt; (20 27 13 1 4 1998 2 nil -9)

参照：
  timestmp.l
</description>
<seealso>format-date-string</seealso>
<seealso>encode-universal-time</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>format-date-string</title>
<type>Function</type>
<arguments>format-date-string FMT &amp;optional UNIVERSAL-TIME</arguments>
<package>editor</package>
<description>
書式に従って整形した日時を文字列として返します。

  FMT            : 日付用の書式文字列を指定します。
  UNIVERSAL-TIME : 出力する日時をユニバーサルタイム形式で指定します。
                   省略時は現在時刻が使われます。

使用例：
  (format-date-string "%y/%m/%d %H:%M:%S" 3112500590)
  =&gt; "98/08/19 16:29:50"
  (format-date-string "%y年%#m月%#d日(%v)")
  =&gt; "99年11月10日(水)"

日付用の書式：
  書式文字については timestmp.l を参照して下さい。以下は抜粋です。 
  a: 短い形式の曜日
  A: 長い形式の曜日
  b: 短い形式の月
  B: 長い形式の月
  d: 日(00～31)                 # (0～31)
  e: 和暦の年(01～)             # (1～)
  E: 和暦の年(元, 02～)         # (元, 2～)
  g: 元号(明治,大正,昭和,平成)  # (明,大,昭,平)
  G: 元号(M, T, S, H)
  H: 時(00～59)                 # (0～59)
  I: 12時間の時(01～12)         # (1～12)
  m: 月(01～12)                 # (1～12)
  M: 分(00～59)                 # (0～59)
  P: AM/PM                      # am/pm
  S: 秒(00～59)                 # (0～59)
  v: 曜日(日本語)
  y: 年(2桁)
  Y: 年(4桁)
  z: タイムゾーン名(JST-9)
  Z: タイムゾーン(+0900)
</description>
<seealso>decode-universal-time</seealso>
<seealso>format-date</seealso>
<section>日付・時間</section>
<file>timestmp.l</file>
</chapter>

<chapter>
<title>format-date</title>
<type>Function</type>
<arguments>format-date S FMT &amp;optional UNIVERSAL-TIME</arguments>
<package>editor</package>
<description>
書式に従って整形した日時をストリームに出力します。

  S              : 出力ストリームを指定します。
                   formatの様にtやnilを指定することはできません。
  FMT            : 日付用の書式文字列を指定します。
                   日付用の書式文字列はformat-date-stringを参照して下さい。
  UNIVERSAL-TIME : 出力する日時をユニバーサルタイム形式で指定します。
                   省略時は現在時刻が使われます。
</description>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<section>日付・時間</section>
<file>timestmp.l</file>
</chapter>

<chapter>
<title>set-file-write-time</title>
<type>Function</type>
<arguments>set-file-write-time FILENAME UNIVERSAL-TIME</arguments>
<package>lisp</package>
<description>
ファイルの最終更新日を変更します。

  FILENAME       : ファイル名を指定します。フルパスでなければ
                   (default-directory)からの相対パスになります。
  UNIVERSAL-TIME : 最終更新日をユニバーサルタイム形式で指定します。
</description>
<seealso>file-write-time</seealso>
<seealso>decode-universal-time</seealso>
<seealso>format-date-string</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-file-attributes</title>
<type>Function</type>
<arguments>get-file-attributes PATHNAME</arguments>
<package>editor</package>
<description>
ファイルの属性を返します。ファイルサイズや最終更新日などの情報も一括して取
得したい場合には、get-file-infoを使用しましょう。

  PATHNAME : 属性を取得するファイル名を指定します。

戻り値は以下の値の合計で表されます。

  ed::*file-attribute-readonly*   : 読み取り専用
  ed::*file-attribute-hidden*     : 隠しファイル
  ed::*file-attribute-system*     : システムファイル
  ed::*file-attribute-directory*  : ディレクトリ
  ed::*file-attribute-archive*    : アーカイブ
  ed::*file-attribute-compressed* : 圧縮

使用例：
  ;;; c:\autoexec.batの属性を取得してみる。多分アーカイブになっているので
  ;;; ed::*file-attribute-archive*との論理積が0以外になる。
  (get-file-attributes "c:/autoexec.bat")
  =&gt; 32
  (= (get-file-attributes "c:/autoexec.bat") ed::*file-attribute-archive*)
  =&gt; t
</description>
<seealso>get-file-info</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-file</title>
<type>Function</type>
<arguments>copy-file FILE NEW-FILE :IF-EXISTS :COPY-ATTRIBUTES :IF-ACCESS-DENIED</arguments>
<package>lisp</package>
<description>
ファイルをコピーします。

  FILE             : コピー元のファイル名を指定します。
  NEW-FILE         : コピー先のファイル名を指定します。
  :COPY-ATTRIBUTES : コピーするときの属性を指定します。
                     指定できる属性はget-file-infoを参照して下さい。
  :IF-EXISTS       : ファイルが存在しない場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。
        :overwrite      強制的にファイル名の変更を試みます。
  :IF-ACCESS-DENIED : アクセスが拒否された場合の動作を指定します。
        :error          エラーを出力します。
        :skip           エラーは出力せず、nilを返します。

使用例：
  ;;; ローカルのautoexec.batを マシン名 VENUSの /work/autoexec.batにコピーする。
  (copy-file "c:/autoexec.bat" "//VENUS/work/autoexec.bat"
             :if-exists :overwrite)
</description>
<seealso>rename-file</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>append-trail-slash</title>
<type>Function</type>
<arguments>append-trail-slash STRING</arguments>
<package>editor</package>
<description>
文字列の末尾に"/"がなければ"/"を追加します。

使用例：
  (append-trail-slash "ffjfj")
  =&gt; "ffjfj/"
  (append-trail-slash "ffjfj/")
  =&gt; "ffjfj/"
</description>
<seealso>remove-trail-slash</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-right-trim</title>
<type>Function</type>
<arguments>string-right-trim CHARACTER-BAG STRING</arguments>
<package>lisp</package>
<description>
文字列の末尾から指定した文字群を削除します。

  STRING         : 文字列
  CHARACTGER-BAG : 削除する文字群です。
  
使用例：
  ;;;  末尾の"/"や"\"を取り除きます。
  (string-right-trim "/\\" "/foo/bar/zzz.txt/" )
  =&gt; "/foo/bar/zzz.txt"
</description>
<seealso>string-trim</seealso>
<seealso>string-left-trim</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-trim</title>
<type>Function</type>
<arguments>string-trim CHARACTER-BAG STRING</arguments>
<package>lisp</package>
<description>
文字列の前後から指定した文字群を削除します。

  STRING         : 文字列
  CHARACTGER-BAG : 削除する文字群です。
  
使用例：
  ;;;  前後の"/"や"\"を取り除きます。
  (string-trim "/\\" "/foo/bar/zzz.txt/" )
  =&gt; "foo/bar/zzz.txt"
</description>
<seealso>string-right-trim</seealso>
<seealso>string-left-trim</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-left-trim</title>
<type>Function</type>
<arguments>character-bag string</arguments>
<package>lisp</package>
<description>
文字列の先頭から指定した文字群を削除します。

  STRING         : 文字列
  CHARACTGER-BAG : 削除する文字群です。
  
使用例：
  ;;;  先頭の"/"や"\"を取り除きます。
  (string-left-trim "/\\" "/foo/bar/zzz.txt/" )
  =&gt; "foo/bar/zzz.txt/"
</description>
<seealso>string-trim</seealso>
<seealso>string-right-trim</seealso>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-type</title>
<type>Function</type>
<arguments>pathname-type PATHNAME</arguments>
<package>lisp</package>
<description>
ファイル名の拡張子を取り出します。拡張子がなければnilを返します。

  PATHNAME : 拡張子を取り出すファイル名を指定します。

使用例：
  ;;; foo.lzh
  (pathname-type "foo.lzh" )
  =&gt;"lzh"
  (pathname-type "foo/bar/zzz.txt")
  =&gt;"txt"
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>split-string</title>
<type>Function</type>
<arguments>split-string STRING SEPARATOR &amp;optional IGNORE-EMPTY CHAR-BAG</arguments>
<package>editor</package>
<description>
文字列を指定されたセパレータ文字で分割したリストにします。
セパレータ文字は含まれません。

  STRING       : 分割する文字列を指定します。
  SEPARATOR    : セパレータ文字を指定します。
  IGNORE-EMPTY : 長さが0の文字列も（つまり、セパレータ文字が連続するような場合）
                 を許すかどうかを指定します。
  CHAR-BAG     : 分割した後の文字列の前後をトリムするための文字群を指定します。
  
使用例：
  (split-string "121,,12321" #\,)       =&gt; ("121" "12321")
  (split-string "121,,12321" #\, t)     =&gt; ("121" "" "12321")
  (split-string "121,,12321" #\, t "1") =&gt; ("2" "" "232")
  (split-string "121,,12321" #\, t "3") =&gt; ("121" "" "12321")
</description>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>valid-path-p</title>
<type>Function</type>
<arguments>valid-path-p PATHNAME</arguments>
<package>lisp</package>
<description>
パスが有効かどうかをチェックします。

  PATHNAME : 有効かどうかをチェックするパス

ここで「有効なパス」というのは、最終的なファイルやディレクトリが存在する
ことを指すのではなく、途中の経路が存在することを指します。ファイルを指し
示している場合には、そのファイル自体の有無は関係ありません。そのファイル
に至るディレクトリが全て存在していることが有効か否かに関わります。

使用例：
  (valid-path-p "foo/bar/zzz.txt")
  =&gt;nil
  (valid-path-p "/autoexec.bat")
  =&gt;t
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>xyzzyで提供されているストリームの種類</title>
<type>Tips</type>
<arguments></arguments>
<description>
（途中）
以下はxyzzyで提供されているストリームの種類です。

  Commonと同じ
  ---------------------------------------------
  file-input-stream       open
  file-output-stream      open
  file-io-stream          open
  string-input-stream     make-string-input-stream
  string-output-stream    make-string-output-stream
  synonym-stream          make-synonym-stream
  broadcast-stream        make-broadcast-stream
  concatenated-stream     make-concatenated-stream
  echo-stream             make-echo-stream
  two-way-stream          make-two-way-stream
  ---------------------------------------------

synonym-stream以降は使ったことないんで(^^;、動くかどうか分からないんです
が多分動くでしょう(^^)。

  独自
  ---------------------------------------------
  buffer-stream           make-buffer-stream
  status-window-stream    なし
  keyboard-stream         なし
  wstreams-stream         なし
  ---------------------------------------------

独自ストリームの概要：
  buffer-stream
    バッファをストリームとみなして入出力どっちでもできます。  
  status-window-stream
    ステータスウィンドウをストリームとみなして出力ができます。
    グローバル変数*status-window*の値です。
  keyboard-stream
    キーボードをストリームとみなして入力ができます。
    グローバル変数*keyboard*の値です。
  wstreams-stream
    formatからコールバックが呼ばれたときのstreamの実体。
</description>
<section>入出力</section>
<file></file>
</chapter>

<chapter>
<title>buffer-stream-p</title>
<type>Function</type>
<arguments>buffer-stream-p STREAM</arguments>
<package>editor</package>
<description>
ストリームがbuffer-streamかどうかを返します。

  STREAM : 判定するストリーム

  t   ストリームはbuffer-streamである。
  nil ストリームはbuffer-streamではない。
</description>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-buffer-stream</title>
<type>Function</type>
<arguments>make-buffer-stream BUFFER &amp;optional POINT EOB</arguments>
<package>editor</package>
<description>
バッファ上にbuffer-streamを作成します。

  BUFFER : buffer-streamを作成するバッファを指定します。
  POINT  : 入出力を開始するポイントを指定します。
        nil     バッファの先頭が開始位置
        nil以外 指定されたポイントが開始位置
  EOB    : 終端のポイントを指定します。
        nil     バッファの最後が終端
        nil以外 指定されたポイントが終端
</description>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-stream-buffer</title>
<type>Function</type>
<arguments>buffer-stream-buffer STREAM</arguments>
<package>editor</package>
<description>
buffer-streamであるストリームが関連付けられているバッファを返します。

  STREAM : buffer-streamであるストリームを指定します。
</description>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-stream-point</title>
<type>Function</type>
<arguments>buffer-stream-point STREAM</arguments>
<package>editor</package>
<description>
buffer-streamであるストリームのポイントを返します。

  STREAM : buffer-streamであるストリームを指定します。
</description>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>buffer-stream-set-point</title>
<type>Function</type>
<arguments>buffer-stream-set-point STREAM POINT</arguments>
<package>editor</package>
<description>
buffer-streamであるストリームのポイントを指定します。

  STREAM : buffer-streamであるストリームを指定します。
  POINT  : buffer-stream上の入出力のポイントを指定します。

参考：
  misc.lのwith-output-to-bufferとかwith-input-from-buffer
</description>
<seealso>xyzzyで提供されているストリームの種類</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sit-for</title>
<type>Function</type>
<arguments>sit-for TIMEOUT &amp;optional NO-REDRAW</arguments>
<package>editor</package>
<description>
指定された秒数停止します。途中でキー入力があれば直ぐに再開します。

  TIMEOUT   : 停止する秒数を指定します。
  NO-REDRAW : 再開後に画面を再描画するかどうかを指定します。
</description>
<seealso>sleep-for</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>sleep-for</title>
<type>Function</type>
<arguments>sleep-for TIMEOUT</arguments>
<package>editor</package>
<description>
指定された秒数停止します。途中でキー入力があっても直ぐには再開しません。

  TIMEOUT   : 停止する秒数を指定します。
</description>
<seealso>sit-for</seealso>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-selection-type</title>
<type>Function</type>
<arguments>get-selection-type NIL</arguments>
<package>editor</package>
<description>
バッファの選択状態を返します。

  nil   選択なし、
  1     行モード選択状態
  2     文字モード選択状態
  3     矩形選択状態
</description>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>selection-point</title>
<type>Function</type>
<arguments>selection-point NIL</arguments>
<package>editor</package>
<description>
セレクションの終端のポイントを返します。
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>selection-mark</title>
<type>Function</type>
<arguments>selection-mark NIL</arguments>
<package>editor</package>
<description>
セレクションの開始のポイントを返します。
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>stop-selection</title>
<type>Function</type>
<arguments>stop-selection NIL</arguments>
<package>editor</package>
<description>
セレクションを解除します。
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ed::get-selection-start-end</title>
<type>Function</type>
<arguments></arguments>
<description>
セレクションの開始位置と終了位置を多値で返します。
ただし、矩形選択状態ではnilを返します。
</description>
<section>ポジション</section>
<file>select.l</file>
</chapter>

<chapter>
<title>make-keymap</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
空のキーマップを作成します。
</description>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-sparse-keymap</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
空のキーマップを作成します。
キー定義の数が少ない時に使うとメモリを節約できます。

使用例：
  ;;; lispmode.lより
  (unless *lisp-mode-map*
    (setq *lisp-mode-map* (make-sparse-keymap))
    (define-key *lisp-mode-map* #\C-M-x 'eval-defun)
    ...
    (define-key *lisp-mode-map* #\) 'lisp-electric-close))
</description>
<seealso>make-keymap</seealso>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>use-keymap</title>
<type>Function</type>
<arguments>use-keymap KEYMAP &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファが使用するキーマップを設定します。

  KEYMAP : 使用するキーマップを指定します。
  BUFFER : バッファを指定します。省略時はカレントバッファに適用されます。

使用例：
  ;;; lispmode.lより
  (defun lisp-mode ()
    (interactive)
    (kill-all-local-variables)
    (setq buffer-mode 'lisp-mode)
    (setq mode-name "Lisp")
    (use-keymap *lisp-mode-map*)
    ...
    (run-hooks '*lisp-mode-hook*))
</description>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-keymap</title>
<type>Function</type>
<arguments>copy-keymap MAP</arguments>
<package>editor</package>
<description>
キーマップのコピーを返します。

使用例：
  ;;; gresreg.lより
  ;;; query-replaceのキーマップをコピーして
  ;;; query-gresregのキーマップを作って、ちょっと修正する。
  (unless *query-gresreg-map*
    (setq *query-gresreg-map* (copy-keymap *query-replace-map*))
    (define-key *query-gresreg-map* #\C-g '(throw . quit)))
</description>
<section>キーマップ</section>
<file>keymap.l</file>
</chapter>

<chapter>
<title>dde-terminate</title>
<type>Function</type>
<arguments>dde-terminate CHAN</arguments>
<package>editor</package>
<description>
DDE 対話を終了します。引数 chan は DDE チャンネルです。正常に終了した場
合は t、すでに対話が終了していた場合は nil を返します。

  CHAN : チャンネルを指定します。
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dde-execute</title>
<type>Function</type>
<arguments>dde-execute CHAN DATA</arguments>
<package>editor</package>
<description>
DDE EXECUTE を実行します。引数 chan は DDE チャンネル、data は相手にくら
わすコマンド文字列です。コマンドの内容は、相手のマニュアルに従ってくださ
い。dde-execute は t を返します。

  CHAN : チャンネルを指定します。
  DATA : データを指定します。

なお、DDE 関数では以下の例外が発生する可能性があります。必要であれば例外
を処理してください。

  dde-timeout        タイムアウトしました。
  dde-busy           DDE サーバが BUSY です。
  dde-low-memory     サーバ先行状態です
  dde-no-conv        DDE 対話が確立できません
  dde-not-processed  トランザクションの実行に失敗しました
  dde-server-died    サーバーが終了しました
  storage-error      メモリがありません
  dde-error          よくわかんないけど、とにかくエラーです
</description>
<section>システム</section>
<seealso>dde-poke</seealso>
<seealso>dde-request</seealso>
<seealso>dde-terminate</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dde-poke</title>
<type>Function</type>
<arguments>dde-poke CHAN ITEM DATA</arguments>
<package>editor</package>
<description>
DDE POKE を実行します。

  CHAN : チャンネルを指定します。
  ITEM : （詳細不明）
  DATA : データを文字列で指定します。

引数 CHAN は DDE チャンネル、DATA は相手にくらわす文字列です。文字列の内
容は、相手のマニュアルに従ってください。dde-poke は t を返します。
</description>
<section>システム</section>
<seealso>dde-execute</seealso>
<seealso>dde-request</seealso>
<seealso>dde-terminate</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dde-request</title>
<type>Function</type>
<arguments>dde-request CHAN DATA RESULT-TYPE</arguments>
<package>editor</package>
<description>
DDE REQUEST を実行します。

  CHAN        : チャンネルを指定します。
  DATA        : データを指定します。
  RESULT-TYPE : 戻り値の型を指定します。

引数 chan は DDE チャンネル、data は相手にくらわす文字列です。文字列の内
容は、相手のマニュアルに従ってください。戻り値は DDE の相手が返したもの
を返しますが、RESULT-TYPE の指定によってデータの解釈を以下のようにおこな
います。

  :text   : 通常の文字列を返します。
  :binary : 漢字などを無視して返ってきたデータをそのまま文字列で返します。
  :int8
  :int16
  :int32  : データをそれぞれ 8, 16, 32 ビット整数の配列とみなして整数のリ
            ストで返します。配列の要素が 1 のときは整数値を返します。

戻り値型の指定は、もじらの DDE で遊ぼうと思って作っただけなので、通常は
指定しなくて構いません。
</description>
<section>システム</section>
<seealso>dde-execute</seealso>
<seealso>dde-poke</seealso>
<seealso>dde-terminate</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-menu</title>
<type>Function</type>
<arguments>create-menu &amp;optional TAG</arguments>
<package>editor</package>
<description>
新たに作成した空のメニューを返します。

  TAG : 識別用のタグを指定します。

メニューの中身は空なので、以下の関数で登録必要があります。
中身を動的に作る必要が無ければ、define-menuを使用した方が良いです。

  add-menu-item         : 項目を追加します。
  add-menu-separator    : セパレータを追加します。
  add-popup-menu        : ポップアップメニューを追加します。
  insert-menu-item      : 項目を挿入します。
  insert-menu-separator : セパレータを挿入します。
  insert-popup-menu     : ポップアップメニューを挿入します。

作成したメニューは以下の関数で使います。

  set-menu       : 標準のメニューとして設定します。
  use-local-menu : バッファにローカルなメニューとして設定します。
</description>
<seealso>create-popup-menu</seealso>
<seealso>define-menu</seealso>
<seealso>set-menu</seealso>
<seealso>use-local-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-popup-menu</title>
<type>Function</type>
<arguments>create-popup-menu &amp;optional TAG</arguments>
<package>editor</package>
<description>
新たに作成したポップアップメニューを返します。ポップアップメニューとして
使えることを除けば、create-menuで作成されたメニューを同じです。

  TAG : 識別用のタグを指定します。

メニューの中身は空なので、create-menuと同じように登録する必要があります。
中身を動的に作る必要が無ければ、define-popup-menuを使用した方が良いです。

作成したポップアップメニューは以下の関数で使います。

  insert-popup-menu  : 既存のメニューにポップアップメニューを追加します。
  track-popup-menu   : ポップアップメニューをその場で表示します。
</description>
<seealso>define-popup-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>add-popup-menu</title>
<type>Function</type>
<arguments>add-popup-menu MENU POPUP-MENU NAME</arguments>
<package>editor</package>
<description>
ポップアップメニューをメニューの末尾に追加します。

  MENU       : 追加先のメニューを指定します。
  POPUP-MENU : 追加するポップアップメニューを指定します。
  NAME       : メニューに表示される名前を指定します。

使用例：
  ;;; 右クリックメニューを標準のメニューに追加してみる。
  (add-popup-menu *app-menu* *app-popup-menu* "編集2(&amp;E)")
  =&gt; #&lt;menu 48701736&gt;
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>add-menu-item</title>
<type>Function</type>
<arguments>add-menu-item MENU TAG NAME &amp;optional COMMAND INIT</arguments>
<package>editor</package>
<description>
新たに作成したメニュー項目をメニューの末尾に追加します。

  MENU    : 追加先のメニューを指定します。
  TAG     : 識別用のタグを指定します。
  NAME    : メニューに表示される名前を指定します。
  COMMAND : メニューの項目が選択されたときに実行するコマンドを指定します。
  INIT    : メニューが開く直前に評価し返される値によってメニューの状態を設定します。
            任意のS式が指定できますが、あまり無茶なことはしないでください。
            式の値として意味のある値には以下のものがあります。

        :modified     カレントバッファが変更されていなければ灰色表示。
        :undo         undo不可能であれば灰色表示。
        :redo         redo不可能であれば灰色表示。
        :selection    カレントバッファのテキストが未選択であるか矩形選択であれば灰色表示。
        :rectangle    カレントバッファのテキストが未選択であるか矩形以外の選択であれば灰色表示。
        :clipboard    クリップボードが空であれば灰色表示。
        :check        チェック。
        :disable      灰色表示。
        その他        使用可能。
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>add-menu-separator</title>
<type>Function</type>
<arguments>add-menu-separator MENU &amp;optional TAG</arguments>
<package>editor</package>
<description>
セパレータをメニューの末尾に追加します。

  MENU : 追加先のメニューを指定します。
  TAG  : 識別用のタグを指定します。
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert-popup-menu</title>
<type>Function</type>
<arguments>insert-popup-menu MENU POSITION POPUP-MENU MENU-NAME</arguments>
<package>editor</package>
<description>
ポップアップメニューをメニューの所定の位置に挿入します。

  MENU       : 追加先のメニューを指定します。
  POSITION   : 挿入する位置を指定します。
  POPUP-MENU : 追加するポップアップメニューを指定します。
  NAME       : メニューに表示される名前を指定します。

使用例：
  ;;; 右クリックメニューを標準のメニューに追加してみる。
  (insert-popup-menu *app-menu* 2 *app-popup-menu* "編集2(&amp;E)")
  =&gt; #&lt;menu 48701736&gt;
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert-menu-item</title>
<type>Function</type>
<arguments>insert-menu-item MENU POSITION TAG ITEM &amp;optional COMMAND INIT</arguments>
<package>editor</package>
<description>
メニュー項目を作成しメニューの所定の位置に挿入します。

  MENU     : 追加先のメニューを指定します。
  POSITION : 挿入する位置を指定します。
  TAG      : 識別するタグを指定します。必要なければnilを指定します。
  ITEM     : メニューに表示される名前を指定します。
  COMMAND  : メニューの項目が選択されたときに実行するコマンドを指定します。
  INIT     : メニューが開く直前に評価し返される値によってメニューの状態
             を設定します。詳細はadd-menu-itemを参照して下さい。
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>insert-menu-separator</title>
<type>Function</type>
<arguments>insert-menu-separator MENU POSITION &amp;optional TAG</arguments>
<package>editor</package>
<description>
セパレータをメニューの所定の位置に挿入します。

  MENU     : 追加先のメニューを指定します。
  POSITION : 挿入する位置を指定します。
  TAG      : 識別するタグを指定します。
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-menu</title>
<type>Function</type>
<arguments>delete-menu MENU TAG-OR-POSITION &amp;optional TAG-OR-POSITION-P</arguments>
<package>editor</package>
<description>
メニューから項目等を削除します。

  MENU              : 削除するメニューを指定します。
  TAG-OR-POSITION   : タグもしくは位置を指定します。
  TAG-OR-POSITION-P : TAG-OR-POSITIONの引数をタグとして解釈するか位置として解釈するかを決めます。
           nil     TAG-OR-POSITIONはタグを表すシンボル
           non-nil TAG-OR-POSITIONは位置を表す整数値
  
タグを指定した場合にはメニューを再帰的に検索し最初に見つかった項目を削除
します。 タグが存在しない場合やメニュー項目数以上の位置を指定した場合に
は、削除に失敗します。

戻り値は以下のとおりです。

  t   削除に成功した。
  nil 削除に失敗した。
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-menu-position</title>
<type>Function</type>
<arguments>get-menu-position MENU TAG</arguments>
<package>editor</package>
<description>
メニューの中からタグの位置を検索して返します。

  MENU : 検索するメニューを指定します。
  TAG  : 検索するタグを指定します。

見つからなかった場合にはnilが返されます。
見つかった場合にはその位置とそれを含むメニューを返します。
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-menu-items</title>
<type>Function</type>
<arguments>copy-menu-items OLD-MENU NEW-MENU</arguments>
<package>editor</package>
<description>
old-menuの構造をnew-menuにトップレベルでコピーします。

亀井さん談：
  ちなみにバグってます。old-menuとnew-menuが同じ場合のことを何も考えていません。
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-menu</title>
<type>Function</type>
<arguments>set-menu MENU</arguments>
<package>editor</package>
<description>
指定されたメニューをデフォルトのメニューにします。xyzzy上部に常時表示さ
れるようになります。

  MENU : 設定するメニューを指定します。
         メニューが不要ならばnilを指定します。
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>use-local-menu</title>
<type>Function</type>
<arguments>use-local-menu MENU</arguments>
<package>editor</package>
<description>
カレントバッファにローカルなメニューを設定します。

  MENU : バッファにローカルなメニューを指定します。nilを設定するとローカ
         ルなメニューは解除され、デフォルトのメニューが使用されます。
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>track-popup-menu</title>
<type>Function</type>
<arguments>track-popup-menu MENU &amp;optional ANY</arguments>
<package>editor</package>
<description>
フローティングポップアップメニューを表示します。選択されたコマン
ドを実行します。マウスボタンが押されていない場合はnilを返します。

  MENU : create-popup-menuもしくはdefine-popup-menuで作成された
         メニューを指定します。
  ANY  : どのようにポップアップするかを指定できます。
        :button1        マウスの位置にポップアップ
        :button2        マウスの位置にポップアップ
        上記以外        カーソルの位置にポップアップ
</description>
<seealso>create-popup-menu</seealso>
<seealso>define-popup-menu</seealso>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>menup</title>
<type>Function</type>
<arguments>menup OBJECT</arguments>
<package>editor</package>
<description>
オブジェクトがメニューかどうかを返します。

  OBJECT : 判定するオブジェクト

  t   オブジェクトはメニュー
  nil オブジェクトはメニューではない
</description>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>define-menu</title>
<type>Macro</type>
<arguments>define-menu &amp;body BODY</arguments>
<package>editor</package>
<description>
固定的なメニューを定義します。
定義方法はdefine-popup-menuを参照して下さい。動的にメニューを生成した場
合にはcreate-menuを参照して下さい。define-menuで生成したメニューも
add-menu-itemやinsert-menu-itemなどで項目を追加することも可能です。
</description>
<seealso>define-popup-menu</seealso>
<section>メニュー</section>
<file>menu.l</file>
</chapter>

<chapter>
<title>define-popup-menu</title>
<type>Macro</type>
<arguments>define-popup-menu &amp;body BODY</arguments>
<package>editor</package>
<description>
固定的なポップアップメニューを定義します。

  BODY : メニューの定義を記述します。

BODYをインチキなBNFで書くと以下の様になります。

  POPUP-DEF : {MENU-ITEM}*

  MENU-ITEM : :sep
            : (:sep [TAG])
            | (:separator [TAG])
            | (:popup tag name {POPUP-DEF}*)
            | (:item tag name [COMMAND [INIT]])

  TAG       : メニュー項目を識別する任意のオブジェクトです。
              タグ同士はeqで比較されます

  COMMAND   : メニュー項目が選択されたときに実行されるコマンドです。

  INIT      : メニューが開く直前に評価され、返される値によってメニューの
              状態が設定されます。任意のS式が指定できますが、あまり無茶
              なことはしないでください。式の値として意味のある値には以下
              のものがあります。

        :modified     カレントバッファが変更されていなければ灰色表示
        :undo         undo不可能であれば灰色表示
        :redo         redo不可能であれば灰色表示
        :selection    カレントバッファのテキストが未選択であるか矩形選択
                      であれば灰色表示
        :rectangle    カレントバッファのテキストが未選択であるか矩形以外
                      の選択であれば灰色表示
        :clipboard    クリップボードが空であれば灰色表示
        :check        チェック
        :disable      灰色表示
        その他        使用可能

使用例：
  ;;; niftylog.l
  (define-popup-menu
    (:item nil "メッセージを読んだことにする(&amp;R)"
     'log-read-article)
    (:item nil "メッセージを読んでないことにする(&amp;N)"
     'log-unread-article)
    (:item nil "スレッドを読んだことにする(&amp;T)"
     'log-read-thread)
    (:item nil "スレッドを読んでないことにする(&amp;H)"
     'log-unread-thread)
    (:item nil "ニュースグループを読んだことにする(&amp;G)")
    (:item nil "ニュースグループを読んでないことにする(&amp;P)"))
  =&gt; #&lt;menu 48698340&gt;
</description>
<section>メニュー</section>
<file>menu.l</file>
</chapter>

<chapter>
<title>add-hook</title>
<type>Function</type>
<arguments>add-hook HOOK FN &amp;optional APPEND</arguments>
<package>editor</package>
<description>
フック変数に関数を追加します。

  HOOK : フック変数のシンボルを指定します。
  FN   : 関数のシンボルを指定します。

フックとは特定の処理においてユーザが望む処理を追加するための仕組みです。
xyzzyには「ユーザが修正したいだろうなぁ」と思うところにフックが仕掛けら
れています。例えば「find-fileするときには何か関数を実行したい」と思った
ら、「find-fileを上書き」したり、「xxx-find-fileを作ったり」するのではな
く、その用途に使えるフック変数がないかどうかを確認しましょう。

下の例はfind-fileする時にfunc1とfunc2を呼び出して何らかの処理をする例です。

  【準備処理】
        ;;; find-fileで呼び出される*before-find-file-hook*に
        ;;; ユーザが作った関数func1とfunc2が呼び出されるように登録する。
        (add-hook '*before-find-file-hook* 'func1)
        (add-hook '*before-find-file-hook* 'func2)

  【find-file実行時】
        ;;; find-fileを実行すると、ファイルの読み込みの前で
        ;;; *before-find-file-hook*に登録されている関数が実行される。
        (find-file ...)
          └(run-hooks '*before-find-file-hook*)
              ├(func1)
              └(func2)

  【後片付け】
        ;;; find-fileで呼び出される*before-find-file-hook*から
        ;;; ユーザが作った関数func1とfunc2を取り除く
        (delete-hook '*before-find-file-hook* 'func1)
        (delete-hook '*before-find-file-hook* 'func2)

なお、フック変数は用途に応じて呼び出され方や戻す値の意味が異なります。注
意しましょう。

使用例：
  ;;; lispmode.l
  (add-hook '*query-kill-buffer-hook* 'kill-scratch-hook)
</description>
<seealso>delete-hook</seealso>
<seealso>run-hooks</seealso>
<seealso>フック変数</seealso>
<section>モード</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>run-hooks</title>
<type>Function</type>
<arguments>run-hooks &amp;rest HOOKLIST</arguments>
<package>editor</package>
<description>
フック変数を順番に実行します。フック変数の詳細はadd-hookを参照して下さい。

  HOOKLIST : フック変数を指定します。複数個並べて書けます。
             並べて書いた順番に実行します。

フック変数の実行には引数をつけることが出来ません。
どうしてもつけたい場合には、run-hook-with-argsを使いましょう。

使用例：
  ;;; c-mode.l
  (run-hooks 'c-mode-hook)
</description>
<seealso>run-hook-with-args</seealso>
<seealso>run-hook-with-args-until-success</seealso>
<seealso>run-hook-with-args-while-success</seealso>
<seealso>フック変数</seealso>
<section>モード</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>autoload</title>
<type>Function</type>
<arguments>autoload FN FILE &amp;optional COMMANDP MACROP</arguments>
<package>lisp</package>
<description>
関数が呼び出された時点でファイルをロードするよう宣言します。

  FN       : 関数シンボルを指定します。
  FILE     : ロードするファイルを指定します。
  COMMANDP : 実行するときにinteractiveに実行するかどうかを指定します。
  MACROP   : マクロかどうかを指定します。

関数を呼び出す側からは、元々そのファイルがロードされていたかのように実行
を続けます。めったに使わない関数をautoloadで宣言しておくとメモリ消費量を
節約できます。また、起動が速くなります。

使用例：
  ;;; defs.lより
  (autoload 'search-dialog "dialogs" t)
  (autoload 'replace-dialog "dialogs" t)
  (autoload 'count-matches-dialog "dialogs" t)
  (autoload 'goto-line-dialog "dialogs" t)
  (autoload 'open-file-dialog "dialogs" t)

--- muleの説明 ---

Function: autoload symbol filename &amp;optional docstring interactive macro

この関数は、(filename からオートロードするよう) symbol で名付けられた関
数 (もしくはマクロ)を定義します。 filename は、この関数を呼ぶ時 load に
渡すパス名です。 

docstring は、この関数用のドキュメンテーションです。これは(通常)この関数
の関数定義中のものと同じストリングになります。 

interactive が non-nil の場合、この関数はインタラクティブに呼ばれます。 
(ここでは)完全な interactive specification を与える必要はありません。 
macro が non-nil の場合、この関数は(実は)マクロです。 

symbol がすでに non-nil の関数セルを持つ場合、 autoload は(何もせず) nil 
を返します。 (関数セルが) void の場合、 symbol の関数セルに (autoload 
filename docstring interactive macro ) というオートロードフォームを設定
します。 

symbol の名前の関数を呼ぶと、(まず)オートロードフォームが評価され、 
filename の名前のファイルが load でロードされます。 (この後) symbol の関
数セルは Lisp 関数かマクロを指すことになります。そうならない場合、エラー
になります。 

(内容の評価でエラーが生じ) ファイルの評価が完全に行なえなかった場合、ロ
ード中に行なわれた関数定義や provide 呼び出しは undone されます(訳注：取
り消されます)。これは、(エラーを直した後)再び autoload できるようにする
ためです。 
</description>
<seealso>各種ロード関係の関数の違い</seealso>
<section>関数</section>
</chapter>

<chapter>
<title>define-history-variable</title>
<type>Macro</type>
<arguments>define-history-variable NAME &amp;optional (INITIAL-VALUE nil sv) DOC</arguments>
<package>editor</package>
<description>
ヒストリ変数を定義します。

  NAME          : ヒストリ変数名を指定します。
  INITIAL-VALUE : 初期値を設定します。
  DOC           : 変数の説明を指定します。

ヒストリ変数とは、次回のxyzzyの立ち上げまで値を保持してくれる(lispを書く
人には)便利な変数です。ヒストリ変数がないと各マクロごとに独自の保存方法
をとらないといけませんが、ヒストリ変数のおかげで宣言するだけで変数の状態
を保存することが可能な優れものです。

ただし、一旦作成したヒストリ変数はいつまでも残ってしまうので、
不要になったらed::*history-variable-list*を確認した上で、
unregister-history-variableで削除して下さい。

使用例：
  ;;; grepd.lより
  (define-history-variable *grep-directory-history* nil)
  (define-history-variable *grep-file-history* nil)
</description>
<seealso>unregister-history-variable</seealso>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>ed::map-selection</title>
<type>Function</type>
<arguments>map-selection FN</arguments>
<description>
セレクションの開始位置と終了位置を引数にして関数を呼び出します。

  FN : 呼び出す関数を指定します。呼び出し時には開始位置と終了位置を渡し
       ますので、そのような関数のI/Fにしておかなければなりません。

使用例：
  ;;;
  (defun map-test ()
    (interactive)
    (ed::map-selection #'(lambda (start end) (message (format nil "~s ~s" start end)))))

補足：
  editorパッケージからエクスポートされてないので、ed::をつける必要があります。
  選択の開始位置と終了位置を正確に渡すので、前後関係に注意して下さい。
</description>
<section>ポジション</section>
<file>select.l</file>
</chapter>

<chapter>
<title>tab-columns</title>
<type>Function</type>
<arguments>tab-columns &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
タブ幅を返します。タブ幅はset-tab-columnsで設定できます。

  BUFFER : タブ幅を返すバッファを指定します。
           指定がなければカレントバッファが対象となります。
</description>
<seealso>set-tab-columns</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-tab-columns</title>
<type>Function</type>
<arguments>set-tab-columns COLUMN &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
タブ幅を設定します。

  COLUMN : タブ幅を指定します。1以上32以下の任意の整数です。
           2のべき乗である必要はありません。
  BUFFER : タブ幅を変更するバッファを指定します。
           指定がなければカレントバッファが対象になります。
</description>
<seealso>tab-columns</seealso>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>skip-chars-forward</title>
<type>Function</type>
<arguments>skip-chars-forward CHARS</arguments>
<package>editor</package>
<description>
指定された文字群を前方方向にスキップします。

  CHARS : スキップする文字群を指定します。

skip-syntax-spec-forwardも似た動作をしますが、これはバッファのシンタック
ステーブルを見てスキップする文字を判断します。目的がはっきりしていれば、
skip-chars-forwardを使用しましょう。

使用例：
  ;;; 半角空白とタブ文字をスキップします。
  (skip-chars-forward " \t")
</description>
<seealso>skip-chars-backward</seealso>
<seealso>skip-syntax-spec-forward</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>skip-chars-backward</title>
<type>Function</type>
<arguments>chars</arguments>
<package>editor</package>
<description>
skip-chars-forwardの後ろ向きのものです。
</description>
<seealso>skip-chars-forward</seealso>
<seealso>skip-syntax-spec-backward</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>skip-syntax-spec-backward</title>
<type>Function</type>
<arguments>skip-syntax-spec-backward SYNTAX-SPEC</arguments>
<package>editor</package>
<description>
skip-syntax-spec-forwardの後ろ向きのものです。
</description>
<seealso>skip-syntax-spec-forward</seealso>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>skip-syntax-spec-forward</title>
<type>Function</type>
<arguments>skip-syntax-spec-forward SYNTAX-SPEC</arguments>
<package>editor</package>
<description>
シンタックステーブルのカテゴリ基づいて文字を前方方向にスキップします。

skip-syntax-spec-(for|back)ward は、シンタックステーブルで指定
される文字のカテゴリに基づいて、指定されたカテゴリに属する文字
をスキップする関数です。カテゴリを表す文字は以下の通りです(7 割
ぐらいは Emacs と互換性あり)。

;  ' '(スペース)  空白文字
;  .              記号
;  (              開き括弧
;  )              閉じ括弧
;  $              TeX の $
;  "              文字列の区切り
;  &lt;             1 文字コメントの開始
;  &gt;             1 文字コメントの終了
;  /              C++ の // コメントの終了
;  \              エスケープ文字
;  '              単独で現れたときは記号、シンボルに隣接している場合はシンボル
;  _              シンボルを構成する文字
;  w              単語を構成する文字
;  k              いわゆる半角カナ
;  j              漢字
;  x              ゴミ文字
;  {              タグの開始
;  }              タグの終了

最初に '^' を指定すると、指定したカテゴリ以外という意味になりま
す(正規表現の[^...]と同じ)。カレントバッファのシンタックステー
ブルに基づくので、バッファのモードによって動きが変わってきます。
ちなみに、単語を構成する文字は一般に英数字で、シンボルを構成す
る文字は単語を構成する文字以外で識別子に使えそうな文字という意
味です。

文字の並びには意味はありません。"w_" と"_w" は同じものを意味します。

使用例：
  ;;; ワードの区切りに移動・英字
  (skip-syntax-spec-forward "w_")

  ;;; ワードの区切りに移動・漢字
  (skip-syntax-spec-forward "jk_")
</description>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-horizontal-spaces</title>
<type>Function</type>
<arguments>delete-horizontal-spaces NIL</arguments>
<package>editor</package>
<description>
同一行内のカーソル位置の前後の空白を削除します。
</description>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>indent-to</title>
<type>Function</type>
<arguments>indent-to COLUMN</arguments>
<package>editor</package>
<description>
指定された桁数までインデントします。現在のカーソル位置が引数より小さけれ
ばスペースを挿入します。そうでなければ何もしません。

  COLUMN : インデントする桁数を指定します。

戻り値は以下のとおりです。

  t   インデントした場合
  nil 何もしなかった場合
</description>
<section>テキスト</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>plain-error</title>
<type>Function</type>
<arguments>plain-error &amp;rest REST</arguments>
<package>lisp</package>
<description>
（詳細不明）
</description>
<section>エラー</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>directory</title>
<type>Function</type>
<arguments>PATHNAME &amp;key :ABSOLUTE :RECURSIVE :WILD :DEPTH :FILE-ONLY :SHOW-DOTS :COUNT :DIRECTORY-ONLY :CALLBACK</arguments>
<package>lisp</package>
<description>
対象ディレクトリ下のファイル名をリストで得ます。

  PATHNAME        : 検索するディレクトリのパスです。
  :ABSOLUTE       : 検索結果をフルパスで取得します。
  :RECURSIVE      : サブディレクトリも対象とするかを制御します。
        t               サブディレクトリの中まで検索
        nil             サブディレクトリの中までは検索しない
  :WILD           : ワイルドカード指定です。リストでも可です。
  :DEPTH          : :RECURSIVE指定するときの再帰の深さです。
  :FILE-ONLY      : ファイルしか検索しません。
  :SHOW-DOTS      : ディレクトリとして"./"と"../"を加えます。
  :COUNT          : 表示されるファイルの個数を制限します。
  :DIRECTORY-ONLY : ディレクトリしか検索しません。
  :CALLBACK       : 見つかったファイルを引数にしてfuncallします。
                    funcallした結果をリストにして返します。
  :FILE-INFO      : ファイルの属性を取得します。
                    get-file-infoで取得できるものと同じです。

使用例：
  ;;;  "../"は出したいけど、"./"を出したくない場合
  (delete "./" (directory ... :show-dots t) :test #'string=)

  ;;; "C:/"の配下を一覧表示する。
  (directory "C:/" :callback #'(lambda (x) (print x)))

  ;;; ファイル名のソート（大文字小文字区別有り）
  (sort (directory ...) #'string&lt;)

  ;;; ファイル名のソート（大文字小文字区別有り）
  (sort (directory ...) #'string-lessp)
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>default-directory</title>
<type>Function</type>
<arguments>default-directory &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファが作業しているディレクトリを返します。

  BUFFER : バッファを指定します。
           指定がなければカレントバッファになります。

そのバッファでfind-file するときに最初に表示されるディレクトリのことです。
このディレクトリは M-x: cd や set-default-directoryで変更することができ
ます。

使用例：
  ;;; デフォルトディレクトリを移動してみる。
  (default-directory)
  =&gt; "C:/applications/xyzzy/site-lisp/"
  (cd "../..")
  =&gt; t
  (default-directory)
  =&gt; "C:/applications/"
</description>
<seealso>set-default-directory</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-default-directory</title>
<type>Function</type>
<arguments>directory &amp;optional buffer</arguments>
<package>editor</package>
<description>
バッファが作業しているディレクトリを変更します。

  DIRECTORY : ディレクトリを指定します。
  BUFFER    : バッファを指定します。
              指定がなければカレントバッファになります。
</description>
<seealso>default-directory</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-clipboard-data</title>
<type>Function</type>
<arguments>get-clipboard-data NIL</arguments>
<package>editor</package>
<description>
クリップボードの内容を文字列として取り出します。
</description>
<seealso>copy-to-clipboard</seealso>
<section>システム</section>
<file>select.l</file>
</chapter>

<chapter>
<title>copy-region-to-clipboard</title>
<type>Function</type>
<arguments>copy-region-to-clipboard FROM TO</arguments>
<package>editor</package>
<description>
指定されたリージョンをクリップボードにコピーします。

  FROM : リージョンの開始位置を指定します。
  TO   : リージョンの終了位置を指定します。
</description>
<section>システム</section>
<file>region.l</file>
</chapter>

<chapter>
<title>copy-to-clipboard</title>
<type>Function</type>
<arguments>copy-to-clipboard STRING</arguments>
<package>editor</package>
<description>
指定された文字列をクリップボードにコピーします。

  STRING : クリップボードにコピーする文字列を指定します。
</description>
<seealso>get-clipboard-data</seealso>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*kill-ring*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
killした文字列を格納します。
*kill-ring*は長さが*kill-ring-max*であるリングバッファです。
</description>
<section>テキスト</section>
<file>region.l</file>
</chapter>

<chapter>
<title>*kill-ring-max*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
killで保存する個数です。*kill-ring*の長さです。
</description>
<section>テキスト</section>
<file>region.l</file>
</chapter>

<chapter>
<title>*quotation-prefix*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
引用を表す接頭子です。具体的には、quote-regionしたときにリージョンの行頭
に挿入する文字列です。

参考：
  ;;; 初期値ではこんなものが設定されています。
  (defvar *quotation-prefix* "| ")
</description>
<section>テキスト</section>
<file>region.l</file>
</chapter>

<chapter>
<title>quote-region</title>
<type>Function</type>
<arguments>quote-region FROM TO</arguments>
<package>editor</package>
<description>
指定されたリージョンの先頭に引用を表す接頭子を挿入します。
引用を表す接頭子として*quotation-prefix*を挿入します。
</description>
<section>テキスト</section>
<file>region.l</file>
</chapter>

<chapter>
<title>current-column</title>
<type>Function</type>
<arguments>current-column NIL</arguments>
<package>editor</package>
<description>
現在の桁位置を返します。
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-window-handle</title>
<type>Function</type>
<arguments>get-window-handle &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
指定されたウィンドウのハンドルを返します。

  WINDOW : ハンドルを返すウィンドウを指定します。

使用例：
  ;;; カーソルがあるウィンドウのハンドルを返します。
  (get-window-handle (selected-window))
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-char</title>
<type>Function</type>
<arguments>read-char &amp;optional INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P</arguments>
<package>lisp</package>
<description>
指定された入力ストリームから一文字読み込んで、文字を返します。

  INPUT-STREAM : 入力ストリーム
  EOF-ERROR-P  : EOFの状態でread-charしたときにどうするか？
        t               エラーとする。
        nil             エラーとせず、nilを返します。
  EOF-VALUE    : EOFの状態でread-charしたときにnilの代わりに返す文字を指定します。
  RECURSIVE-P  : （詳細不明）

使用例：
  (read-char *keyboard*) &lt;-- "a"を入力
  =&gt; #\a

補足：
  蛇足ですが、EOFはEnd Of Fileの略です。ファイルやストリームをすっかり読
  み終わってしまった状態を指します。

---- Common Lisp ------
Description: reads one character from the current stream and returns it 
as an object. If end of file is encountered, the operation of read-char 
is determined by the eof-error-p and eof-value arguments (see read).
</description>
<seealso>read-char-no-hang</seealso>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>write-registry</title>
<type>Function</type>
<arguments>write-registry SECTION KEY VALUE</arguments>
<package>editor</package>
<description>
レジストリに書き込みます。

  SECTION : セクションを指定します。
  KEY     : キーを指定します。
  VALUE   : 値を指定します。

使用例：
  ;;; HKCT\software\freesoftware\xyzzyの下にデータを書き込む
  (write-registry "software\\chombo\\altime" "aaa" 64 )
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>read-registry</title>
<type>Function</type>
<arguments>read-registry SECTION KEY &amp;optional ROOT</arguments>
<package>editor</package>
<description>
レジストリから読み込みます。

  SECTION : セクションを指定します。
  KEY     : キーを指定します。
  ROOT    : （詳細不明）

使用例：
  ;;; HKEY_CURRENT_USER/software/Microsoft/devstudio/5.0/Recent File List/project1 の値を読む
  (read-registry "software\\Microsoft\\devstudio\\5.0\\Recent File List" "project1"  :current-user)
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>call-interactively</title>
<type>Function</type>
<arguments>call-interactively FN</arguments>
<package>editor</package>
<description>
指定された関数をinteractiveに呼び出したかのごとく実行します。

  FN : interactiveに呼び出す関数を指定します。
       (interactive ...)として宣言された関数でなければなりません。

使用例：
  ;;; find-fileを無引数で呼び出してもエラーになる。
  (find-file)
  =&gt; 引数が少なすぎます: (find-file)

  ;;; interactiveに呼び出すと大丈夫
  (call-interactively 'find-file)
  =&gt; Find file: C:/applications/xyzzy/
</description>
<section>その他</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>get-windows-directory</title>
<type>Function</type>
<arguments>get-windows-directory NIL</arguments>
<package>editor</package>
<description>
Windowsフォルダへのパスを返します。

使用例：
  (get-windows-directory)
  =&gt; "C:/WINDOWS/"
</description>
<section>システム</section>
<seealso>get-system-directory</seealso>
<seealso>get-special-folder-location</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-system-directory</title>
<type>Function</type>
<arguments>get-system-directory NIL</arguments>
<package>editor</package>
<description>
Windowsシステムフォルダまでのパスを返す。

使用例：
  (get-system-directory)
  =&gt; "C:/WINDOWS/System32/"
</description>
<section>システム</section>
<seealso>get-windows-directory</seealso>
<seealso>get-special-folder-location</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-special-folder-location</title>
<type>Function</type>
<arguments>get-special-folder-location PLACE</arguments>
<package>editor</package>
<description>
いろいろなフォルダへのパスを返します。

  PLACE : フォルダの種類を指定します。
    :start-menu
    :send-to
    :desktop
    :personal
    :programs
    :recent
    :startup
    :templates

参考：
  WindowsAPIのGetSpecialFolderLocation
</description>
<section>システム</section>
<seealso>get-windows-directory</seealso>
<seealso>get-system-directory</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>user-name</title>
<type>Function</type>
<arguments>user-name NIL</arguments>
<package>editor</package>
<description>
Windowsのログオンユーザー名を返します。
</description>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>current-line-number</title>
<type>Function</type>
<arguments>current-line-number NIL</arguments>
<package>editor</package>
<description>
現在の物理行の行番号を返します。
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>do-all-symbols</title>
<type>Macro</type>
<arguments>do-all-symbols (VAR &amp;optional RESULT-FORM) &amp;body BODY</arguments>
<package>lisp</package>
<description>
全シンボルを列挙します。

  VAR         : 列挙されたシンボルを格納する変数名を指定します。
  RESULT-FORM : （詳細不明）
  BODY        : 実行するフォームを指定します。

使用例：
  ;;; シンボルを列挙して変数・関数・マクロ・パッケージを出力してみる。
  (do-all-symbols (sym)
    (and (or (boundp sym)
             (fboundp sym))
         (format t "~:[ ~;V~]~:[ ~;F~]~:[ ~;M~] ~A ~S~%"
                 (boundp sym)
                 (fboundp sym)
                 (macro-function sym)
                 (package-name (symbol-package sym))
                 sym)))
</description>
<section>パッケージ</section>
<seealso>with-package-iterator</seealso>
<file>package.l</file>
</chapter>

<chapter>
<title>with-package-iterator</title>
<type>Macro</type>
<arguments>with-package-iterator (MNAME PACKAGE-LIST &amp;rest SYMBOL-TYPE) &amp;body BODY</arguments>
<package>lisp</package>
<description>
指定されたパッケージのシンボルを列挙する関数を作ってもらいます。
作られた関数を呼び出すたびにシンボルが列挙されます。

  MNAME        : シンボルを返す関数名を指定します。
  PACKAGE-LIST : パッケージのリストを指定します。
  SYMBOL-TYPE  : どんなシンボルを返すかを指定するようです。

使用例：
  ;;; 全シンボルを列挙します。
  ;;; 呼ぶたびに次のシンボルを返すfooという関数を定義してもらう。
  (with-package-iterator (foo (list-all-packages) :internal :external)
    (loop
      (multiple-value-bind (f sym type package)
          (foo)             ; 呼ぶと次のシンボルが返ってくる。
        (unless f           ; なければ終わり。
          (return))
        (and (or (boundp sym)
                 (fboundp sym))
             (format t "~:[ ~;V~]~:[ ~;F~]~:[ ~;M~] ~A ~S ~S~%"
                     (boundp sym)
                     (fboundp sym)
                     (macro-function sym)
                     (package-name package)
                     sym
                     type)))))
</description>
<section>パッケージ</section>
<seealso>do-all-symbols</seealso>
<file>package.l</file>
</chapter>

<chapter>
<title>si:closure-variable</title>
<type>Function</type>
<arguments>si:closure-variable CLOSURE</arguments>
<package>System</package>
<description>
クロージャの中身を覗くための関数です。

  CLOSURE : レキシカルクロージャもしくは関数定義に
            レキシカルクロージャを持つシンボルを指定します。

以下の関数でクロージャを参照することが可能です。

  si:closure-variable closure
  si:closure-function closure
  si:closure-frame closure
  si:closure-body closure

使用例：
  (setq foo (let ((x 3)) #'(lambda () (incf x) x)))
  =&gt; #&lt;lexical-closure: (anonymous)&gt;
  (funcall foo)
  =&gt; 4
  (funcall foo)
  =&gt; 5
  (si:closure-variable foo)
  =&gt; ((x . 5))
</description>
<section>その他</section>
</chapter>

<chapter>
<title>process-send-string</title>
<type>Function</type>
<arguments>process-send-string PROCESS STRING</arguments>
<package>editor</package>
<description>
プロセスに文字列を送ります。

  PROCESS : 文字列を送りつけるプロセスを指定します。 
  STRING  : 送りつける文字列を指定します。

使用例：
  ;;; sort.exeを起動して、"abc" "aab" "aac"を送りつける。
  (setq proc (make-process "sort"))
  =&gt; #&lt;process 135271372&gt;
  (process-send-string proc "abc\n") =&gt; t
  (process-send-string proc "aab\n") =&gt; t
  (process-send-string proc "aac\n") =&gt; t
  (process-send-string proc "^Z")    =&gt; t
  aab
  aac
  abc
</description>
<seealso>make-process</seealso>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*eol-cr*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
改行コードのCRを表す値です。
プロセスやバッファの入出力の改行コードを設定するのに使用します。
</description>
<seealso>*eol-lf*</seealso>
<seealso>*eol-crlf*</seealso>
<link></link>
<section>入出力</section>
<file>encoding.l</file>
</chapter>

<chapter>
<title>*eol-crlf*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
改行コードのCRLFを表す値です。
プロセスやバッファの入出力の改行コードを設定するのに使用します。
</description>
<seealso>*eol-cr*</seealso>
<seealso>*eol-lf*</seealso>
<link></link>
<section>入出力</section>
<file>encoding.l</file>
</chapter>

<chapter>
<title>*eol-lf*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
改行コードのLFを表す値です。
プロセスやバッファの入出力の改行コードを設定するのに使用します。
</description>
<seealso>*eol-cr*</seealso>
<seealso>*eol-crlf*</seealso>
<link></link>
<section>入出力</section>
<file>encoding.l</file>
</chapter>

<chapter>
<title>make-process</title>
<type>Function</type>
<arguments>make-process COMMAND-LINE &amp;key :ENVIRON :OUTPUT :EXEC-DIRECTORY :INCODE :OUTCODE :EOL-CODE</arguments>
<package>editor</package>
<description>
プロセスを起動します。

  COMMAND-LINE    : 実行するコマンドをオプション付で指定します。
  :ENVIRON        : 設定する環境変数を連想リスト形式で渡します。
                    (("HOME" . "C:/applications/xyzzy/")
                     ("TOPDIR" . "C:/spool/"))
  :OUTPUT         : プロセスの標準出力を出力するバッファを指定します。
  :EXEC-DIRECTORY : 実行するディレクトリを指定します。
  :INCODE         : プロセスの入力の文字コードを指定します。
  :OUTCODE        : プロセスの出力の文字コードを指定します。
  :EOL-CODE       : 改行コードを指定します。

プロセスへの入力はprocess-send-stringを使用します。
プロセスはバッファに関連付けられ、プロセスの出力がバッファにそのまま出力されます。
また、環境変数や出力先等を変更できます。

参考：
  [xyzzy:02210]山本真二さん
  call-process または別の組み込み関数で、標準入力、標準出力、標準エラー
  出力を直接バッファに繋ぐようにした方が早くてかっこいいと思うのですが、
  難しいですか？

  (make-process *eshell* :output (selected-buffer))
  (process-send-string (buffer-process (selected-buffer))
                       (concatenate 'string cmd *shell-ret*))
</description>
<seealso>call-process</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>call-process</title>
<type>Function</type>
<arguments>call-process COMMAND-LINE &amp;key :ENVIRON :NO-STD-HANDLES :INPUT :OUTPUT :ERROR :EXEC-DIRECTORY :SHOW :WAIT</arguments>
<package>editor</package>
<description>
外部プログラムを実行します。完全にxyzzyの外部でプログラムを実行します。

  COMMAND-LINE    : 実行するコマンドをオプション付で指定します。
  :ENVIRON        : 設定する環境変数を連想リスト形式で渡します。
                    (("HOME" . "C:/applications/xyzzy/")
                     ("TOPDIR" . "C:/spool/"))
  :NO-STD-HANDLES : （詳細不明）
  :INPUT          : 標準入力を使用する外部プログラムであれば入力ファイル名を指定します。
  :OUTPUT         : 標準出力を使用する外部プログラムであれば出力ファイル名を指定します。
  :ERROR          : （詳細不明）
  :EXEC-DIRECTORY : 実行するディレクトリを指定します。
  :SHOW           : 外部プログラムの実行時の大きさを指定します。
                    :minimize  最小化
                    :maximize  最大化
                    上記以外   通常のウィンドウ
  :WAIT           : 外部プログラムが終了するのを待ち合わせます。

使用例：
  ;;; notepad.exeの終了を待ち合わせてみる。
  (call-process "notepad" :wait t)
</description>
<section>プロセス</section>
<seealso>execute-shell-command</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>execute-shell-command</title>
<type>Function</type>
<arguments>execute-shell-command COMMAND &amp;optional INFILE OUTPUT ENVIRON DIRECTORY</arguments>
<package>editor</package>
<description>
外部プログラムを実行します。結果だけをxyzzyに取り込みます。

  COMMAND    : 実行するコマンドをオプション付で指定します。
  INFILE     : 標準入力を使用する外部プログラムであれば入力ファイル名を指定します。
  OUTPUT     : 標準出力を出力するバッファを指定します。
  ENVIRON    : 設定する環境変数を連想リスト形式で渡します。
                (("HOME" . "C:/applications/xyzzy/")
                 ("TOPDIR" . "C:/spool/"))
  DIRECTORY  : 実行するディレクトリを指定します。

call-processとは違って標準出力をバッファに出力します。出力するバッファは完
全に破壊されますので注意してください。

使用例：
  ;;; コマンドプロンプトのhelpを表示してみる。
  (execute-shell-command "help" nil (selected-buffer))
</description>
<section>プロセス</section>
<seealso>call-process</seealso>
<file>process.l</file>
</chapter>

<chapter>
<title>ファイル操作の例</title>
<type>Tips</type>
<arguments></arguments>
<description>
(defun find-modify-save-test (file)
  (interactive "f")
  (let (temp-buffer)
    (unwind-protect
        (progn
          ;; テンポラリのバッファを作って
          (setq temp-buffer (create-new-buffer "*foo*"))
          ;; カレントバッファにして
          (set-buffer temp-buffer)
          ;; ファイルを読み込む
          (insert-file-contents (merge-pathnames file *src-dir*))
          (goto-char (point-min))
          ;; ここでいろいろやる

          ;; ファイルに書く
          (write-file (merge-pathnames file *dst-dir*)))
      ;; バッファを作っていたら消す(kill-bufferはうるさいのでdelete-bufferで)
      (when temp-buffer
        (delete-buffer temp-buffer)))))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>create-archive</title>
<type>Function</type>
<arguments>create-archive ARCHIVE-FILE FILES BASE-DIRECTORY</arguments>
<package>editor</package>
<description>
アーカイブを作成します。

  ARCHIVE-FILE   : 作成/追加する書庫ファイル名を指定します。指定したファ
                   イルが存在すれば追加、なければ新規作成します。書庫フ
                   ァイルを作成するディレクトリを指定する場合は、フルパ
                   スで指定します。
  FILES          : アーカイブするファイルのリストを指定します。フルパス
                   で指定する必要があります。
  BASE-DIRECTORY : 基準となるディレクトリを指定します。

使用例：
  ;;; foo.lzh に c:/tmp/a.c, c:/tmp/b.c を追加します。
  (create-archive "foo.lzh"
                  '("c:/tmp/a.c" "c:/tmp/b.c")
                  "c:/tmp")
</description>
<seealso>extract-archive</seealso>
<seealso>delete-file-in-archive</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>パッケージ</title>
<type>Tips</type>
<arguments></arguments>
<description>
パッケージは簡単に言うと、いわゆる oblist とか obarray といったものが
いっぱいあって、リーダがシンボルを読んだときにどの obarray を使って
find-symbol や intern をするかを指定するものです。

さらに、一つのパッケージに 内部用と外部用の二つの obarray があり、通常
は内部用に intern されます。関数 export で、内部用から外部用に移動するこ
とができます。

内部用と外部用の違いは、パッケージを作るときに(作るときじゃなくてもい
いけど)他のパッケージを使用(use)すると宣言すると、ある名前を find-symbol
するときに、そのシンボルが指定されたパッケージに存在しない場合、そのパッ
ケージが使用しているパッケージの外部用にあるかを見にいくようになっています。

exportの仕組み：
  exportしても全部のパッケージから見えるわけじゃなくて、そのパッ
  ケージをuseしているパッケージから見えるようになるだけです。

  (package-use-list "user")
  =&gt; (#&lt;package: lisp&gt; #&lt;package: editor&gt;)

  (package-use-list "editor")
  =&gt; (#&lt;package: lisp&gt;)

  なので、editorパッケージから見えるのは、editorのシンボルとlispのexportさ
  れたシンボルだけです。
  ※「見える」というのはパッケージの修飾子なしで参照できるという意味合いです。
</description>
<section>パッケージ</section>
<seealso>パッケージの概要</seealso>
<file></file>
</chapter>

<chapter>
<title>パッケージの概要</title>
<type>Tips</type>
<arguments></arguments>
<description>
パッケージには外部から参照されるシンボル用の空間と、内部のシンボル用の空
間があります。シンボルは最初は内部に登録されます。exportすると外部に移動
させられます。
     system        lisp        editor        user
   ┌───┐   ┌───┐   ┌───┐   ┌───┐
   │s-exp │   │l-exp │   │e-exp │   │u-exp │ &lt;- 外部
   ├───┤   ├───┤   ├───┤   ├───┤
   │s-int │   │l-int │   │e-int │   │u-int │ &lt;- 内部
   └───┘   └───┘   └───┘   └───┘


通常は user で作業をしています。 user は lisp, editor を利用すると宣言し
ています。そのため、l-exp, e-exp, u-exp, u-int に登録されたシンボルをパ
ッケージの修飾子無しで参照できるようになっています（太枠の部分です）。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │s-exp │   ┃l-exp ┃   ┃e-exp ┃   ┃u-exp ┃ &lt;- 外部
   ├───┤   ┗━━━┛   ┗━━━┛   ┠───┨
   │s-int │   │l-int │   │e-int │   ┃u-int ┃ &lt;- 内部
   └───┘   └───┘   └───┘   ┗━━━┛


プログラムを書いて新しいシンボルが出てくると、u-int に登録されます。
(in-package "editor") を実行後にシンボルを書くと e-int に登録されます。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │      │   ┃      ┃   ┃      ┃   ┃      ┃ &lt;- 外部
   │ ...  │   ┃ ...  ┃   ┃ ...  ┃   ┃ ...  ┃
   ├───┤   ┗━━━┛   ┗━━━┛   ┠───┨
   │      │   │      │   │ bar  │   ┃ foo  ┃ 
   │ ...  │   │ ...  │   │ ...  │   ┃ ...  ┃ &lt;- 内部
   └───┘   └───┘   └───┘   ┗━━━┛
このあたりまでは分かりやすいと思うのですが、難しいのは「自分(editor)を
useしているパッケージ(user)に既にあるシンボル(foo)をexportしようとしてエ
ラーがでる」というトラブルです。


u-intとe-intのそれぞれにfooというシンボルを定義している状態を考えます。
この状態自体は問題ありませんが、この状態でeditor::fooをexportしようとす
るとエラーが発生します。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │      │   ┃      ┃   ┃  Ｘ  ┃   ┃      ┃ &lt;- 外部
   │ ...  │   ┃ ...  ┃   ┃ .↑  ┃   ┃ ...  ┃
   ├───┤   ┗━━━┛   ┗━│━┛   ┠───┨
   │      │   │      │   │ foo  │   ┃ foo  ┃ 
   │ ...  │   │ ...  │   │ ...  │   ┃ ...  ┃ &lt;- 内部
   └───┘   └───┘   └───┘   ┗━━━┛
user が参照可能な範囲からすると、u-intに既にあるシンボルと同じ名前のシン
ボルがe-expに入れられようとするため、「名前が衝突するためexportできませ
ん: editor::foo」と怒られます。

  (setq foo "user")
  =&gt; "user"
  (setq ed::foo "editor")
  =&gt; "editor"
  (export '(ed::foo) "ed")
  =&gt; 名前が衝突するためexportできません: editor::foo

これ以外にもこんな形でも起きます。lisp::fooとeditor::fooの間の問題のよう
ですが、実はuserがlispとeditorをuseしていることが原因です。
     system        lisp        editor        user
   ┌───┐   ┏━━━┓   ┏━━━┓   ┏━━━┓
   │      │   ┃ foo  ┃   ┃  Ｘ  ┃   ┃      ┃ &lt;- 外部
   │ ...  │   ┃ ...  ┃   ┃ .↑  ┃   ┃ ...  ┃
   ├───┤   ┗━━━┛   ┗━│━┛   ┠───┨
   │      │   │      │   │ foo  │   ┃      ┃ 
   │ ...  │   │ ...  │   │ ...  │   ┃ ...  ┃ &lt;- 内部
   └───┘   └───┘   └───┘   ┗━━━┛
</description>
<section>パッケージ</section>
<seealso>パッケージ</seealso>
<file></file>
</chapter>

<chapter>
<title>コマンドによりヒストリを変更するには？</title>
<type>Tips</type>
<arguments></arguments>
<description>
コマンド別にミニバッファのヒストリを管理する方法です。

  ;;; ヒストリのリスト
  (setq foo-history '("qux" "quux" "quuux"))
  
  ;;; 管理したいコマンド
  (defun foo ()
    (interactive)
    (list
     (let ((*minibuffer-default-history* foo-history)) ; ヒストリを設定する
       (prog1
         (completing-read
          "foo: "               ; プロンプト文字列
          '("foo" "bar" "baz")  ; 補完候補
          :must-match nil       ; 必ず補完候補にマッチしなきゃ駄目？
          :case-fold t)         ; 大文字小文字を区別する？
         ; 変更されたかもしれないから戻しておく
         (setq foo-history *minibuffer-default-history*)))))
</description>
<section>その他</section>
<file>search.l</file>
</chapter>

<chapter>
<title>dialog-box</title>
<type>Function</type>
<arguments>dialog-box TEMPLATE INITIAL-VALUE CHECK-OR-DISABLE</arguments>
<package>editor</package>
<description>
ダイアログボックスを表示します。ダイアログはdialogで定義されたものを使います。

  TEMPLATE :
      lispの形式で記述されたダイアログテンプレートを指定します。
      詳細は、関数dialogを参照してください。

  INITIAL-VALUE :
      エディトボックス等に入れる、文字列などを指定します。
      特に指定しない場合はnilでもかまいません。

  CHECK-OR-DISABLE :
      チェックボックス等の初期選択状態を指定します。
      特に指定しない場合はnilでもかまいません。

戻り値は、多値なので、multiple-value-bind等で受け取る必要があります。1番
目の戻り値は、cancelボタンが押されたらnil、okボタンが押されたらtが返ります。
  
使用例：
  ;;; テスト用のダイアログを定義します。
  (setq *test-dialog-template*
    `(dialog 0 0 300 100 
             (:caption "について")
             (:font 9 "ＭＳ Ｐゴシック")
             (:control
              (:static nil nil #x50020003 7 7 18 21)
              (:static nil ,(concat "XYZZY version "
                                    (software-version))
               #x50020000 34 7 92 8)
              (:static nil "Copyright (C) 1996, 97 T.Kamei"
               #x50020000 34 17 92 8)
              (:button IDOK "OK" #x50010001 52 35 36 14))))

  ;;; テスト用のダイアログを表示します。
  (defun test-dialog ()
    (interactive)
    (dialog-box *test-dialog-template* nil nil)
    t)
</description>
<seealso>dialog</seealso>
<section>ダイアログ</section>
<file>builtin.l</file>
</chapter>
  
<chapter>
<title>dialog</title>
<type>Function</type>
<arguments>dialog X Y W H &amp;rest CONTROLS</arguments>
<package>lisp</package>
<description>
ダイアログを定義します。

  X Y      : ダイアログの表示位置を指定します。
  W H      : ダイアログの大きさを指定します。
  CONTROLS : コントロールを指定します。

コントロールをxyzzyで作成するのは面倒なので、VisualC++のリソース作成画面
で、部品を配置して変換する方法が用意されています。新しくバッファを作って 
*.rcファイルから必要な部分を持ってきた後で、

  M-x convert-dialog-template-buffer

バッファ名を選択するとlisp形式に変換されます。
</description>
<seealso>dialog-box</seealso>
<section>ダイアログ</section>
<file></file>
</chapter>

<chapter>
<title>popup-string</title>
<type>Function</type>
<arguments>popup-string STRING POINT &amp;optional TIMEOUT</arguments>
<package>editor</package>
<description>
文字列をポップアップさせます。ツールチップのポップみたいな表示です。

  STRING  : ポップアップさせる文字列を指定します。
  POINT   : 文字列を表示する位置をポイントで指定します。
  TIMEOUT : 表示を止めるまでの秒数を指定します。
</description>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*wrap-search*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
文字列検索でバッファの最後までいったら、最初に戻るかどうかを制御します。

| search-forward-again で、バッファの最後まで行くと、最初に
| 戻って探しつづけますよね。
| あれって禁止できないでしょうか？

  (setq *wrap-search* nil)

とすればできますけど、たまに禁止したいとなるとちょっと面倒ですね。

| と言うか、それはそれで便利なんだけど、禁止したい時もあるんです。
| 「ここ以降にあるか無いか」と言うことを知りたい時とか・・・

現在位置から最後までを narrow してサーチするとか。
count-matches が 0 だったら無いとか。
検索ダイアログから指定するとか。
</description>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>set-local-window-flags</title>
<type>Function</type>
<arguments>set-local-window-flags BUFFER-OR-WINDOW FLAGS ON-OR-OFF</arguments>
<package>editor</package>
<description>
行番号の表示を制御します。

 BUFFER-OR-WINDOW : バッファかウィンドウのいずれかを指定します。
 FLAG             : 下のフラグのどれかを指定します。
        *window-flag-alternate-vscroll-bar*
        *window-flag-cursor-line*
        *window-flag-eof*
        *window-flag-fold-line*
        *window-flag-fold-mark*
        *window-flag-full-width-space*
        *window-flag-half-width-space*
        *window-flag-hscroll-bar*
        *window-flag-just-inverse*
        *window-flag-line-number*
        *window-flag-mode-line*
        *window-flag-newline*
        *window-flag-ruler*
        *window-flag-scrolling*
        *window-flag-tab*
        *window-flag-vscroll-bar*
        *window-flag-zenkaku-space*
 ON-OR-OFF       : 変更後の値を設定します。
        t        フラグをonにします。
        nil      フラグをoffにします。
        それ以外 デフォルトに戻します。

使用例：
  ;;; カレントバッファの行番号を表示しないようにする。
  (set-local-window-flags (selected-buffer)
                          *window-flag-line-number* nil)
</description>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>DOSのコマンドをキックして結果を文字列にするには？</title>
<type>Tips</type>
<arguments></arguments>
<description>
| DOSのコマンド(コンソールアプリって言ったほうがいいのかな？）
| をキックして、結果を文字列として、取り出す事はできますか？

こんな感じでしょうか。

(defun command-substitution (command)
  (let ((outfile nil)
        (buffer nil))
    (unwind-protect
        (save-excursion
          (setq buffer (create-new-buffer "*foo*"))
          (setq outfile (make-temp-file-name))
          (call-process command :output outfile :show :hide :wait t)
          (set-buffer buffer)
          (insert-file-contents outfile)
          (goto-char (1- (point-max)))
          (when (looking-for "\n")
            (delete-char 1))
          (goto-char (point-min))
          (replace-buffer "\n+" " " :regexp t)
          (buffer-substring (point-min) (point-max)))
      (and buffer
           (delete-buffer buffer))
      (and outfile
           (delete-file outfile)))))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>imagehdr</title>
<type>Function</type>
<arguments>imagehdr FILENAME</arguments>
<description>
指定された画像ファイルの縦・横・フォーマットを取得することが可能です。

使用例：
  ;;; imageタグを挿入してみる
  (require "imagehdr")
  (defun html-write-image-tag (file)
    (interactive "fJPEG, GIF, PNG : ")
    (multiple-value-bind (width height fmt)
      (get-image-size file)
      (insert (format nil "&lt;IMG SRC=\"~a\" WIDTH=~d HEIGHT=~d&gt;" file width height))))
</description>
<section>その他</section>
<file>imagehdr.l</file>
</chapter>

<chapter>
<title>C-z でアイコン化させるには？</title>
<type>Tips</type>
<arguments></arguments>
<description>
(require "wip/winapi")
(c:define-dll-entry winapi:BOOL ShowWindow (winapi:HWND c:int) "user32")

(global-set-key #\C-z #'(lambda () (interactive)
                          (ShowWindow (get-window-handle) 6)))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>get-disk-usage</title>
<type>Function</type>
<arguments>get-disk-usage DIRECTORY &amp;optional RECURSIVEP</arguments>
<package>editor</package>
<description>
指定されたディレクトリの容量を取得します。

  DIRECTORY  : 情報を取得するディレクトリを指定します。
  RECURSIVEP : サブディレクトリも再帰的にチェックするかを指定します。

戻り値は多値で返します。

  1 ブロックサイズ（バイト）
  2 全ディスク容量（バイト）
  3 空きディスク容量（バイト）
  4 ブロック単位の合計（バイト）
  5 ファイルサイズを単純に加算した合計（バイト）
  6 調べたディレクトリの個数
  7 調べたファイルの個数

使用例：
  (defun my-folder-size (my-dir)
    (interactive "Dfolder name: ")
    (let (my-dir-list (my-total-size  0))
      (setq my-dir-list (directory my-dir
                                   :wile "*.*"
                                   :absolute t
                                   :file-only t
                                   :recursive t
                                   :show-dots nil))
      (dolist (f my-dir-list)
        (setq my-total-size (+ my-total-size (file-length f))))
      (msgbox (format nil "フォルダの使用容量は、~d バイトです。"
                      my-total-size))))
</description>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-length</title>
<type>Function</type>
<arguments>file-length PATHNAME</arguments>
<package>lisp</package>
<description>
指定されたファイルの大きさをバイト単位で返します。

  PATHNAME : ファイル名を指定します。

使用例：
  (file-length "C:/xyzzy/xyzzy.exe")
  =&gt; 977408
</description>
<section>ファイルシステム</section>
</chapter>

<chapter>
<title>OLEオートメーションの使用例</title>
<type>Tips</type>
<arguments></arguments>
<description>
; 意味もなく全部のシートに「東西南北」を書き込む
(setq application (ole-create-object "Excel.Application"))
(ole-putprop application 'visible 1)
(setq workbook (ole-method (ole-getprop application 'Workbooks) 'Add))
(setq numbers-of-worksheets
      (ole-getprop
       (ole-getprop workbook 'worksheets)
       'count))
(setq worksheet-index 1)
(while (&lt;= worksheet-index numbers-of-worksheets)
  (setq worksheet
 (ole-getprop workbook 'Worksheets worksheet-index))
  (ole-putprop (ole-method worksheet 'Range "A1:D1")
        'value #("東" "西" "南" "北"))
  (setq worksheet-index (+ worksheet-index 1)))


こんな小細工をしてみたんですけどどうでしょう?

(defmacro $ (obj prop &amp;rest args)
  `(ole-method ,obj ',prop ,@args))

(defsetf $ (obj prop &amp;rest args) (x)
  `(progn
     (ole-putprop ,obj ',prop ,x ,@args)
     ,x))

(let (app workbook worksheet range)
  (setq app (ole-create-object "Excel.Application"))
  (setf ($ app Visible) t)
  (setq workbook ($ ($ app Workbooks) Add))
  (setq worksheet ($ workbook Worksheets 1))
  (setf ($ ($ worksheet Range "A1:D1") Value) '("North" "South" "East" "West"))
  (setf ($ ($ worksheet Range "A2:B2") Value) #(5.2 10))
  (setf ($ ($ worksheet Range "C2") Value) 8)
  (setf ($ ($ worksheet Range "D2") Value) 20)

  (setq range ($ worksheet Range "A1:D2"))
  ($ range Select)
  ($ ($ workbook Charts) Add)
  (sit-for 5)

  (setf ($ workbook saved) t)
  ($ ($ app ActiveWorkbook) Close 0)
  ($ app Quit))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>あるバッファが削除されたバッファかどうか調べるには？</title>
<type>Tips</type>
<arguments></arguments>
<description>
  (defun deleted-buffer-p (buffer)
    (not (ignore-errors (buffer-kanji-fileio-code buffer))))
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>各種ロード関係の関数の違い</title>
<type>Tips</type>
<arguments></arguments>
<description>
load         インタプリタでloadします。

load-library *.lcがあればそれをロードします。
             *.lcがなければ*.lをロードします。

autoload     関数1つ単位で、呼ばれたときloadするようにできます。
             関数が呼ばれるまではloadされません。

require      あるライブラリをロードします。ただし、既に
             ロード済みならロードしません。

*modules*    この変数を見ると今どのモジュールがロード済か分かります。
             既にロード済だともうロードしません。
</description>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>ignore-errors</title>
<type>Macro</type>
<arguments>ignore-errors &amp;body BODY</arguments>
<description>
本体を評価したときに発生するエラーを全て無視します。
エラーが発生した場合には、ignore-errorsはnilを返します。

C++の場合：
  try {
    return resolve_shortcut("c:\\autoexec.bat");
  } catch (...) {
    return nil;
  }

xyzzyの場合：
  (ignore-errors  (resolve-shortcut "c:/autoexec.bat"))
</description>
<section>エラー</section>
<file>handler.l</file>
</chapter>

<chapter>
<title>resolve-shortcut</title>
<type>Function</type>
<arguments>resolve-shortcut PATHNAME</arguments>
<description>
ショートカットからファイル名を求めます。

  PATHNAME : ショートカットを指定します。

使用例：
  (resolve-shortcut "d:/winnt/profiles/henmi2/personal/my documentsへのショートカット.lnk")
  =&gt; "G:/My Documents"
</description>
<seealso>create-shortcut</seealso>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*prefix-args*</title>
<type>Variable</type>
<package>editor</package>
<description>
コマンドが数引き数付きで呼ばれた場合に設定される変数です。

  (defun test1 ()
    (interactive)
    (message "~s,~s " *prefix-args* *prefix-value*))

例えば、C-u 10 M-x test1と呼び出されると、
*prefix-args*がnon nilになり、*prefix-value*に値が入ります。
</description>
<seealso>*prefix-value*</seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>*prefix-value*</title>
<type>Variable</type>
<package>editor</package>
<description>
コマンドが数引き数付きで呼ばれた時に数値が入ります。
</description>
<seealso>*prefix-args*</seealso>
<section>変数と定数</section>
</chapter>

<chapter>
<title>make-hash-table</title>
<type>Function</type>
<arguments>make-hash-table &amp;key :TEST :SIZE :REHASH-SIZE :REHASH-THRESHOLD</arguments>
<package>lisp</package>
<description>
ハッシュテーブルを作成して返します。
</description>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hash-table-p</title>
<type>Function</type>
<arguments>hash-table-p OBJECT</arguments>
<package>lisp</package>
<description>
オブジェクトがハッシュテーブルかどうかを返します。

  OBJECT : 判定するオブジェクトを指定します。

  (hash-table-p x) == (typep x 'hash-table)
</description>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>gethash</title>
<type>Function</type>
<arguments>gethash KEY HASH-TABLE &amp;optional DEFAULT</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの中からキーが一致するものを返します。

  KEY        : 検索するキーを指定します。
  HASH-TABLE : ハッシュテーブルを指定します。

使用例：
  (setq hash-table (make-hash-table))
  =&gt; #&lt;hash table&gt;
  (gethash 'a hash-table)
  =&gt; nil
  (setf (gethash 'a hash-table) 1)
  =&gt; 1
  (gethash 'a hash-table)
  =&gt; 1

  (setq h (make-hash-table :test #'equalp))
  (setf (gethash "body" h) '(a b c))
  (gethash "BODY" h)
</description>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remhash</title>
<type>Function</type>
<arguments>remhash KEY HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの中からキーが一致するものを削除します。

  KEY        : 削除するキーを指定します。
  HASH-TABLE : ハッシュテーブルを指定します。

一致するキーが存在すれば削除してtを返します。
なければnilを返します。

使用例：
  (setq hash-table (make-hash-table))
  =&gt; #&lt;hash table&gt;
  (setf (gethash 'a hash-table) 1)
  =&gt; 1
  (remhash 'b hash-table)
  =&gt; nil
  (remhash 'a hash-table)
  =&gt; t
</description>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>maphash</title>
<type>Function</type>
<arguments>maphash FUNCTION HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの各要素を関数に渡します。

  FUNCTION   : キーと値を受け取る関数
  HASH-TABLE : ハッシュテーブルを指定します。

使用例：
  (setf (gethash #\a hsh) "Apple")  =&gt; "Apple"
  (setf (gethash #\b hsh) "Banana") =&gt; "Banana"
  (setf (gethash #\c hsh) "Cake")   =&gt; "Cake"
  (with-output-to-selected-buffer
    (maphash #'(lambda (x y) (format t "~S ~S~%"x y)) hsh))
  #\a "Apple"
  #\b "Banana"
  #\c "Cake"
</description>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>clrhash</title>
<type>Function</type>
<arguments>clrhash HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの全要素を削除します。

  HASH-TABLE : ハッシュテーブルを指定します。
</description>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hash-table-count</title>
<type>Function</type>
<arguments>hash-table-count HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの要素数を返します。

  HASH-TABLE : ハッシュテーブルを指定します。
</description>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hash-table-rehash-size</title>
<type>Function</type>
<arguments>hash-table-rehash-size HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの現在のrehash-sizeを返します。

  HASH-TABLE : ハッシュテーブルを指定します。
</description>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hash-table-size</title>
<type>Function</type>
<arguments>hash-table-size HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルの現在の大きさを返します。

  HASH-TABLE : ハッシュテーブルを指定します。
</description>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hash-table-test</title>
<type>Function</type>
<arguments>hash-table-test HASH-TABLE</arguments>
<package>lisp</package>
<description>
ハッシュテーブルのキーを比較する関数を返します。

  HASH-TABLE : ハッシュテーブルを指定します。

使用例：
  (hash-table-test hash-table)
  =&gt; eql
</description>
<section>ハッシュ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>current-virtual-column</title>
<type>Function</type>
<arguments>current-virtual-column NIL</arguments>
<package>editor</package>
<description>
カーソル位置の表示桁を返します。
※実際の表示が表示行／物理行には依存しません。
(current-virtual-column)
</description>
<seealso>goto-virtual-column</seealso>
<section>ポジション</section>
<file></file>
</chapter>

<chapter>
<title>goto-virtual-column</title>
<type>Function</type>
<arguments>goto-virtual-column COLUMN &amp;optional EXCEED-P</arguments>
<package>editor</package>
<description>
指定された表示桁へ移動します。

  COLUMN   : 移動する表示桁位置を指定します。
  EXCEED-P : （詳細不明）

表示桁が折り返しの桁位置よりも大きいときは、折り返しの桁位置で止まります。
※実際の表示が表示行／物理行には依存しません。
</description>
<seealso>goto-column</seealso>
<section>ポジション</section>
<file></file>
</chapter>

<chapter>
<title>goto-virtual-eol</title>
<type>Function</type>
<arguments>goto-virtual-eol NIL</arguments>
<package>editor</package>
<description>
表示行の行末に移動します。
※実際の表示が表示行／物理行には依存しません。
</description>
<seealso>goto-eol</seealso>
<section>ポジション</section>
<file></file>
</chapter>

<chapter>
<title>goto-virtual-bol</title>
<type>Function</type>
<arguments>goto-virtual-bol NIL</arguments>
<package>editor</package>
<description>
表示行の行頭に移動します。
※実際の表示が表示行／物理行には依存しません。
</description>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>abbreviate-display-string</title>
<type>Function</type>
<arguments>abbreviate-display-string STRING LENGTH &amp;optional PATHNAMEP</arguments>
<package>editor</package>
<description>
文字列を表示幅に収まるように[...]で省略して返します。

  STRING    : 表示する文字列を指定します。
  LENGTH    : 表示幅を指定します。
  PATHNAMEP : 文字列がファイル名かどうかを指定します。
              ファイル名の場合には先頭の3文字(例："C:/"）だけ残して省略します。

使用例：
 (abbreviate-display-string "c:/xyzzy/lisp/builtin.l" 20 nil)
 =&gt; "c:/xyzzy.../builtin.l"
 (abbreviate-display-string "c:/xyzzy/lisp/builtin.l" 20 t)
 =&gt; "c:/.../lisp/builtin.l"
</description>
<section>文字列</section>
<seealso></seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*menu-display-length*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
メニューの「最近使ったファイル」で表示されるファイルパスの長さを指定します。
デフォルトでは40です。
</description>
<section>変数と定数</section>
<seealso></seealso>
<file>app-menu.l</file>
</chapter>

<chapter>
<title>sort</title>
<type>Function</type>
<arguments>sort SEQUENCE PREDICATE &amp;key :KEY </arguments>
<package>lisp</package>
<description>
sequenceをpredicateに従った順番に並び替えたものを返します。元のsequence
は変更されます。sortは安定であることは保証されません。安定なソートが必要
なときはstable-sortを使いましょう。

  SEQUENCE  : ソートするシーケンスを指定します。
  PREDICATE : 比較関数を指定します。
  :KEY      : 比較対象を取得する関数を指定します。

使用例：
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  =&gt; (("foo") ("bar") ("hoge"))
  (setq *test-seq* (sort *test-seq* #'string-lessp :key #'car))
  =&gt; (("bar") ("foo") ("hoge"))
  *test-seq*
  =&gt; (("bar") ("foo") ("hoge"))
 
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  =&gt; (("foo") ("bar") ("hoge"))
  (sort *test-seq* #'string-lessp :key #'car)
  =&gt; (("bar") ("foo") ("hoge"))
  *test-seq*
  =&gt; (("foo") ("hoge"))

参考：
  [xyzzy:06221] (こっそり)バージョンアップのお知らせ
  ・sort のアルゴリズムを quick から merge に変更
  (比較回数が少ない分、merge の方が速いっぽい)。
  結果、stable-sort と同じになった(が、依存しないように)。
  従来は *たまたま* (eq list (sort list)) だったが、
  そうではなくなったので注意すること。
</description>
<section>シーケンス</section>
<seealso>stable-sort</seealso>
<seealso>[xyzzy:06221]</seealso>
</chapter>

<chapter>
<title>stable-sort</title>
<type>Function</type>
<arguments>stable-sort SEQUENCE PREDICATE &amp;key :KEY</arguments>
<package>lisp</package>
<description>
sequenceをpredicateに従った順番に並び替えたものを返します。元のsequence
は変更されます。stable-sortは安定なソートを行います。つまりpredicateによっ
て同順と見なされる要素間の順序は、ソート前と同じであることが保証されます。

  SEQUENCE  : ソートするシーケンスを指定します。
  PREDICATE : 比較関数を指定します。
  :KEY      : 比較対象を取得する関数を指定します。

使用例：
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  =&gt; (("foo") ("bar") ("hoge"))
  (setq *test-seq* (stable-sort *test-seq* #'string-lessp :key #'car))
  =&gt; (("bar") ("foo") ("hoge"))
  *test-seq*
  =&gt; (("bar") ("foo") ("hoge"))
 
  (setq *test-seq* '(("foo") ("bar") ("hoge")))
  =&gt; (("foo") ("bar") ("hoge"))
  (stable-sort *test-seq* #'string-lessp :key #'car)
  =&gt; (("bar") ("foo") ("hoge"))
  *test-seq*
  =&gt; (("foo") ("hoge"))
</description>
<section>シーケンス</section>
<seealso>sort</seealso>
<seealso>[xyzzy:06221]</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*status-bar-format*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ステータスバーに表示する情報を指定する文字列です。文字の並び順に表示されます。

  t     時計
  p     カーソル位置
  c     カーソル位置の文字コード(内部コード)
  u     カーソル位置の文字コード(ユニコード)
  T     時計（曜日入り）

使用例：
  (setq *status-bar-format* "cupT")
</description>
<section>ウィンドウ</section>
<file>page.l</file>
</chapter>

<chapter>
<title>*next-screen-context-lines*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
previous-page と next-page で重なって表示される行数を指定します。
*page-scroll-half-window* が non-nilのときは効果はありません。
</description>
<section>ウィンドウ</section>
<seealso>next-page</seealso>
<seealso>previous-page</seealso>
<seealso>*page-scroll-half-window*</seealso>
<file>page.l</file>
</chapter>

<chapter>
<title>compile-regexp すると一応高速化されるんでしょうか？</title>
<type>Tips</type>
<arguments></arguments>
<description>
遅くはならないはずです(^^; ま、せいぜいこの程度ですが。

  (let ((tick (get-internal-real-time)))
    (dotimes (x 100000)
      (string-match "a" "a"))
    (- (get-internal-real-time) tick))
  =&gt; 3484
  
  (let ((tick (get-internal-real-time))
        (regexp (compile-regexp "a")))
    (dotimes (x 100000)
      (string-match regexp "a"))
    (- (get-internal-real-time) tick))
  =&gt; 2984
</description>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>どの関数の頭に何がつくのでしょうか？</title>
<type>Tips</type>
<arguments></arguments>
<description>
| パッケージという概念に関係があるんだと思いますが、どの関数の頭に何がつくの
| かというのはどこを見ればわかるんでしょうか。

  M-x apropos make-chunk RET

としたときに、

  system:make-chunk

のように表示されるものはパッケージが必要なものです。ちなみに、
si は system パッケージの、c は foreign パッケージのニックネー
ムです。
----------------------------------

  editor::xyzzy-mode  `:'が2つ表示される場合はexportされていない
        ^^
  editor:xyzzy-mode   `:'が1つ表示される場合はexportされている
        ^
  xyzzy-mode          パッケージが表示されない場合は現在のパッケージから
                      直接アクセスできる
</description>
<section>パッケージ</section>
<seealso>パッケージの概要</seealso>
<file></file>
</chapter>


<chapter>
<title>BS と C-h に別々の機能を割り当てるには？</title>
<type>Tips</type>
<arguments></arguments>
<description>
| (global-set-key #\C-h 'replace-dialog) という設定を行うと、
| BS Key を押下した場合も、ダイアログが出てきます。

伝統的な仕様ですが、

  (setf (svref *kbd-translate-table* (char-code #\C-h)) #\F13)
  (global-set-key #\F13 'replace-dialog)

このようにすれば逃げられなくもないです。
</description>
<seealso>global-set-key</seealso>
<section>キーマップ</section>
</chapter>

<chapter>
<title>start-xyzzy-server</title>
<type>Function</type>
<arguments>start-xyzzy-server NIL</arguments>
<package>System</package>
<description>
stop-xyzzy-serverの逆です。複数のxyzzy-serverが立ち上がっている状態で
xyzzycliが実行された場合、最後にアクティブになったほうが選択されるよう
です。
</description>
<seealso>stop-xyzzy-server</seealso>
<section>システム</section>
</chapter>
<chapter>
<title>stop-xyzzy-server</title>
<type>Function</type>
<arguments>stop-xyzzy-server NIL</arguments>
<package>System</package>
<description>
xyzzycli.exeに反応しないようにします。
</description>
<seealso>start-xyzzy-server</seealso>
<section>システム</section>
</chapter>

<chapter>
<title>*before-delete-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
delete-bufferを継続するかどうかを制御します。登録された関数が一
つでもnilを返すとdelete-bufferを中止します。

参考：
  ;;; 呼び出し方
  (run-hook-with-args-until-success
       '*before-delete-buffer-hook* (selected-buffer))

使用例：
  (add-hook '*before-delete-buffer-hook* 'func)
  =&gt;(func)
  (defun func (x) (yes-or-no-p "delete-buffer ~A ?" (buffer-name x)))
  =&gt;func
</description>
<seealso>delete-buffer</seealso>
<seealso>*delete-buffer-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*buffer-menu-mode-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
buffer-menuの起動時に実行されます。

参考：
  (run-hooks '*buffer-menu-mode-hook*)
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>buf-menu.l</file>
</chapter>

<chapter>
<title>*find-file-read-only-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
find-file-read-onlyの中で呼び出されます。

参考：
  (run-hooks '*find-file-read-only-hook*)
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*isearch-scanner-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
isearch-scannerで実行されます。scan-bufferするパターンを書き換えることが
出来そうです。migemo用？

参考：
  (funcall *isearch-scanner-hook* pattern)
</description>
<seealso></seealso>
<link></link>
<section>検索・正規表現</section>
<file>isearch.l</file>
</chapter>

<chapter>
<title>*process-command-line-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
xyzzy.exeに渡されたオプション引数を判定する際に呼び出されます。
*post-startup-hook*の直前で呼び出されます。

参考：
  (run-hook-with-args-until-success
   '*process-command-line-hook* arg)
</description>
<seealso>起動時処理フロー</seealso>
<link></link>
<section>システム</section>
<file>estartup.l</file>
</chapter>

<chapter>
<title>キーワードファイルの書き方</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
キーワードファイルは*keyword-load-path*もしくはetc-pathから検索
をします。$XYZZY/etc配下のファイルを参照して下さい。

形式：
  属性を指定する場合には以下の二つの形式で記述します。

  ;*n[attrib]
  ;**fg[bg[attrib]]

      n       キーワード番号(0-5) 3-5は0-2と同じ色の反転
      fg      文字色 0-f (0ならば普通の色)
      bg      背景色 0-f (0ならば普通の色）
      attrib  属性みたいなもの。以下のものの組み合わせ
              b bold
              u underline
              s strike-out
              l 一行丸ごと
条件：
  xyzzy 0.2.207からload-keyword-fileにconditionを指定する
  ことが可能になりました。conditionはitemと比較を行います。
  $XYZZY/lisp/html-kwd.lを参照

  ;*+         conditionに関わらず以降を有効にする
  ;*-         conditionに関わらず以降を無効にする
  ;*+item     itemがconditionに一致した場合に以降を有効にする
  ;*-item     itemがconditionに一致した場合に以降を無効にする
  ;*&amp;         以降はHTMLのタグ以外でも有効なキーワードとする
  ;*&lt;         以降はHTMLのタグでのみ有効なキーワードとする
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file></file>
</chapter>

<chapter>
<title>step</title>
<type>Macro</type>
<arguments>step FORM &amp;environment ENV</arguments>
<package>lisp</package>
<description>
ステップ実行を行います。
</description>
<seealso></seealso>
<link></link>
<section>制御構造</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>*page-scroll-keep-window-position*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
next-page実行時にバッファの最後がウィンドウ内にある場合、バッフ
ァの最後に移動します。previous-pageも同様です。

  t   移動しません
  nil 移動します
</description>
<seealso></seealso>
<link></link>
<section>ポジション</section>
<file>page.l</file>
</chapter>

<chapter>
<title>local-variable-p</title>
<type>Function</type>
<arguments>local-variable-p SYMBOL &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
指定されたシンボルがバッファローカル変数かどうかを判定します。

使用例：
  ;;; buffer: foo
  (local-variable-p 'abc)
  =&gt; nil
  (make-local-variable 'abc)
  =&gt; t
  (local-variable-p 'abc)
  =&gt; t

  ;;; buffer: bar
  (local-variable-p 'abc)
  =&gt; nil
</description>
<seealso>make-local-variable</seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*auto-update-per-device-directory*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
ファイラで移動したときにドライブ毎のデフォルトのディレクトリについて制御します。

  t   移動するたびに更新する
  nil set-perdevice-directoryで指定したディレクトリに固定する
</description>
<seealso>set-per-device-directory</seealso>
<link></link>
<section>ファイルシステム</section>
<file></file>
</chapter>

<chapter>
<title>set-per-device-directory</title>
<type>Function</type>
<arguments>set-per-device-directory DIRECTORY</arguments>
<package>lisp</package>
<description>
ドライブ毎のデフォルトのディレクトリを設定します。ドライブ毎のデ
フォルトのディレクトリは、ファイラ等で移動すると毎回更新されます。
更新されたくない場合には、*auto-update-per-device-directory*をnil
に設定します。

使用例：
  (set-per-device-directory "D:/foo/bar")
  (set-per-device-directory "E:/bar/foo")
</description>
<seealso>*auto-update-per-device-directory*</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*dabbrev-search-this-buffer-only*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
dabbrev-expandの検索対象を設定します。

  t   カレントバッファのみを検索します
  nil 全バッファを検索します
</description>
<seealso>dabbrev-expand</seealso>
<link></link>
<section>その他</section>
<file>dabbrev.l</file>
</chapter>

<chapter>
<title>yank-pop</title>
<type>Function</type>
<arguments>yank-pop &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
次の要素をyankします。直前のコマンドがyankならば*kill-ring*のポインター
をずらして、次の要素でyankをし直します。
</description>
<seealso>yank</seealso>
<link></link>
<section>バッファ</section>
<file>region.l</file>
</chapter>

<chapter>
<title>*modal-filer-save-position*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
モーダルでファイラーを動作させているときの、ファイラー終了時の動作を設定します。

  t   位置を保存します
  nil 位置を保存しません
</description>
<seealso>*modal-filer-save-size*</seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>next-line-add-newlines</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファの最後尾でnext-line系の移動をしたときの動作を設定します。

  t   空行を挿入します
  nil 何もしません

使用例：
  (setq next-line-add-newlines t)
</description>
<seealso></seealso>
<link></link>
<section>ポジション</section>
<file></file>
</chapter>

<chapter>
<title>*filer-modal*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラーの動作を指定します。

モーダルの場合には、ファイラーはエディタとは同期的に動作します。
ファイラー起動中はエディタでの編集は不能です。
モードレスの場合には、ファイラーはエディタとは非同期に動作します。
ファイラー起動中にエディタでの編集が可能です。

  t   モーダルで動作させます
  nil モードレスで動作させます
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラー</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*modal-filer-save-size*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
モーダルでファイラーを動作させているときの、ファイラー終了時の動作を設定します。

  t   大きさを保存します
  nil 大きさを保存しません
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*smart-indentation*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
インデント処理の前後で全く変更する必要が無かった場合の制御を設定します。

  nil      位置が同じでも従来通り常に変更する
  t        位置が違う場合のみ変更する（タブとスペースの組み合わせは気にする）
  上記以外 位置が違う場合のみ変更する（タブとスペースの組み合わせは気にしない）
</description>
<seealso>smart-indentation</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>get-menu</title>
<type>Function</type>
<arguments>get-menu MENU TAG-OR-POSITION &amp;optional TAG-OR-POSITION-P</arguments>
<package>editor</package>
<description>
指定されたメニューから、タグ名または位置で検索したメニューを取得します。

  TAG-OR-POSITION   : タグもしくは位置を指定します。
  TAG-OR-POSITION-P : TAG-OR-POSITIONの引数をタグとして解釈するか位置として解釈するかを決めます。
           nil     TAG-OR-POSITIONはタグを表すシンボル
           non-nil TAG-OR-POSITIONは位置を表す整数値
使用例：
  (get-menu *app-menu* 3 t)
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*filer-echo-filename*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
（途中）
ファイラのステータスウィンドウへのファイル名の表示を制御します。
ファイル名の表示は暇なときに行なっているようです。
  non-nil  暇なときに表示する
  nil      表示しない
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*show-matched-parenthesis*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
対応する括弧の表示を制御します。括弧に使用する文字は
set-syntax-matchで指定します。
  non-nil  対応する括弧を表示する
  nil      対応する括弧を表示しない
</description>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>current-menu</title>
<type>Function</type>
<arguments>current-menu &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
現在表示されているメニューを返します。use-local-menuを使用してい
るバッファは*app-menu*とは違うものが取得されます。
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-file-info</title>
<type>Function</type>
<arguments>get-file-info PATHNAME</arguments>
<package>editor</package>
<description>
ファイルの属性をまとめて取得します。属性・最終更新日・サイズ・短い
名前のリストの形式です。属性は以下の感じで。
  ed::*file-attribute-readonly*
  ed::*file-attribute-hidden*
  ed::*file-attribute-system*
  ed::*file-attribute-directory*
  ed::*file-attribute-archive*
  ed::*file-attribute-compressed*

使用例：
  (setq i (get-file-info (si:system-root)))
  =&gt; (16 3208385786 0 "XYZZY")
  (logand (car i) ed::*file-attribute-directory*)
  =&gt; 16
  (logand (car i) ed::*file-attribute-hidden*)
  =&gt; 0
  (format-date-string "%y/%m/%d %H:%M:%S" (cadr i))
  =&gt; "01/09/02 11:16:26"
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>list-server-resources</title>
<type>Function</type>
<arguments>list-server-resources SERVER-NAME &amp;optional COMMENT-P</arguments>
<package>editor</package>
<description>
指定されたコンピュータの共有資源の一覧を取得します。
同時に資源のコメントも取得可能です。

使用例：
  (list-server-resources "SAMURAI")
  =&gt; ("SPOOL" "E" "D" "A")
  (list-server-resources "SAMURAI" t)
  =&gt; (("SPOOL" "") ("E" "CD-ROM Drive") ("D" "Backup Storage") ("A" "FD Drive"))
</description>
<seealso>list-servers</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list-servers</title>
<type>Function</type>
<arguments>list-servers &amp;optional COMMENT-P</arguments>
<package>editor</package>
<description>
ネットワークコンピュータの一覧が取得できます。
同時にコンピュータに設定されているコメントも取得可能です。

使用例：
  (list-servers)
  =&gt; ("SAMURAI" "ROUNIN")
  (list-servers t)
  =&gt; (("SAMURAI" "Main Mashine") ("ROUNIN" "Sub Machine"))
</description>
<seealso>list-server-resources</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*show-cursor-line-always*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
カレントでないウィンドウでもカーソルラインを表示します。

使用例：
  (setq *show-cursor-line-always* t)
</description>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>*minibuffer-save-ime-status*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファのIMEの状態を制御します。
  nil  ミニバッファのIMEの状態を保存しません。
  t    ミニバッファのIMEの状態を保存します。
</description>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file></file>
</chapter>

<chapter>
<title>find-load-path</title>
<type>Function</type>
<arguments>find-load-path FILENAME</arguments>
<package>lisp</package>
<description>
*load-path*からファイルを検索しそのフルパスを返します。

使用例：
  (find-load-path "wip/ftp.l")
  =&gt; "C:/APPLICATIONS/XYZZY/lisp/wip/ftp.l"
  (find-load-path "siteinit.l")
  =&gt; "C:/APPLICATIONS/XYZZY/site-lisp/siteinit.l"
</description>
<seealso>*load-path*</seealso>
<link></link>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>regexp-keyword-list</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
正規表現を用いたキーワードの色分け機能です。キーワード長は256文
字程度らしいです。

使用例：
  (defvar *c-number-formats*
    (compile-regexp-keyword-list
     '(("\\(^\\|\\_S\\)\\(?:[0-9]+\\.[0-9]*\\|\\.[0-9]+\\)\\(?:e[-+]?[0-9]+\\)?[fl]?\\($\\|\\_S\\)"
        t (:keyword 0 :bold) nil -1 -2)
       ("\\_&lt;[0-9]+e[-+]?[0-9]+[fl]?\\_&gt;" t 1)
       ("\\_&lt;\\([1-9][0-9]*\\|0[0-7]*\\|0x[0-9a-f]+\\)\\(u?l\\|l?u\\|u?i64\\)?\\_&gt;"
        t (:color 1 2 :underline)))))
  (make-local-variable 'regexp-keyword-list)
  (setq regexp-keyword-list *c-number-formats*)

形式：
  (compile-regexp-keyword-list
   '((regexp1 case-fold color [ context [ begin [ end ] ] ] )
     (regexp2 case-fold color [ context [ begin [ end ] ] ] )
     ...
     (regexpN case-fold color [ context [ begin [ end ] ] ] )))

パラメタ：
  regexp  
      正規表現
  case-fold
      non-nil  正規表現のマッチングで大文字小文字を区別しない
      nil      正規表現のマッチングで大文字小文字を区別する
  color
      下の何れかの形式で指定します。
      keyword-color
          0-2       キーワードの1-3の色
          3-5       キーワードの1-3の色でそのキーワードだけ反転 
          6-8       キーワードの1-3の色でその行の端から端まで反転
          9         単なるbold 
          10-18     0-8と同じ色でbold
          :string   文字列の色 
          :comment  コメントの色 
          :tag      タグの色 
      (:keyword keyword-color [attributes])
          keyword-color
              keyword-colorの値
          attributes
              :bold        ボールド 
              :underline   アンダーライン 
              :strike-out  取り消し線 
              :line        一行まるごと 
      (:color foreground [background [attributes]]) 
          foreground
              0-15  前景色
          background 
              0     指定しない
              1-15  背景色
  context
      キーワードが有効な文脈を指定します。下のシンボルもしくは
      シンボルのリストを指定します。指定しない場合には、nilが指
      定されたものとして動作します。
      :string   文字列内部で有効
      :tag      タグの内部で有効
      :comment  コメントの内部で有効
      nil       上記以外で有効
      t         全ての文脈で有効
  begin
      マッチしたテキストの色を付ける部分の開始位置を指定します。
      0-9ならば(match-beginning begin)の位置からです。-1--9なら
      ば(match-end (- begin))の位置からです。指定しないかnilの場合に
      は(match-beginning 0)の位置からです。
  end
      マッチしたテキストの色を付ける部分の終了位置を指定します。
      0-9ならば(match-end end)の位置までです。-1--9ならば
      (match-beginning (- end))の位置までです。指定しないかnilの場合に
      は(match-end 0)の位置までです。
</description>
<seealso></seealso>
<link></link>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>verify-visited-file-modtime</title>
<type>BufferLocal</type>
<arguments>verify-visited-file-modtime &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
activate時のバッファの最終更新日チェックを制御します。
  :auto    更新されていれば自動的に読み直す
  non-nil  チェックする
  nil      チェックしない
</description>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>


<chapter>
<title>buffer-modified-count</title>
<type>Function</type>
<arguments>buffer-modified-count &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
（バッファが修正されたカウント数？）
</description>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>build-summary-function</title>
<type>BufferLocal</type>
<arguments></arguments>
<package></package>
<description>
バッファ中の関数の一覧を取得します。行及び関数名を要素に持つリス
トで得られます。list-functionで使用されています。

使用例：
  ; listfn.lで評価
  (funcall ed::build-summary-function)
  =&gt; ((10 "lisp-build-summary-of-functions") (39 "lisp-maketags"))
</description>
<seealso>list-function</seealso>
<link></link>
<section>関数</section>
<file></file>
</chapter>

<chapter>
<title>list-function</title>
<type>Function</type>
<arguments>list-function &amp;rest ARGS</arguments>
<package>editor</package>
<description>
バッファ中の関数の一覧をダイアログで表示します。選択することで定
義位置にジャンプすることが可能です。バッファ中の関数の一覧は、バ
ッファローカル変数build-summary-functionから取得しています。
</description>
<seealso></seealso>
<link></link>
<section>関数</section>
<file>listfn.l</file>
</chapter>

<chapter>
<title>*kill-buffer-kills-scratch*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
*kill-buffer-kills-scratch*がnon-nilの場合には、kill-bufferで
*scratch*が削除可能です。デフォルトはnilになっています。
</description>
<seealso>kill-buffer</seealso>
<link></link>
<section>変数と定数</section>
<file>lispmode.l</file>
</chapter>

<chapter>
<title>popup-list</title>
<type>Function</type>
<arguments>popup-list LIST CALLBACK &amp;optional POINT</arguments>
<package>editor</package>
<description>
ポップアップリストを表示します。選択された項目を引数にコールバッ
ク関数が呼び出されます。

使用例：
  (defun func ()
    (popup-list
       '("123" "abc" "xyz")
       #'(lambda (x) (msgbox "\"~A\" selected" x))))
  =&gt; func
</description>
<seealso>dabbrev-popup</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>compiled-regexp-case-fold-p</title>
<type>Function</type>
<arguments>compiled-regexp-case-fold-p REGEXP</arguments>
<package>editor</package>
<description>
コンパイル済みの正規表現が、大文字小文字を区別するようになってい
るかどうかを判定します。

使用例：
  (setq a (compile-regexp "a+bc*d" t))
  =&gt; #&lt;compiled regular expression: a+bc*d&gt;
  (compiled-regexp-case-fold-p a)
  =&gt; t
</description>
<seealso>compile-regexp</seealso>
<link></link>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>compiled-regexp-source</title>
<type>Function</type>
<arguments>compiled-regexp-source REGEXP</arguments>
<package>editor</package>
<description>
コンパイル済みの正規表現から元の正規表現を抽出します。

使用例：
  (setq a (compile-regexp "a+bc*d" t))
  =&gt; #&lt;compiled regular expression: a+bc*d&gt;
  (compiled-regexp-source a)
  =&gt; "a+bc*d"
</description>
<seealso>compiled-regexp-case-fold-p</seealso>
<link></link>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>display-first-tab-char</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
タブの表示に使用する文字を設定します。最初の文字は
display-first-tab-charで設定し、以降の文字は
display-rest-tab-charで設定します。
xyzzy 0.2.2.215～

使用例：
  (setq-default display-first-tab-char #\rightwards_arrow_to_bar)
  (setq-default display-rest-tab-char nil)
</description>
<seealso>display-rest-tab-char</seealso>
<link></link>
<section>文字</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>display-newline-char</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
改行の表示に使用する文字を設定します。
  半角文字  指定した文字で表示
  nil       空白で表示
  上記以外  従来の文字で表示

使用例：
  (setq-default display-newline-char #\downwards_arrow_with_tip_leftwards)
</description>
<seealso></seealso>
<link></link>
<section>文字</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>*filer-mark-file-size-unit*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラのマークファイルの合計サイズの単位を指定します。
#\B, #\K, #\M, #\G, #\Tの何れかを指定可能です。ただし、例えば#\K
が設定されたとき、サイズが1K未満ならバイト単位になります。デフォ
ルトではnilに設定されています。

使用例：
  (setq *filer-mark-file-size-unit* #\M)
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>calendar</title>
<type>Function</type>
<arguments>calendar &amp;optional YEAR</arguments>
<package>editor</package>
<description>
YEARにより指定された年のカレンダーを表示します。当日には下線が、
祝祭日には色が付いています。マウスをこれらの上に移動すると、休日
の内容がポップアップ表示されます。
</description>
<seealso></seealso>
<link></link>
<section>日付・時間</section>
<file>calendar.l</file>
</chapter>

<chapter>
<title>syntax-start-column-comment-p</title>
<type>Function</type>
<arguments>syntax-start-column-comment-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
  set-syntax-start-column-commentで指定した文字か否かを判定しま
  す。
</description>
<seealso>set-syntax-start-column-comment</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>stop-timer</title>
<type>Function</type>
<arguments>stop-timer FN</arguments>
<package>editor</package>
<description>
設定したタイマーを停止します。
</description>
<seealso>start-timer</seealso>
<link></link>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>start-timer</title>
<type>Function</type>
<arguments>start-timer INTERVAL FN &amp;optional ONE-SHOT-P</arguments>
<package>editor</package>
<description>
タイマーを設定します。INTERVAL秒後に、FNがfuncallされます。

  INTERVAL   : 何秒後に関数を実行するかを指定します。
  FN         : 実行する関数を指定します。
  ONE-SHOT-P : 継続して作動させるかどうかを指定します。
        nil      継続して作動させます。
        non-nil  1 回だけ作動させます。
  
使用例：
  ;; パターンを循環参照で作る
  (setq pat '(#\― #\／ #\｜ #\＼))
  =&gt; pat
  (setf (cdr (last pat)) pat)
  =&gt; #1=(#\― #\／ #\｜ #\＼ . #1#)
  (defun func () (setq pat (cdr pat)) (message "~A" (car pat)))
  =&gt; func
  ;; 動かす時は…
  (start-timer 0.2 'func)
  =&gt; t  
  ;; 止める時は…
  (stop-timer 'func)
  =&gt; t
</description>
<seealso>stop-timer</seealso>
<link></link>
<section>日付・時間</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-start-column-comment</title>
<type>Function</type>
<arguments>set-syntax-start-column-comment SYNTAX-TABLE CHAR &amp;optional PARSE-SEXP-IGNORE-COMMENT-P</arguments>
<package>editor</package>
<description>
set-syntax-comment-columnの補助的な設定をします。
set-syntax-optionに*syntax-option-comment-column-char*を指定した場合に
のコメント開始用のキャラクタを設定します。
詳細はset-syntax-optionを参照して下さい。
</description>
<seealso>set-syntax-option</seealso>
<seealso>set-syntax-comment-column</seealso>
<seealso>syntax-start-column-comment-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-comment-column</title>
<type>Function</type>
<arguments>set-syntax-comment-column SYNTAX-TABLE COLUMN</arguments>
<package>editor</package>
<description>
指定された列に#\SPC以外のキャラクタがある場合にコメント行と見な
します。特定のキャラクタだけにしたい場合には、
set-syntax-optionを参照して下さい。
  
使用例：
  ;;; cobol-mode.lの定義
  (set-syntax-comment-column *cobol-mode-syntax-table* 6)
</description>
<seealso>syntax-table</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>parse-point-syntax</title>
<type>Function</type>
<arguments>parse-point-syntax &amp;optional POINT</arguments>
<package>editor</package>
<description>
指定された位置のシンタックスを返します。
  :string  set-syntax-stringで指定されたキャラクタに囲まれた領域           
  :comment set-syntax-comment-column
           set-syntax-start-c++-comment
           set-syntax-end-c++-comment
           set-syntax-start-comment
           set-syntax-end-comment
           set-syntax-start-multi-comment
           set-syntax-end-multi-comment
           set-syntax-start-column-comment
           で指定された領域
  :tag     set-syntax-tagで指定されたキャラクタに囲まれた領域
  nil      上記以外の領域
</description>
<seealso>syntax-table</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>run-hook-with-args</title>
<type>Function</type>
<arguments>run-hook-with-args HOOK &amp;rest ARGS</arguments>
<package>editor</package>
<description>
  run-hooksと同じように関数を実行します。run-hooksと異なり引数を
  指定できます。
</description>
<seealso>run-hooks</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>run-hook-with-args-until-success</title>
<type>Function</type>
<arguments>run-hook-with-args-until-success HOOK &amp;rest ARGS</arguments>
<package>editor</package>
<description>
  run-hooksと同じように関数を実行します。run-hooksと異なり復帰値
  がnon-nilになるまで順番に実行します。
</description>
<seealso>run-hook-with-args</seealso>
<seealso>run-hook-with-args-while-success</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>run-hook-with-args-while-success</title>
<type>Function</type>
<arguments>run-hook-with-args-while-success HOOK &amp;rest ARGS</arguments>
<package>editor</package>
<description>
  run-hooksと同じように関数を実行します。run-hooksと異なり復帰値
  がnon-nilの間だけ順番に実行します。
</description>
<seealso>run-hook-with-args</seealso>
<seealso>run-hook-with-args-until-success</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*tail-f-mode-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
tail-f起動時に実行されます。
</description>
<seealso>tail-f</seealso>
<link></link>
<section>モード</section>
<file>tail-f.l</file>
</chapter>

<chapter>
<title>*pre-abbrev-expand-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
expand-abbrevの最初に実行されます。
</description>
<seealso>expand-abbrev</seealso>
<link></link>
<section>変数と定数</section>
<file>abbrev.l</file>
</chapter>

<chapter>
<title>*filer-chdir-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
（ファイラでディレクトリが変更されたりすると実行されます。用途不明） 
</description>
<seealso></seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*paste-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>system</package>
<description>
クリップボードから貼り付けるときに実行されます。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*show-match-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
検索で一致したものの表示に使用しています。設定されていなければ、
show-matchが実行されます。
※run-hook-with-args-while-successで実行されるので注意すること。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>search.l</file>
</chapter>

<chapter>
<title>*command-output-mode-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
execute-subprocessの中でcommand-output-mode起動時に実行されます。
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file>process.l</file>
</chapter>

<chapter>
<title>*make-backup-filename-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
（多分触らないほうがいいと思われます） 
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>backup.l</file>
</chapter>

<chapter>
<title>*select-pseudo-frame-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
（多分フレームが選択されたときに実行されると思われます）
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>pframe.l</file>
</chapter>

<chapter>
<title>*print-completion-list-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
do-completion実行時に、補完リストを表示するために使用されています。
ポップアップ表示の前に処理されます。 
※funcallで実行されるので注意すること
  
使用例：
  (setq *print-completion-list-hook*
        '(lambda (list prefix &amp;optional string)
          (popup-string
           (format nil
                   "Possible completions are ~D items:\n~{\n~A~}"
                   (length list) list) (point))))
</description>
<seealso>*popup-completion-list-default*</seealso>
<link></link>
<section>変数と定数</section>
<file>complete.l</file>
</chapter>

<chapter>
<title>*diff-mode-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
diff起動時に実行されます。
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file>diff.l</file>
</chapter>

<chapter>
<title>*gresreg-directory-name-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
gresreg-dialogでgresreg対象のディレクトリを個々に設定したい場合
に実行されます。
※funcallで実行されるので注意すること
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>gresregd.l</file>
</chapter>

<chapter>
<title>*grep-directory-name-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
grep-dialogでgrep対象のディレクトリを個々に設定したい場合に実行
されます。
※funcallされるので注意すること
</description>
<seealso>*grep-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file>grepd.l</file>
</chapter>

<chapter>
<title>*grepd-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
grep-dialog起動時に実行されます。
</description>
<seealso>*grep-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file>grepd.l</file>
</chapter>

<chapter>
<title>*grep-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
grep起動時に実行されます。
</description>
<seealso>*grepd-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file>grep.l</file>
</chapter>

<chapter>
<title>*drag-and-drop-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
D&amp;D時に実行されます。デフォルトでは、D&amp;D先がミニバッファ
ならミニバッファへの入力として扱い、それ以外ならfind-fileする
ようになっています。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>mouse.l</file>
</chapter>

<chapter>
<title>fill-region-hook</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
fill-region/fill-paragraphの最後で実行されます。
</description>
<seealso>auto-fill-hook</seealso>
<link></link>
<section>リージョン</section>
<file></file>
</chapter>

<chapter>
<title>*ime-mode-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
IMEの切替え時に呼び出されます。
</description>
<seealso>toggle-ime</seealso>
<link></link>
<section>モード</section>
<file></file>
</chapter>

<chapter>
<title>*auto-mode-alist*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
モード判定用の連想リストです。(key . datum)の組で登録します。
(string-matchp key filename)がnon-nilになった場合に、
datumをfuncallします。

datumにdecode-auto-modeのプロパティが存在する場合には、バッファを
第一引数にしてdatumをfuncallします。
cc-mode.lのdecode-c-modeを参照

使用例：
  (pushnew '("\\.asp" . basic-mode) *auto-mode-alist* :test 'equal)
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>*std-control-up-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
select-bufferやダイアログのリストボックスで、上方向に移動するキ
ャラクタを設定します。

使用例：
  (setq *std-control-up-char* #\C-p)
</description>
<seealso>*std-control-down-char*</seealso>
<link></link>
<section>ダイアログ</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>*std-control-down-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
select-bufferやダイアログのリストボックスで、下方向に移動するキ
ャラクタを設定します。

使用例：
  (setq *std-control-down-char* #\C-n)
</description>
<seealso>*std-control-up-char*</seealso>
<link></link>
<section>ダイアログ</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>*std-control-default-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
select-bufferやダイアログのリストボックスで、デフォルト選択用の
キャラクタを設定します。

使用例：
  (setq *std-control-default-char* #\RET)
</description>
<seealso></seealso>
<link></link>
<section>ダイアログ</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>*etc-path*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
キーワードファイル等を格納するパスが設定されています。
標準では(merge-pathnames "etc" (si:system-root))が設定されています。

参照例：
  *etc-path*
  =&gt; "C:/APPLICATIONS/XYZZY/etc"
</description>
<seealso>etc-path</seealso>
<link></link>
<section>変数と定数</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>*load-path*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
ライブラリをロードするパスがリストで設定されています。
直接リストを修正するよりも、siteinit.lで*default-load-path*に追
加する方が好ましいようです。
</description>
<seealso>si:*load-library</seealso>
<seealso>load-library</seealso>
<seealso>*default-load-path*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*default-load-path*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
siteinit.lから*load-path*を修正するために用いられます。
siteinit.lの直後に*default-load-path*の内容が、*load-path*にマー
ジされ、*pre-startup-hook*から有効になります。
追加するパスはリストで設定します。

使用例：
  (setq *default-load-path* '("C:/APPLICATIONS/XYZZY/lib"))
</description>
<seealso>*load-path*</seealso>
<link></link>
<section>変数と定数</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>etc-path</title>
<type>Function</type>
<arguments>etc-path</arguments>
<package>editor</package>
<description>
*etc-path*を返します。
</description>
<seealso>*etc-path*</seealso>
<link></link>
<section>システム</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>*filer-path-masks*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラーのファイルマスクを設定します。

使用例：
  (pushnew '("Microsoft" "*.doc" "*.xls" "*.ppt" "*.sys" "*.bat" "*.ini")
           *filer-path-masks* :test 'equal)
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラー</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*filer-directories*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラーのジャンプ用のディレクトリを連想リストで設定します。

使用例：
  (setq *filer-directories*
      '((" [ﾃﾞｽｸﾄｯﾌﾟ]" . "c:/windows/ﾃﾞｽｸﾄｯﾌﾟ")
        (" [ｽﾌﾟｰﾙ]" . "c:/spool")))
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラー</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*filer-guide-text*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラー下部に表示されるガイドテキストを設定します。

使用例：
  (setq *filer-guide-text*
      '("(A)ttribute  (B)yteCompile  (C)opy  (D)elete  (E)xtract  (F)ind"
        "(G)o  (J)ump  m(K)dir  &lt;L&gt;Cd  (M)ove  re(N)ame"))
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-secondary-file-mask*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラー右側の初期のファイルマスクをリストで設定します。

使用例：
  (setq *filer-secondary-file-mask* '("*"))
</description>
<seealso>*filer-primary-file-mask*</seealso>
<seealso>filer</seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-primary-file-mask*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラー左側の初期のファイルマスクをリストで設定します。

使用例：
  (setq *filer-primary-file-mask* '("*"))
</description>
<seealso>filer</seealso>
<seealso>*filer-secondary-file-mask*</seealso>
<link></link>
<section>ファイラー</section>
<file></file>
</chapter>

<chapter>
<title>*filer-use-recycle-bin*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ファイラーでファイルの削除にゴミ箱を使用するかを設定します。
  non-nil  ファイラで削除したときはゴミ箱行き
  nil      直接削除
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラー</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>*std-control-next-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
select-bufferやダイアログのリストボックスで、
ページダウンするキャラクタを設定します。

使用例：
  (setq *std-control-next-char* #\C-v)
</description>
<seealso>*std-control-prior-char*</seealso>
<link></link>
<section>ダイアログ</section>
<file></file>
</chapter>

<chapter>
<title>*std-control-prior-char*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
select-bufferやダイアログのリストボックスで、
ページアップするキャラクタを設定します。

使用例：
  (setq *std-control-prior-char* #\C-u)
</description>
<seealso>*std-control-next-char*</seealso>
<link></link>
<section>ダイアログ</section>
<file></file>
</chapter>

<chapter>
<title>*keyword-load-path*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
キーワードファイルのパスをリストで設定します。
指定されたキーワードファイルがこのリストから見つからない場合には、
etc-pathで取得されるパスを検索します。

使用例：
  (setq *keyword-load-path* '("C:/Program Files/xyzzy/keyword"))
</description>
<seealso>*etc-path*</seealso>
<link></link>
<section>変数と定数</section>
<file>kwd.l</file>
</chapter>

<chapter>
<title>title-bar-format</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
タイトルバーのフォーマットを設定します。
モードラインのフォーマットと同様です。

使用例：
  (setq title-bar-format "--%*- %b (%M) [%k:%l] %P %f")

パラメタ：
  %*    変更あり          : **
        書込禁止          : %-
        変更あり・書込禁止: %*
        それ以外          : --
  %#*   変更あり: *
        変更なし: (空白) 
  %r    書込可  : (空白)
        書込禁止: % 
  %#r   書込可        : (空白)
        書込禁止      : %
        不完全バッファ: # 
  %p    プログラム名 
  %v    バージョン 
  %h    ホスト名 
  %#h   @ホスト名 
  %b    バッファ名 
  %f    File: ファイル名 
  %#f   ファイル名 
  %F    File: ファイル名。ファイル名がなければバッファ名 
  %#F   ファイル名。ファイル名がなければバッファ名 
  %M    モード(マイナーモード含む) 
  %m    モード 
  %k    エンコーディング 
  %l    改行コード 
  %i    IMEの状態。mode-line-formatのみ。 
  %P    カーソル位置。mode-line-formatのみ。
</description>
<seealso>mode-line-format</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*minibuffer-popup-completion-list*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファで補完リストをポップアップ表示するかを設定します。

使用例：
  (setq *popup-completion-list-default* :always)
  (setq *minibuffer-popup-completion-list* :never)

動作：
  *minibuffer-popup-completion-list*
    :always   ポップアップ表示
    :never    *Completion*バッファで表示
  
    *popup-completion-list-default*
      :always ポップアップ表示
      :never  *Completion*バッファで表示
  
    non-nil   ポップアップ表示
    nil       *Completion*バッファで表示
</description>
<seealso>*popup-completion-list-default*</seealso>
<link></link>
<section>ミニバッファ</section>
<file>minibuf.l</file>
</chapter>

<chapter>
<title>*popup-completion-list-default*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
補完リスト表示のデフォルトの動作を制御します。
  :always   必ずポップアップ表示します。
  :never    *Completion*バッファで表示します。
  上記以外  個々の設定(*minibuffer-popup-completion-list*等)が
            適用されます。
</description>
<seealso>*minibuffer-popup-completion-list*</seealso>
<link></link>
<section>その他</section>
<file>complete.l</file>
</chapter>

<chapter>
<title>*move-forward-after-undo-deletion*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
削除をundoした場合のカーソルの位置を制御します。
  non-nil  削除範囲の最後尾
  nil      削除範囲の先頭
</description>
<seealso>undo</seealso>
<link></link>
<section>バッファ</section>
<file></file>
</chapter>

<chapter>
<title>*dabbrevs-no-undo*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
dabbrev-expand時のundoの方法を設定します。
dabbrev-expandを行なった際に候補が順次挿入されますが...
  non-nil  dabbrev-expandの直前まで一気に取り消す
  nil      途中の挿入過程を順番に取り消す
</description>
<seealso>undo</seealso>
<seealso>dabbrev-expand</seealso>
<link></link>
<section>バッファ</section>
<file>dabbrev.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-window</title>
<type>Function</type>
<arguments>set-buffer-fold-type-window</arguments>
<package>editor</package>
<description>
カレントバッファをウィンドウ幅で折り返します。
</description>
<seealso>set-buffer-fold-type-none</seealso>
<seealso>set-buffer-fold-type-column</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-none</title>
<type>Function</type>
<arguments>set-buffer-fold-type-none</arguments>
<package>editor</package>
<description>
カレントバッファを折り返しなしにします。
</description>
<seealso>set-buffer-fold-type-window</seealso>
<seealso>set-buffer-fold-type-column</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>set-buffer-fold-type-column</title>
<type>Function</type>
<arguments>set-buffer-fold-type-column</arguments>
<package>editor</package>
<description>
カレントバッファを指定位置で折り返しします。
</description>
<seealso>set-buffer-fold-type-window</seealso>
<seealso>set-buffer-fold-type-none</seealso>
<link></link>
<section>バッファ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>undo-boundary</title>
<type>Function</type>
<arguments>undo-boundary</arguments>
<package>editor</package>
<description>
UNDO情報に境界を設定します。
以後undoを実行すると、この境界まで戻ります。
</description>
<seealso>clear-undo-boundary</seealso>
<seealso>undo</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>undo</title>
<type>Function</type>
<arguments>undo</arguments>
<package>editor</package>
<description>
直前の操作を取り消します。
UNDO情報の直近の境界まで戻ります。
</description>
<seealso>clear-undo-boundary</seealso>
<seealso>kept-undo-information</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>clear-undo-boundary</title>
<type>Function</type>
<arguments>clear-undo-boundary &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
UNDO情報から直近の境界を削除します。

使用例：
  (defun self-insert-space (&amp;optional (arg 1))
    (interactive "*")
    (when (eq *last-command* 'self-insert-space)
      (clear-undo-boundary))
    (self-insert-command arg))
  (define-key ed::*lisp-mode-map* #\SPC 'self-insert-space)
</description>
<seealso>undo</seealso>
<seealso>kept-undo-information</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>dabbrev-popup</title>
<type>Function</type>
<arguments>dabbrev-popup</arguments>
<package>editor</package>
<description>
dabbrev-expandのポップアップリスト版です。
</description>
<seealso>dabbrev-expand</seealso>
<seealso>popup-list</seealso>
<link></link>
<section>その他</section>
<file>dabbrev.l</file>
</chapter>

<chapter>
<title>toggle-ime</title>
<type>Function</type>
<arguments>toggle-ime &amp;optional ON-OR-OFF</arguments>
<package>editor</package>
<description>
IMEのON/OFFを制御します。
  non-nil  IMEをONにする
  nil      IMEをOFFにする
  省略時   IMEをトグルする
</description>
<seealso></seealso>
<link></link>
<section>キーマップ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-fill-prefix</title>
<type>Function</type>
<arguments>set-fill-prefix</arguments>
<package>editor</package>
<description>
行頭からポイントまでをfill prefixに設定します。行頭で実行された
場合には、fill prefixはクリアされます。auto-fill-modeでは、折り
返しが行なわれると行頭にfill prefixが挿入されます。
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>indent-region</title>
<type>Function</type>
<arguments>indent-region FROM TO</arguments>
<package>editor</package>
<description>
mode-specific-indent-commandがnon-nilならば、指定のリージョンを
mode-specific-indent-commandで一行ずつインデントします。
行末はdelete-trailing-spacesで空白を削除されます。
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>lispmode.l</file>
</chapter>

<chapter>
<title>use-package</title>
<type>Function</type>
<arguments>use-package PACKAGES-TO-USE &amp;optional PACKAGE</arguments>
<package>lisp</package>
<description>
指定されたパッケージ（省略された場合はカレントのパッケージ）が使
用する他のパッケージを設定します。
</description>
<seealso>find-package</seealso>
<seealso>defpackage</seealso>
<link></link>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>ed::toggle-mode</title>
<type>Function</type>
<arguments>toggle-mode VAR ARG SV</arguments>
<package>editor</package>
<description>
マイナーモードの状態を表す変数VARを設定します。
SVがnilならば状態は反転します。
ARGが負数もしくはnilならば無効になります。
ARGが非負数値もしくはnon-nilならば有効になります。
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>unset-minor-mode-map</title>
<type>Function</type>
<arguments>unset-minor-mode-map KEYMAP &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
マイナーモード用のキーマップを解除します。
</description>
<seealso>set-minor-mode-map</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-minor-mode-map</title>
<type>Function</type>
<arguments>set-minor-mode-map KEYMAP &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
マイナーモード用のキーマップを設定します。
</description>
<seealso>unset-minor-mode-map</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*exit-minibuffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファから出たときに実行されます。
</description>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file></file>
</chapter>

<chapter>
<title>*enter-minibuffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファに入ったときに実行されます。(interactive...)で指定さ
れた引数が渡されます。
</description>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file></file>
</chapter>

<chapter>
<title>*change-buffer-colors-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
途中
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*delete-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
delete-bufferで実行されます。
</description>
<seealso>delete-buffer</seealso>
<seealso>*before-delete-buffer-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*deactivate-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファがdeactivateされたときに任意の処理を行うために使用されま
す。デフォルトではクリップボードの同期を行っています。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*activate-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
バッファがactivateされたときに任意の処理を行うために使用されます。
デフォルトではファイルの修正日付を確認しています。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*create-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
多分create-new-bufferで実行されます。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*save-buffer-no-filenames-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
多分get-buffer-file-nameがnilとかだと実行されます。
※run-hook-with-args-until-successで実行されるので注意すること
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*after-save-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
多分save-bufferの最後に実行されます。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*before-save-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
多分save-bufferの最初に実行されます。
※run-hook-with-args-until-successで実行されるので注意すること
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*query-kill-buffer-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
kill-bufferで実行されます。バッファの破棄を確認するために使用します。
※run-hook-with-args-while-successで実行されるので注意すること。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>*find-file-hooks*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
find-fileの最後で実行されます。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*find-file-file-not-found-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
find-fileで指定されたファイルが存在しないときに実行されます。
※run-hook-with-args-until-successで実行されるので注意すること
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>files.l</file>
</chapter>

<chapter>
<title>*before-find-file-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
find-fileの最初で実行されます。
※run-hook-with-args-until-successで実行されるので注意すること
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>files.l</file>
</chapter>

<chapter>
<title>post-buffer-modified-hook</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
任意のバッファで任意の操作が行われたときに呼び出されます。
[xyzzy:06354]を参照
xyzzy 0.2.1.186～
  
使用例：
  (enable-post-buffer-modified-hook t)
  (defun buffer-modified-hook (buffer operation from to undo-p)
    (message "ope:~A  undo:~A from:~d to:~d" operation undo-p from to))
  (add-hook 'post-buffer-modified-hook 'buffer-modified-hook)
</description>
<seealso>enable-post-buffer-modified-hook</seealso>
<seealso>post-buffer-modified-hook-enabled-p</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>post-buffer-modified-hook-enabled-p</title>
<type>Function</type>
<arguments>post-buffer-modified-hook-enabled-p &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファでpost-buffer-modified-hookが有効かを判定します。
[xyzzy:06354]を参照
xyzzy 0.2.1.186～ 
</description>
<seealso>enable-post-buffer-modified-hook</seealso>
<seealso>post-buffer-modified-hook</seealso>
<link></link>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>enable-post-buffer-modified-hook</title>
<type>Function</type>
<arguments>enable-post-buffer-modified-hook ENABLE &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
post-buffer-modified-hookを有効にします。
[xyzzy:06354]を参照
xyzzy 0.2.1.186～ 
</description>
<seealso>post-buffer-modified-hook-enabled-p</seealso>
<seealso>post-buffer-modified-hook</seealso>
<link></link>
<section>変数と定数</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>auto-fill-hook</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
入力の結果、fill-columnを越えたらdo-auto-fillから実行されます。
</description>
<seealso>*auto-fill-hook</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*auto-fill-hook</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
auto-fill-modeの時に、self-insert-commandから*last-command-char*
を引数として実行されます。普通はdo-auto-fillが設定されています。
多分修正しない方が良いと思います。
※run-hooksではなく、funcallされるので注意すること
</description>
<seealso>auto-fill-hook</seealso>
<link></link>
<section>変数と定数</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>*post-command-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
コマンドループにおいてコマンドの実行後に実行されます。
</description>
<seealso>*pre-command-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*pre-command-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
コマンドループにおいてコマンドの実行前に実行されます。 
</description>
<seealso>*post-command-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*kill-xyzzy-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
xyzzyの終了時に実行されます。
</description>
<seealso>*query-kill-xyzzy-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*query-kill-xyzzy-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
xyzzy終了時に実行されます。このフック変数の実行がnilだと終了しない。
[xyzzy:03872]を参照
</description>
<seealso>*kill-xyzzy-hook*</seealso>
<link></link>
<section>変数と定数</section>
<file></file>
</chapter>

<chapter>
<title>*command-line-mailto-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
コマンドラインで指定された -mailto オプションの引数を元に実行されます。 
※run-hooksではなくfuncallされるので注意すること
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>estartup.l</file>
</chapter>

<chapter>
<title>*save-history-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
*kill-xyzzy-hook*実行時に呼び出されます。
コマンドバー、セッション等のヒストリ変数の保存に使用されています。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>*init-app-menus-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
xyzzy実行後に実行されます。*app-menu*を直接変更する用途で用いら
れます。

使用例：
  (add-hook '*init-app-menus-hook*
            #'(lambda ()
                (add-menu-item *app-menu* 'close-box :close-box
                               #'kill-selected-buffer)))
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>app-menu.l</file>
</chapter>

<chapter>
<title>*load-history-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
.xyzzy処理後に実行されます。コマンドバー、セッション等のヒストリ変
数の読み込みに使用されています。
</description>
<seealso>起動時処理フロー</seealso>
<link></link>
<section>変数と定数</section>
<file>history.l</file>
</chapter>

<chapter>
<title>起動時処理フロー</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
  起動時の処理フローです。$XYZZY/xyzzy.exeを起動すると、最初はinit.cc
  から $XYZZY/lisp/startup.lが呼び出されます。以降の主なフローは以下
  のとおりです。
  
  init.cc: 
    1. startupをload-library 
       startup.l: 
        1. loadupをload-library 
           loadup.l: 
            1. estartupをload-library 
             （estartup.lで、e:startupを定義） 
            2. historyをload-library 
             （history.lで、load-history-fileを定義） 
            3. app-menuをload-library 
             （app-menu.lで、init-app-menusを定義） 
            4. siteinitをload-library 
    2. ダンプが未だならダンプ 
    3. e:startupを実行 
       estartup.lのe:startup: 
        1. フレームを初期化 
        2. *pre-startup-hook*を実行 
        3. .xyzzyを実行 
        4. ヒストリを初期化 
         （history.lのload-history-fileで、*load-history-hook*を実行） 
        5. メニューを初期化 
         （app-menu.lのinit-app-menusで、*init-app-menus-hook*を実行） 
        6. *scratch*を作成
        7.引数解析
          (process-command-lineから、*command-line-mailto-hook*とか
           *process-command-line-hook*を実行）
        8. *post-startup-hook*を実行 
  
まとめると、起動時にユーザが変更可能な部分は、以下の順番で実行さ
れます。

  1. $XYZZY/site-lisp/siteinit.l
  2. *pre-startup-hook*
  3. ~/.xyzzy
  4. *load-history-hook*
  5. *init-app-menus-hook*
  6. *command-line-mailto-hook*（-mailtoがある場合）
  7. *process-command-line-hook*（不明なオプションがある場合）
  8. *post-startup-hook*
</description>
<seealso></seealso>
<link></link>
<section>システム</section>
<file></file>
</chapter>

<chapter>
<title>*post-startup-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
初期設定ファイル.xyzzy実行後に以下の順番でフック変数が評価されま
す。
  1. *load-history-hook*
  2. *init-app-menu-hook*
  3. *command-line-mailto-hook*（-mailtoがある場合）
  4. *process-command-line-hook*（不明なオプションがある場合）
  5. *post-startup-hook*
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>estartup.l</file>
</chapter>

<chapter>
<title>*pre-startup-hook*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
初期設定ファイルsiteinit.l実行後に実行されます。
</description>
<seealso></seealso>
<link></link>
<section>変数と定数</section>
<file>estartup.l</file>
</chapter>

<chapter>
<title>hide-command-bar</title>
<type>Function</type>
<arguments>hide-command-bar SYM</arguments>
<package>editor</package>
<description>
define-command-barで定義したコマンドバーを非表示にします。
</description>
<seealso>show-command-bar</seealso>
<link></link>
<section>メニュー</section>
<file>cmdbar.l</file>
</chapter>

<chapter>
<title>show-command-bar</title>
<type>Function</type>
<arguments>show-command-bar SYM</arguments>
<package>editor</package>
<description>
define-command-barで定義したコマンドバーを表示します。
</description>
<seealso>hide-command-bar</seealso>
<link></link>
<section>メニュー</section>
<file>cmdbar.l</file>
</chapter>

<chapter>
<title>goto-matched-parenthesis</title>
<type>Function</type>
<arguments>goto-matched-parenthesis &amp;optional ARG</arguments>
<package>editor</package>
<description>
ポイントに存在するキャラクタが、syntax-open-pもしくはsyntax-close-pを満
たす場合に、対応するキャラクタに移動します。対応する各種括弧に移動するの
に使われます。
</description>
<seealso></seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*executing-macro*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
マクロを実行中か否かを返します。
  t    マクロを実行中
  nil  マクロを実行中ではない
</description>
<seealso></seealso>
<link></link>
<section>マクロ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>get-buffer-alternate-file-name</title>
<type>Function</type>
<arguments>get-buffer-alternate-file-name &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファBUFFERに設定されたファイル名の別名を取得します。
</description>
<seealso>set-buffer-alternate-file-name</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-buffer-alternate-file-name</title>
<type>Function</type>
<arguments>set-buffer-alternate-file-name NAME &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファBUFFERにファイル名の別名NAMEをつけます。set-buffer-file-nameでは、
ありえないパスを指定するとエラーになります。
set-buffer-alternate-file-nameではどのような文字列でも指定可能です。

使用例：
  ; c:/abc/は存在しないパス
  (set-buffer-file-name "c:/abc/def.txt")
  =&gt; c:/abc/def.txt
     指定されたパスが見つかりません。 

  ; URLでもなんでも任意の文字列を設定可
  (set-buffer-alternate-file-name "http://www.asahi.com")
  =&gt; t

指定した文字列は、バッファのファイル名がnilの場合（つまり、
get-buffer-file-nameの戻り値がnilの場合）に限り、
以下の個所で使用されます

  1)select-bufferで表示されるダイアログのファイル名
  2)mode-line-format/title-bar-formatのファイル名
</description>
<seealso>get-buffer-alternate-file-name</seealso>
<seealso>set-buffer-file-name</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>copy-syntax-table</title>
<type>Function</type>
<arguments>copy-syntax-table FROM-SYNTAX-TABLE TO-SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
FROM-SYNTAX-TABLEをTO-SYNTAX-TABLEコピーします。
</description>
<seealso>make-syntax-table</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>keywordp</title>
<type>Function</type>
<arguments>keywordp OBJECT</arguments>
<package>lisp</package>
<description>
与えられたオブジェクトOBJECTがキーワードか否かを返します。多分、
keyword-hash-tableを参照して、登録されているか否かを返すのだと思います。
</description>
<seealso></seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>update-mode-line</title>
<type>Function</type>
<arguments>update-mode-line &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
モード行を更新します。mode-line-formatの変更などを行った場合に、速やかに
モード行に反映したい場合に実行します。
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fill-column</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
詰め込み時の折り返しの桁数を保持します。
既定値は 72 です。

使用例:
  ;;; 既定値を 62 に変更する。
  (setq-default fill-column 62)

カレントバッファの値を変更する場合は、Function set-fill-column 
を使用します。
</description>
<seealso>auto-fill-mode</seealso>
<link></link>
<section>ポジション</section>
<file></file>
</chapter>

<chapter>
<title>set-fill-column</title>
<type>Function</type>
<arguments>set-fill-column &amp;optional (COL (CURRENT-COLUMN))</arguments>
<package>editor</package>
<description>
詰め込み桁数を指定します。
指定された値は、変数 fill-column に代入されます。

  COL : 詰め込み桁数
        引数がない場合は、現在のカーソル位置の桁数を詰め込み桁数に設定し
        ます。
</description>
<seealso>fill-column</seealso>
<link></link>
<section>ポジション</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>fill-region</title>
<type>Function</type>
<arguments>fill-region FROM TO</arguments>
<package>editor</package>
<description>
リージョン内の各段落に対し、詰め込みを行います。

使用例:
  ;;; バッファ全体を詰め込み
  (fill-region (point-min) (point-max))
</description>
<seealso>fill-paragraph</seealso>
<link></link>
<section>リージョン</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>*next-buffer-in-tab-order*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
next-bufferで次に移動するバッファを、タブでの順番どおりにするか否かを設
定します。もちろんprevious-bufferにも影響します。
  t    バッファバーでの次のバッファに移動する。
  nil  どうなるでしょうか？
</description>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>ignored-extensions</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
ミニバッファでの入力補完において、ignored-extensionsの拡張子がついたファ
イルは補完の対象になりません。

使用例：
  ; exeとdllは入力補完しない
  (setq ignored-extensions '("exe" "dll"))
</description>
<seealso></seealso>
<link></link>
<section>ミニバッファ</section>
<file>defs.l</file>
</chapter>

<chapter>
<title>compile-regexp-keyword-list</title>
<type>Function</type>
<arguments>compile-regexp-keyword-list LIST</arguments>
<package>editor</package>
<description>
regexp-keyword-list用に正規表現のコンパイルを行います。
指定するLISTの形式はregexp-keyword-listを参照して下さい。
</description>
<seealso>regexp-keyword-list</seealso>
<link></link>
<section>検索・正規表現</section>
<file>re-kwd.l</file>
</chapter>

<chapter>
<title>syntax-table-p</title>
<type>Function</type>
<arguments>syntax-table-p OBJECT</arguments>
<package>editor</package>
<description>
指定されてオブジェクトOBJECTがシンタックステーブルか否かを返します。
  t    シンタックステーブルである。
  nil  シンタックステーブルでない。
</description>
<seealso>make-syntax-table</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-syntax-table</title>
<type>Function</type>
<arguments>make-syntax-table</arguments>
<package>editor</package>
<description>
シンタックステーブルを作成します。基本的に各文字にシンタックスコードを割
り振りますが、他にも目的の構文に応じて以下の設定を行います。

  ・文字列中のエスケープ文字の設定
  ・タグや括弧などの対応付けのある文字の設定
  ・単なる対になった区切り文字の設定
  ・コメントの設定
      ・開始終了を一文字で行うコメント
      ・開始終了を文字列で行うコメント
      ・C++スタイルのコメント
  ・特定行に文字があった場合のコメントの設定

これらの設定は set-syntax-... 系の関数を使って行います。設定に応じて、画
面の色付けやskip-syntax-spec-forward / skip-syntax-spec-backwardでの動作
が変わったりします。

デフォルト値：
  Num           Char            SyntaxCode
  ---           ----            ----------
  0x00          #\NUL           SCjunk
  0x01 .. 0x08  #\C-a .. #\C-h  SCjunk
  0x09          #\TAB           SCwhite
  0x0a          #\LFD           SCwhite
  0x0b          #\C-k           SCjunk
  0x0c          #\C-l           SCwhite
  0x0d          #\RET           SCwhite
  0x0e .. 0x1a  #\C-n .. #\C-z  SCjunk
  0x1b          #\ESC           SCjunk
  0x1c          #\C-\\          SCjunk
  0x1d          #\C-]           SCjunk
  0x1e          #\C-^           SCjunk
  0x1f          #\C-_           SCjunk
  0x20          #\SPC           SCwhite
  0x21 .. 0x2f  #\! .. #\/      SCpunct
  0x30 .. 0x39  #\0 .. #\9      SCword
  0x3a          #\:             SCpunct
  0x3b          #\;             SCpunct
  0x3c          #\&lt;             SCpunct
  0x3d          #\=             SCpunct
  0x3e          #\&gt;             SCpunct
  0x3f          #\?             SCpunct
  0x40          #\@             SCpunct
  0x41 .. 0x5a  #\A .. #\Z      SCword
  0x5b          #\[             SCpunct
  0x5c          #\\             SCpunct
  0x5d          #\]             SCpunct
  0x5e          #\^             SCpunct
  0x5f          #\_             SCpunct
  0x60          #\`             SCpunct
  0x61 .. 0x7a  #\a .. #\z      SCword
  0x7b          #\{             SCpunct
  0x7c          #\|             SCpunct
  0x7d          #\}             SCpunct
  0x7e          #\~             SCpunct
  0x7f          #\DEL           SCjunk
  0x80                          SCjunk
  0x81 ..0x9f   #\x81 .. #\x9f  SCkanji
  0xa0                          SCkanji
  0xa1 .. 0xb0  #\｡ .. #\ｰ      SCkana
  0xb1 .. 0xdd  #\ｱ .. #\ﾝ      SCkana
  0xde          #\ﾞ             SCkana
  0xdf          #\ﾟ             SCkana
  0xe0 .. 0xfc  #\xe0 .. #\xfc  SCkanji
  0xfd                          SCjunk
  0xfe                          SCjunk
  0xff                          SCjunk
</description>
<seealso></seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-quote-p</title>
<type>Function</type>
<arguments>syntax-quote-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがSYNTAX-TABLEでquote(?)として規定されているか否か返します。
  t    CHARはquoteである。
  nil  CHARはquoteでない。
</description>
<seealso>set-syntax-quote</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-quote</title>
<type>Function</type>
<arguments>set-syntax-quote SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
SYNTAX-TABLEにCHARをquoteとして規定します。
lispでリストで使う`''(quote)や、マクロで使う``'(backquote) `,'(comma)、
ベクタで使う`#'等があります。シンタックス上では意味付けをすることができ
ますが、どのような違いが出るかは不明。

使用例：
  ; lisp/lispmode.l
  (set-syntax-quote *lisp-mode-syntax-table* #\#)
  (set-syntax-quote *lisp-mode-syntax-table* #\')
  (set-syntax-quote *lisp-mode-syntax-table* #\,)
  (set-syntax-quote *lisp-mode-syntax-table* #\`)
</description>
<seealso>syntax-quote-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-string</title>
<type>Function</type>
<arguments>set-syntax-string SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
SYNTAX-TABLEにCHARを文字列の区切り文字として規定します。ここで指定した文
字で囲まれた領域はリテラルの文字列として色づけされます。

使用例：
  ; | を 文字列の区切り文字とする場合
  (set-syntax-string *user-mode-syntax-table* #\|)
</description>
<seealso>syntax-string-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-string-p</title>
<type>Function</type>
<arguments>syntax-string-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがSYNTAX-TABLEで文字列の区切りとして規定されているか否かを返します。
  t    CHARは文字列の区切り文字である。
  nil  CHARは文字列の区切り文字でない。
</description>
<seealso>set-syntax-string</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-whitespace</title>
<type>Function</type>
<arguments>set-syntax-whitespace SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
SYNTAX-TABLEにCHARをwhitespaceとして規定します。whitespaceとして規定され
た文字は skip-white-forward / skip-white-backwardでスキップされるように
なります。

使用例：
  ; lisp/lispmode.l
  (set-syntax-whitespace *lisp-mode-syntax-table* #\SPC)
  (set-syntax-whitespace *lisp-mode-syntax-table* #\TAB)
  (set-syntax-whitespace *lisp-mode-syntax-table* #\C-l)
  (set-syntax-whitespace *lisp-mode-syntax-table* #\RET)
</description>
<seealso>syntax-whitespace-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-whitespace-p</title>
<type>Function</type>
<arguments>syntax-whitespace-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがSYNTAX-TABLEでwhitespaceとして規定されてるか否かを返します。
  t    CHARはwhitespaceでない。
  nil  CHARはwhitespaceである。
</description>
<seealso>set-syntax-whitespace</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-exit-code</title>
<type>Function</type>
<arguments>process-exit-code PROCESS</arguments>
<package>editor</package>
<description>
指定されたプロセスPROCESSの終了コードを取得します。
</description>
<seealso>process-status</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>signal-process</title>
<type>Function</type>
<arguments>signal-process PROCESS</arguments>
<package>editor</package>
<description>
指定されたプロセスPROCESSにシグナルを送ります。
※SIGINT?
</description>
<seealso>kill-process</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>print-dialog</title>
<type>Function</type>
<arguments>print-dialog &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
指定されたバッファBUFFERの印刷用のダイアログを表示します。
</description>
<seealso>print-buffer</seealso>
<link></link>
<section>ダイアログ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>print-buffer</title>
<type>Function</type>
<arguments>print-buffer &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
バッファを印刷します。
</description>
<seealso>print-dialog</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>drive-dialog</title>
<type>Function</type>
<arguments>drive-dialog &amp;optional DRIVE</arguments>
<package>editor</package>
<description>
ドライブ選択のダイアログを表示します。DRIVEで初期表示するドライブを選択
できます。選択したドライブのドライブ文字がキャラクタで返されます。

使用例：
  (drive-dialog)
  =&gt; #\R
</description>
<seealso></seealso>
<link></link>
<section>ダイアログ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-number-of-function-bar-labels</title>
<type>Function</type>
<arguments>set-number-of-function-bar-labels N</arguments>
<package>editor</package>
<description>
ファンクションバーのラベルの数を設定します。指定できる数は、
4/5/8/10/12/15です。
</description>
<seealso>number-of-function-bar-labels</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>number-of-function-bar-labels</title>
<type>Function</type>
<arguments>number-of-function-bar-labels</arguments>
<package>editor</package>
<description>
ファンクションバーのラベルの数を返します。非表示の場合でも数値を返します。
</description>
<seealso>set-number-of-function-bar-labels</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-tool-bar</title>
<type>Function</type>
<arguments>delete-tool-bar NAME</arguments>
<package>editor</package>
<description>
ツールバーNAMEを削除します。
コマンドバーとして登録していた場合には、[表示]-[ツールバー]に残骸が残っ
てしまいますので、delete-command-barで削除する必要があります。
</description>
<seealso>create-tool-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hide-tool-bar</title>
<type>Function</type>
<arguments>hide-tool-bar NAME</arguments>
<package>editor</package>
<description>
ツールバーNAMEを非表示にします。
</description>
<seealso>show-tool-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>show-tool-bar</title>
<type>Function</type>
<arguments>show-tool-bar NAME &amp;optional EDGE X Y W</arguments>
<package>editor</package>
<description>
ツールバーNAMEを表示します。EDGE X Y Wを指定することで任意の位置に表示さ
せることが可能です。

  EDGE  :top    上側に表示
        :left   左側に表示
        :right  右側に表示
        :bottom 下側に表示
        nil     非表示
  X     横の位置
  Y     縦の位置
  W     タブバーの場合に左右に表示した場合の横幅を与える。
        ツールバーの場合はnilを与える。

[表示]-[ツールバー]に登録したいのならば、show-tool-barではなく、
define-command-bar/show-command-barを使います。
</description>
<seealso>hide-tool-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tool-bar-info</title>
<type>Function</type>
<arguments>tool-bar-info NAME</arguments>
<package>editor</package>
<description>
指定したツールバーNAMEの情報を多値で返します。

形式：
  表示位置  :top        上側に表示
            :left       左側に表示
            :right      右側に表示
            :bottom     下側に表示
            nil         非表示
  横位置    横の位置を返す。
  縦位置    縦の位置を返す。
  横幅      タブバーの場合に左右に表示した場合の横幅を返す。
            ツールバーの場合はnilを返す。
</description>
<seealso>list-tool-bars</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tool-bar-exist-p</title>
<type>Function</type>
<arguments>tool-bar-exist-p NAME</arguments>
<package>editor</package>
<description>
指定されたツールバーNAMEが存在するか否かを返します。
  t    ツールバーが存在する。
  nil  ツールバー存在しない。
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list-tool-bars</title>
<type>Function</type>
<arguments>list-tool-bars</arguments>
<package>editor</package>
<description>
ツールバーの状態を取得します。状態は以下の形式で返されます。

形式：
  (((左側のツールバー1 横位置1 縦位置1 横幅1)
    (左側のツールバー2 横位置2 縦位置2 横幅2)
    (左側のツールバー3 横位置3 縦位置3 横幅3) ... )
   ((上側のツールバー1 横位置1 縦位置1 横幅1) ... )
   ((右側のツールバー1 横位置1 縦位置1 横幅1) ... )
   ((下側のツールバー1 横位置1 縦位置1 横幅1) ... )
   (非表示のツールバー1 非表示のツールバー2 ... ))

タブバーの場合だけ横幅に数字が返されます。ツールバーの場合には、必ずnil
が返されます。
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>focus-tool-bar</title>
<type>Function</type>
<arguments>focus-tool-bar</arguments>
<package>editor</package>
<description>
タブバーにフォーカスを移します。タブバーからはTABを押すことで元のバッフ
ァに戻ることが出来ます。タブバーが存在しないときは、フォーカスは元のバッ
ファのままです。
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-tool-bar</title>
<type>Function</type>
<arguments>create-tool-bar NAME BITMAP ITEMS</arguments>
<package>editor</package>
<description>
ツールバーNAMEを作成します。ツールバーに表示するビットマップファイルのフ
ルパスBITMAPと、ツールバーの項目ITEMSを指定します。ITEMSは以下の形式で記
述します。項目の替わりに:sepを指定するとセパレータを表示できます。

形式：
  ((ツールチップ1 アイコンの番号1 実行する関数1 状態制御用1)
   (ツールチップ2 アイコンの番号2 実行する関数2 状態制御用2)
    ...
   (ツールチップN アイコンの番号N 実行する関数N 状態制御用N))

補足：
  アイコンの番号：
        16x16の領域をひとつのアイコンとみなして、ビットマップファイルの
        左から0ベースの番号で指定します。
  状態制御用：
        ボタンの状態が何に依存して変更するかを指定します。
        :modified              編集されていたら 
        :selection             行モード選択、文字モード選択をしていたら 
        :modify-selection      編集可能なバッファで行モード選択
                               文字モード選択をしていたら 
        :rectangle             矩形選択していたら 
        :modify-rectangle      編集可能なバッファで矩形選択をしていたら 
        :any-selection         選択していたら 
        :modify-any-selection  編集可能なバッファで選択していたら 
        :clipboard             編集可能なバッファでクリップボードに値が入っていたら 
        :undo                  UNDOできる状態なら 
        :redo                  リドゥできる状態なら 
        関数 (function)        関数が返す値による
            :disable           ボタンを押せない状態 
            :check             ボタンを押してへこんだ状態 
            上記以外           普通の押せる状態 
        上記以外               指定しないとの同じで無条件に押せる状態 
        ※OHKUBO Hiroshiさんのサイトより
          http://members.tripod.co.jp/ohkubo/xyzzy/memo.html

使用例：
(create-tool-bar 'abc-tool-bar
 (merge-pathnames "toolbar.bmp" (etc-path))
 '(("line-number" 0 toggle-line-number)
   ("vscroll-bar" 1 toggle-vscroll-bar)
   ("mode-line" 2 toggle-mode-line)
   :sep
   ("function-bar" 3 toggle-function-bar)
   ("fold-line" 4 toggle-fold-line)
   ("read-only" 5 toggle-read-only)))

</description>
<seealso>define-command-bar</seealso>
<seealso>create-tab-bar</seealso>
<seealso>lisp/cmdbar.l</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>define-command-bar</title>
<type>Function</type>
<arguments>define-command-bar SYM NAME &amp;optional EDGE X Y W</arguments>
<package>editor</package>
<description>
※以下は私見です。

ツールバーやタブバーを総称してツールバーと呼ぶようです。作成するときやツ
ールバーのリストを操作するときは全てtool-bar系の関数を使います。単に表示
するだけならば、show-tool-barを使えば可能です。

ただし、メニューの[表示]-[ツールバー]の一覧に追加する場合には、
command-bar系の関数を使います。define-command-barで登録したツールバーは、
[表示]-[ツールバー]から表示を制御することが可能です。予め、
define-command-barで定義したSYMに対応する、ツールバー・タブバーを作って
おく必要があります。

以下はタブバーを操作する場合の例です。

  (progn
    (defun a-func (a) (msgbox "~A ~A" a (type-of a)))
    (define-command-bar 'a-bar "a bar")
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))

  (progn
    (tab-bar-delete-item 'a-bar '1st)
    (tab-bar-delete-item 'a-bar '2nd)
    (delete-tool-bar 'a-bar)
    (delete-command-bar 'a-bar))

また、ユーザのツールバーなどを作成する場合には、delete-command-barで削除
する手順を考慮することをおすすめします。コマンドバーは（シンボル名だけ）
ヒストリ変数に格納されます。その実体（ツールバーやタブバー）がなくとも、
ずっと[表示]-[ツールバー]に残ってしまいます。そのようなときは、手動で削
除する必要があります。

似たような話で、コマンドバーには関数名だけを指定しておいて、後から本体を
読み込みたい場合には、autoloadで出来ます。本体の初期化に時間が掛かる場合
には、このように分離するほうが良いと思います。

使用例：
  ------------------------------------------------
  ;;; .xyzzy
  (progn
    (define-command-bar 'a-bar "a bar")
    (autoload 'a-bar "a-bar.l"))
  ------------------------------------------------

  ------------------------------------------------
  ;;; a-bar.l
  (progn
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))
  ------------------------------------------------

</description>
<seealso>delete-command-bar</seealso>
<link></link>
<section>メニュー</section>
<file>cmdbar.l</file>
</chapter>

<chapter>
<title>tab-bar-modify-item</title>
<type>Function</type>
<arguments>tab-bar-modify-item BAR ITEM &amp;optional STRING TOOLTIP MENU</arguments>
<package>editor</package>
<description>
指定されたタブバーBARのタブITEMの設定を変更します。

使用例：
  (tab-bar-modify-item 'a-bar '1st "- first -")
  =&gt; t
</description>
<seealso>tab-bar-add-item</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-list-items</title>
<type>Function</type>
<arguments>tab-bar-list-items BAR</arguments>
<package>editor</package>
<description>
指定されたタブバーBARのタブのシンボルのリストを返します。

使用例：
  (tab-bar-list-items 'a-bar)
  =&gt; (1st 2nd)
</description>
<seealso>tab-bar-find-item</seealso>
<seealso>create-tab-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-find-item</title>
<type>Function</type>
<arguments>tab-bar-find-item BAR ITEM</arguments>
<package>editor</package>
<description>
指定されたタブバーBARからタブITEMが存在するか否かを返します。
  t    存在する。
  nil  存在しない。

使用例：
  (tab-bar-find-item 'a-bar '1st)
  =&gt; t
  (tab-bar-find-item 'a-bar '3rd)
  =&gt; nil
</description>
<seealso>create-tab-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-select-item</title>
<type>Function</type>
<arguments>tab-bar-select-item BAR ITEM</arguments>
<package>editor</package>
<description>
指定されたタブバーBARのタブITEMを選択状態にします。同時にタブバーに設定
されたCALLBACKが実行されます。
</description>
<seealso>tab-bar-current-item</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-delete-item</title>
<type>Function</type>
<arguments>tab-bar-delete-item BAR ITEM</arguments>
<package>editor</package>
<description>
create-tab-barで作成したタブバーBARからタブITEMを削除します。削除するタ
ブが選択状態であれば、次のタブが選択されて同時にCALLBACKが実行されます。
</description>
<seealso>tab-bar-add-item</seealso>
<seealso>create-tab-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-current-item</title>
<type>Function</type>
<arguments>tab-bar-current-item BAR</arguments>
<package>editor</package>
<description>
選択中のタブの情報が返されます。タブがひとつも無い場合には、nilが返され
ます。必ず、タブを識別するためのシンボル、タブの文字列、ツールチップのリ
ストで返されます。ツールチップが設定されていない場合には、nilが返されま
す。

使用例：
  (progn
    (defun a-func (a) (msgbox "~A ~A" a (type-of a)))
    (define-command-bar 'a-bar "a bar")
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))
  =&gt; t
  (tab-bar-current-item 'a-bar)
  =&gt; (1st "- 1st -" "1st item")
  (progn
    (tab-bar-delete-item 'a-bar '1st)
    (tab-bar-delete-item 'a-bar '2nd)
    (delete-tool-bar 'a-bar)
    (delete-command-bar 'a-bar))
  =&gt; t
</description>
<seealso>tab-bar-delete-item</seealso>
<seealso>tab-bar-add-item</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>tab-bar-add-item</title>
<type>Function</type>
<arguments>tab-bar-add-item BAR ITEM STRING &amp;optional TOOLTIP MENU &amp;key :FIRST :LAST :BEFORE :AFTER</arguments>
<package>editor</package>
<description>
create-tab-barで作成したタブバーBARにタブを追加します。タブを識別するた
めのITEMとタブの文字列STRINGを指定します。個別のツールチップTOOLTIPと、
メニューMENUを指定可能です。
</description>
<seealso>tab-bar-delete-item</seealso>
<seealso>create-tab-bar</seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>create-tab-bar</title>
<type>Function</type>
<arguments>create-tab-bar BAR CALLBACK</arguments>
<package>editor</package>
<description>
タブバーの識別子BARと、タブが選択されたとき実行するコールバック関数
CALLBACKを指定して、タブバーを作成します。CALLBACKは、各タブの作成時に設
定したシンボルが渡されます。

使用例：
  (progn
    (defun a-func (a) (msgbox "~A ~A" a (type-of a)))
    (define-command-bar 'a-bar "a bar")
    (create-tab-bar 'a-bar 'a-func)
    (show-command-bar 'a-bar)
    (tab-bar-add-item 'a-bar '1st "- 1st -" "1st item")
    (tab-bar-add-item 'a-bar '2nd "- 2nd -" "2nd item"))
  =&gt; t  
  (progn
    (tab-bar-delete-item 'a-bar '1st)
    (tab-bar-delete-item 'a-bar '2nd)
    (delete-tool-bar 'a-bar)
    (delete-command-bar 'a-bar))
  =&gt; t
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>next-error</title>
<type>Function</type>
<arguments>next-error &amp;optional ARG</arguments>
<package>editor</package>
<description>
次のエラーの該当行にジャンプします。
</description>
<seealso>*error-regexp-list*</seealso>
<seealso>first-error</seealso>
<link></link>
<section>エラー</section>
<file>errors.l</file>
</chapter>

<chapter>
<title>*error-regexp-list*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
first-error/next-errorで使用するエラー発生位置の表記形式を変更することが可能です。
*error-regexp-list*の形式は以下のとおりです。

  ((正規表現1 ファイル名のマッチ位置1 行のマッチ位置1)
   (正規表現2 ファイル名のマッチ位置2 行のマッチ位置2)
    ...
   (正規表現N ファイル名のマッチ位置N 行のマッチ位置N))

[xyzzy:05447]で亀井さんが示しているとおり、pushを使って追加するのが無難です。
(push (list (compile-regexp "^\"\\([^\"\n]+\\)\", line \\([0-9]+\\):") 1 2)
      *error-regexp-list*)
</description>
<seealso>next-error</seealso>
<seealso>first-error</seealso>
<link></link>
<section>エラー</section>
<file>errors.l</file>
</chapter>

<chapter>
<title>first-error</title>
<type>Function</type>
<arguments>first-error &amp;optional ARG WRAP</arguments>
<package>editor</package>
<description>
grep後の*compilation*バッファ上で実行すると、該当行へジャンプ可能です。
以後は、next-error(F11)を押すことで次々と該当行へジャンプ可能です。
各種コンパイラの出力結果に応じてジャンプすることも可能です。
また、コンパイラのエラー出力が標準に対応していなくても、
*error-regexp-list*を変更することで対応が可能な場合があります。
</description>
<seealso>next-error</seealso>
<link></link>
<section>エラー</section>
<file>errors.l</file>
</chapter>

<chapter>
<title>select-buffer</title>
<type>Function</type>
<arguments>select-buffer</arguments>
<package>editor</package>
<description>
バッファを選択するダイアログを表示します。
デフォルトではC-p/C-nで上下し、C-mで選択します。
buffer-menuのようなバッファの削除などはできません。
※正確には*std-control-xxx-char*の設定に依ります。
</description>
<seealso>buffer-menu</seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>toggle-over</title>
<type>Function</type>
<arguments>toggle-over &amp;optional (ARG () SV)</arguments>
<package>editor</package>
<description>
上書き用マイナーモードを制御します。
  nil以外  上書きモードにする
  nil      挿入モードにする
  省略時   モードをトグルする
</description>
<seealso></seealso>
<link></link>
<section>モード</section>
<file></file>
</chapter>

<chapter>
<title>transpose-chars</title>
<type>Function</type>
<arguments>transpose-chars &amp;optional (ARG 1 F)</arguments>
<package>editor</package>
<description>
ポイントのひとつ前の文字を、ポイントの位置の文字と交換します。
ポイント自体はひとつ前に進みます。
</description>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>call-last-kbd-macro</title>
<type>Function</type>
<arguments>call-last-kbd-macro &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
start-kbd-macro/end-kbd-macroで登録したキーボードマクロを実行します。
[ツール(T)]-[キーボードマクロおまけ(O)]-[保存]したキーボードマクロは、
[ツール(T)]-[キーボードマクロおまけ(O)]-[読み込み]で後から選択することが可能です。
</description>
<seealso></seealso>
<link></link>
<section>マクロ</section>
<file>kbdmacro.l</file>
</chapter>

<chapter>
<title>newline-and-indent</title>
<type>Function</type>
<arguments>newline-and-indent &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
改行後、文字が存在する直前の行と同じ桁数だけインデントをします。
モードに依存したインデントコマンドは使用しません。
</description>
<seealso></seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>delete-char-or-selection</title>
<type>Function</type>
<arguments>delete-char-or-selection &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
セレクションで選択中ならばセレクション全体を、そうでなければカーソルの位
置の文字を削除します。delete-charとはセレクション時の動作が異なります。
</description>
<seealso>delete-char</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>beginning-of-line</title>
<type>Function</type>
<arguments>beginning-of-line</arguments>
<package>editor</package>
<description>
行頭に移動します。goto-bolのinteractive版です。
</description>
<seealso>end-of-line</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>macro-function</title>
<type>Function</type>
<arguments>macro-function SYMBOL</arguments>
<package>lisp</package>
<description>
SYMBOLがマクロか否かを返します。マクロの場合にはその内容を返します。
使用例：
  (macro-function 'car)
  =&gt;nil

  (macro-function 'when)
  =&gt;(macro (lisp::test &amp;body lisp::body)
         (block when (list 'if lisp::test (cons 'progn lisp::body))))
</description>
<seealso>fboundp</seealso>
<seealso>boundp</seealso>
<link></link>
<section>マクロ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>regexp-quote</title>
<type>Function</type>
<arguments>regexp-quote REGEXP</arguments>
<package>editor</package>
<description>
REGEXPのメタ文字をエスケープした表現を返します。
例えば、「正規表現のメタ文字を含む文字列」を含む
正規表現で検索したい場合に便利です。
使用例：
  (regexp-quote "a+b*")
  =&gt;"a\\+b\\*"
</description>
<seealso></seealso>
<link></link>
<section>検索・正規表現</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>remove-trail-slash</title>
<type>Function</type>
<arguments>remove-trail-slash STRING</arguments>
<package>editor</package>
<description>
STRINGの末尾に"/"があれば削除した文字列を返します。
使用例：
  (remove-trail-slash "ffjfj")
  =&gt;"ffjfj"

  (remove-trail-slash "ffjfj/")
  =&gt;"ffjfj"
</description>
<seealso>append-trail-slash</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-property</title>
<type>Function</type>
<arguments>file-property PATHNAME</arguments>
<package>editor</package>
<description>
PATHNAMEのファイルのプロパティを表示します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (file-property a)
  =&gt;t
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>eject-media</title>
<type>Function</type>
<arguments>eject-media DRIVE</arguments>
<package>editor</package>
<description>
DRIVEに指定したドライブをイジェクトします。
DRIVEはキャラクタで指定します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"
  
  (eject-media (svref a 0)) ; イジェクト不可能なドライブ
  =&gt;指定されたデバイス名は無効です。 

  (eject-media #\P)
  =&gt;t
(svref (default-directory) 0))
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>get-short-path-name</title>
<type>Function</type>
<arguments>get-short-path-name PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEの8.3形式でのパスを返します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (get-short-path-name a)
  =&gt;"C:/APPLIC~2/xyzzy/xyzzy.exe"
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-outcode</title>
<type>Function</type>
<arguments>process-outcode PROCESS</arguments>
<package>editor</package>
<description>
PROCESSに設定された出力用の漢字コードを指定します。
</description>
<seealso>set-process-outcode</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-incode</title>
<type>Function</type>
<arguments>process-incode PROCESS</arguments>
<package>editor</package>
<description>
PROCESSに設定された入力用の漢字コードを指定します。
</description>
<seealso>set-process-incode</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-eol-code</title>
<type>Function</type>
<arguments>process-eol-code PROCESS</arguments>
<package>editor</package>
<description>
PROCESSに設定された改行コードを返します。
</description>
<seealso>set-process-eol-code</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-process-eol-code</title>
<type>Function</type>
<arguments>set-process-eol-code PROCESS CODE</arguments>
<package>editor</package>
<description>
PROCESSで処理する場合の改行コードCODEを設定します。
</description>
<seealso>process-eol-code</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-sentinel</title>
<type>Function</type>
<arguments>process-sentinel PROCESS</arguments>
<package>editor</package>
<description>
PROCESSに設定されたSENTINEL用の関数を返します。
</description>
<seealso>set-process-sentinel</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-filter</title>
<type>Function</type>
<arguments>process-filter PROCESS</arguments>
<package>editor</package>
<description>
PROCESSに設定されたFILTER用の関数を返します。
</description>
<seealso>set-process-filter</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>namestring</title>
<type>Function</type>
<arguments>namestring PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEの内容に応じて適切なフルパスを返すような動きをする。与えたのがフ
ルパスでなければ、先頭に(default-directory)を補ってフルパスらしくします。
使用例：
  (default-directory)
  =&gt;"C:/Applications/xyzzy/"

  (namestring "abc.txt")
  =&gt;"C:/Applications/xyzzy/abc.txt"

  (namestring "Z:/zzz.txt")
  =&gt;"Z:/zzz.txt"
</description>
<seealso>file-namestring</seealso>
<link></link>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-name</title>
<type>Function</type>
<arguments>pathname-name PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのファイル名（拡張子無し）を返します。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (pathname-name a)
  =&gt;"xyzzy"
</description>
<seealso>pathname-type</seealso>
<seealso>pathname-directory</seealso>
<seealso>pathname-device</seealso>
<seealso>pathname-host</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-directory</title>
<type>Function</type>
<arguments>pathname-directory PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのディレクトリ名を返します。各階層ごとの名前を要素とするリスト形
式で返されます。
使用例：
  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (pathname-directory a)
  =&gt;("Applications" "xyzzy")
</description>
<seealso>pathname-type</seealso>
<seealso>pathname-name</seealso>
<seealso>pathname-device</seealso>
<seealso>pathname-host</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-device</title>
<type>Function</type>
<arguments>pathname-device PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのドライブ名を返します。
使用例：
  (setq a "//SAMURAI/Applications/xyzzy/xyzzy.exe")
  =&gt; "//SAMURAI/Applications/xyzzy/xyzzy.exe"

  (pathname-device a)
  =&gt; nil

  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt; "C:/Applications/xyzzy/xyzzy.exe"

  (pathname-device a)
  "C"
</description>
<seealso>pathname-type</seealso>
<seealso>pathname-name</seealso>
<seealso>pathname-directory</seealso>
<seealso>pathname-host</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-host</title>
<type>Function</type>
<arguments>pathname-host PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEのホスト名を返します。
使用例：
  (setq a "//SAMURAI/Applications/xyzzy/xyzzy.exe")
  =&gt;"//SAMURAI/Applications/xyzzy/xyzzy.exe"

  (pathname-host a)
  =&gt;"SAMURAI"

  (setq a (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (pathname-host a)
  =&gt;nil
</description>
<seealso>pathname-type</seealso>
<seealso>pathname-name</seealso>
<seealso>pathname-directory</seealso>
<seealso>pathname-device</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>streamp</title>
<type>Function</type>
<arguments>streamp OBJECT</arguments>
<package>lisp</package>
<description>
OBJECTがストリームか否かを返します。
  t    OBJECTはストリームである。
  nil  OBJECTはストリームでない。
</description>
<seealso></seealso>
<link></link>
<section>入出力</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pathname-match-p</title>
<type>Function</type>
<arguments>pathname-match-p PATHNAME WILDNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEがWILDNAMEで指定されたワイルドカードにマッチするるかどうかを返します。
  t    PATHNAMEがWILDNAMEにマッチする。
  nil  PATHNAMEがWILDNAMEにマッチしない。

使用例：
  (setq p (merge-pathnames "xyzzy.exe" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.exe"

  (setq w (merge-pathnames "xyzzy.*" (si:system-root)))
  =&gt;"C:/Applications/xyzzy/xyzzy.*"

  (wild-pathname-p p)
  =&gt;nil

  (wild-pathname-p w)
  =&gt;t

  (pathname-match-p p w)
  =&gt;t
</description>
<seealso>wild-pathname-p</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>special-file-p</title>
<type>Function</type>
<arguments>special-file-p PATHNAME</arguments>
<package>lisp</package>
<description>
PATHNAMEがデバイスファイル(CON, AUX, NUL, PRN, LPT1/2/3/4, COM1/2/3/4)か
否かを返します。
  t    デバイスファイルである。
  nil  デバイスファイルでない。
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>file-executable-p</title>
<type>Function</type>
<arguments>file-executable-p PATHNAME</arguments>
<package>lisp</package>
<description>
注）何故か実行ファイルでも、tが返らない気がする。
PATHNAMEが実行ファイルか否かを返します。

  t    実行ファイルである。
  nil  実行ファイルではない。
</description>
<seealso>file-exist-p</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>imagpart</title>
<type>Function</type>
<arguments>imagpart NUMBER</arguments>
<package>lisp</package>
<description>
複素数の虚数部を取得します。

使用例：
  (setq a (complex 1 3))
  =&gt;#C(1 3)

  (imagpart a)
  =&gt;3
</description>
<seealso>realpart</seealso>
<seealso>complex</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>realpart</title>
<type>Function</type>
<arguments>realpart NUMBER</arguments>
<package>lisp</package>
<description>
複素数の実数部を取得します。

使用例：
  (setq a (complex 1 3))
  =&gt;#C(1 3)

  (realpart a)
  =&gt;1
</description>
<seealso>imagpart</seealso>
<seealso>complex</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>complex</title>
<type>Function</type>
<arguments>complex REALPART &amp;optional IMAGPART</arguments>
<package>lisp</package>
<description>
指定された実数部(REALPART)と虚数部(IMAGPART)で複素数を表現します。

使用例：
  (setq a (complex 0 1))
  =&gt;#C(0 1)

  (* a a)
  =&gt;-1
</description>
<seealso>imagpart</seealso>
<seealso>realpart</seealso>
<link></link>
<section>数値</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>wrong-disk</title>
<type>Misc</type>
<arguments></arguments>
<package>lisp</package>
<description>
注）どこにもみつからない？
</description>
<seealso>wrong-disk-pathname</seealso>
<link></link>
<section>ファイルシステム</section>
<file></file>
</chapter>

<chapter>
<title>wrong-disk-pathname</title>
<type>Function</type>
<arguments>wrong-disk-pathname X</arguments>
<package>lisp</package>
<description>
注）どこにもみつからない？
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file></file>
</chapter>

<chapter>
<title>yank</title>
<type>Function</type>
<arguments>yank &amp;optional PREFIX (ARG 0)</arguments>
<package>editor</package>
<description>
*kill-ring*の先頭の要素を挿入します。
</description>
<seealso>kill</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>yank-rectangle-as-region</title>
<type>Function</type>
<arguments>yank-rectangle-as-region</arguments>
<package>editor</package>
<description>
copy-rectangleで切り取った矩形領域を、
連続した一連の文字列として挿入します。

  ABCDEFG ;
  HIJKLMN ; JKL
  OPQRSTU ; QRS
  VWXYZ   ; XYZの領域をcopy-rectangle

  (yank-rectangle)
  =&gt;JKL
    QRS
    XYZ

  (yank-rectangle-as-region)
  =&gt;JKLQRSXYZ

</description>
<seealso>yank-rectangle</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>yank-selection-and-pop</title>
<type>Function</type>
<arguments>yank-selection-and-pop &amp;optional (ARG 0)</arguments>
<package>editor</package>
<description>
*selection-ring*の先頭の要素をyank-selectionした後に、
先頭の要素を*selection-ring*からpopします。
*selection-ring*は一要素分短くなります。
</description>
<seealso>yank-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>copy-selection</title>
<type>Function</type>
<arguments>copy-selection</arguments>
<package>editor</package>
<description>
選択された領域をコピーして、*selection-ring*の先頭に追加します。
追加した内容はyank-selectionで貼り付けられます。
デフォルトでは'F8'に割り付けられています。
</description>
<seealso>yank-selection</seealso>
<seealso>kill-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>kill-selection</title>
<type>Function</type>
<arguments>kill-selection</arguments>
<package>editor</package>
<description>
選択された領域を切り取り、*selection-ring*の先頭に追加します。
追加した内容はyank-selectionで貼り付けられます。
デフォルトでは'F7'に割り付けられています。
</description>
<seealso>yank-selection</seealso>
<seealso>copy-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>*selection-ring*</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
copy-selectionやkill-selectionで切り取った選択された領域を管理します。
*selection-ring*は*kill-ring*と同様にリングバッファとして管理されます。
</description>
<seealso>yank-selection</seealso>
<seealso>copy-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>yank-selection</title>
<type>Function</type>
<arguments>yank-selection &amp;optional (ARG 0)</arguments>
<package>editor</package>
<description>
*selection-ring*の先頭の要素を貼り付けます。
*selection-ring*へはcopy-selectionもしくはkill-selectionで追加します。
デフォルトでは'F9'に割り付けられています。
</description>
<seealso>kill-selection</seealso>
<seealso>copy-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>yank-and-pop</title>
<type>Function</type>
<arguments>yank-and-pop &amp;optional PREFIX (ARG 0)</arguments>
<package>editor</package>
<description>
*kill-ring*の先頭の要素をyankした後に、先頭の要素を*kill-ring*からpopします。
*kill-ring*は一要素分短くなります。
</description>
<seealso>yank-pop</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>unshift-region</title>
<type>Function</type>
<arguments>unshift-region START END &amp;optional (COLUMN (TAB-COLUMNS (SELECTED-BUFFER)))</arguments>
<package>editor</package>
<description>
STARTとENDがある行の範囲をCOLUMN桁だけインデントを戻します。
</description>
<seealso>shift-region</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>shift-region</title>
<type>Function</type>
<arguments>shift-region START END &amp;optional (COLUMN (TAB-COLUMNS (SELECTED-BUFFER)))</arguments>
<package>editor</package>
<description>
STARTとENDがある行の範囲をCOLUMN桁だけインデントします。
</description>
<seealso>unshift-region</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>yank-to-clipboard</title>
<type>Function</type>
<arguments>yank-to-clipboard &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
*kill-ring*の内容をクリップボードに複写します。
</description>
<seealso>copy-to-clipboard</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>previous-virtual-line</title>
<type>Function</type>
<arguments>previous-virtual-line &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
N行前の表示行に移動します。
  t    先頭行以外の場合
  nil  先頭行の場合
</description>
<seealso>previous-line</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>next-virtual-line</title>
<type>Function</type>
<arguments>next-virtual-line &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
N行後の表示行に移動します。
  t    最終行以外の場合
  nil  最終行の場合
</description>
<seealso>next-line</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>next-line</title>
<type>Function</type>
<arguments>next-line &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
N行後の物理行に移動します。
  t    最終行以外の場合
  nil  最終行の場合
</description>
<seealso>next-virtual-line</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>paste-rectangle-from-clipboard</title>
<type>Function</type>
<arguments>paste-rectangle-from-clipboard</arguments>
<package>editor</package>
<description>
paste-from-clipboardとは異なり、クリップボードの内容を矩形で貼り付けます。
</description>
<seealso>paste-from-clipboard</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>paste-from-clipboard</title>
<type>Function</type>
<arguments>paste-from-clipboard</arguments>
<package>editor</package>
<description>
クリップボードの内容を貼り付けます。
</description>
<seealso>paste-rectangle-from-clipboard</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>kill-region-to-clipboard</title>
<type>Function</type>
<arguments>kill-region-to-clipboard FROM TO</arguments>
<package>editor</package>
<description>
FROMとTOで指定される領域を削除したのち、クリップボードにコピーします。
</description>
<seealso>kill-rectangle-selection-to-clipboard</seealso>
<seealso>kill-region</seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>kill-rectangle-selection-to-clipboard</title>
<type>Function</type>
<arguments>kill-rectangle-selection-to-clipboard</arguments>
<package>editor</package>
<description>
マウスで矩形選択されたセレクションの領域を削除した後、クリップボードにコ
ピーします。
</description>
<seealso>kill-rectangle-selection</seealso>
<seealso>copy-rectangle-selection-to-clipboard</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>copy-rectangle-selection-to-clipboard</title>
<type>Function</type>
<arguments>copy-rectangle-selection-to-clipboard</arguments>
<package>editor</package>
<description>
マウスで矩形選択されたセレクションの領域をクリップボードにコピーします。
</description>
<seealso>kill-rectangle-selection-to-clipboard</seealso>
<seealso>copy-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>copy-rectangle-selection</title>
<type>Function</type>
<arguments>copy-rectangle-selection</arguments>
<package>editor</package>
<description>
マウスで矩形選択されたセレクションの領域をコピーします。yankには
yank-rectangle-selectionを使いますが、yank-rectangleでも行けそうです。
コピーした内容は*kill-ring*ともクリップボードとも違う領域に格納されてい
るようです。
</description>
<seealso>kill-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>copy-rectangle</title>
<type>Function</type>
<arguments>copy-rectangle P1 P2</arguments>
<package>editor</package>
<description>
P1とP2で指定される矩形領域をコピーします。コピーした矩形領域のyankには、
yank-rectangleを使います。
</description>
<seealso>kill-rectangle</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>continue-popup</title>
<type>Function</type>
<arguments>continue-popup</arguments>
<package>editor</package>
<description>
popup-stringで前回表示した内容を再度表示します。
</description>
<seealso>popup-string</seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>bobp</title>
<type>Function</type>
<arguments>bobp</arguments>
<package>editor</package>
<description>
ポイントがバッファの先頭にあるか否かを返します。
  t    ポイントがバッファの先頭にある。
  nil  ポイントがバッファの先頭にはない。
</description>
<seealso>eobp</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>autoload-function-p</title>
<type>Function</type>
<arguments>autoload-function-p DEF</arguments>
<package>lisp</package>
<description>
指定された関数がautoloadされたか否かを返します。
  nil 指定された関数がautoload済み
      もしくはautoloadしない関数の場合
  t   指定された関数がautoload前の場合

使用例：
  (export 'lisp-info-F1)
  (autoload 'lisp-info-F1 "info-modoki" t)
  (autoload-function-p 'lisp-info-F1)
  =&gt; t
  (lisp-info-F1)
  (autoload-function-p 'lisp-info-F1)
  =&gt; nil
</description>
<seealso>autoload</seealso>
<link></link>
<section>関数</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>yank-rectangle</title>
<type>Function</type>
<arguments>yank-rectangle</arguments>
<package>editor</package>
<description>
copy-rectangleやkill-rectangleによって選択された領域を矩形挿入します。
yank-rectangle-selectionのInsert相当の機能のようです。
</description>
<seealso>kill-rectangle</seealso>
<seealso>yank-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>yank-rectangle-selection</title>
<type>Function</type>
<arguments>yank-rectangle-selection</arguments>
<package>editor</package>
<description>
マウスで矩形選択されたセレクションの領域をyankします。
実行後にどのようにyankするかを質問されます。
  F6    Cancel                  yank中止
  F7    Append                  行末に追加
  F8    Overwrite               上書き
  F9    Insert                  挿入
  F10   Insert as region        文字列にして挿入
</description>
<seealso>yank-rectangle</seealso>
<seealso>kill-rectangle-selection</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>kill-rectangle-selection</title>
<type>Function</type>
<arguments>kill-rectangle-selection</arguments>
<package>editor</package>
<description>
マウスで矩形選択されたセレクションの領域をkillします。
yankにはyank-rectangle-selectionを使いますが、yank-rectangleでも行けそうです。
killした内容は*kill-ring*ともクリップボードとも違う領域に格納されているようです。
</description>
<seealso>kill-rectangle</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>set-process-sentinel</title>
<type>Function</type>
<arguments>set-process-sentinel PROCESS SENTINEL</arguments>
<package>editor</package>
<description>
プロセスが終了する場合に呼ばれる関数（いわゆるSENTINEL）を指定します。
</description>
<seealso>set-process-filter</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-process-incode</title>
<type>Function</type>
<arguments>set-process-incode PROCESS CODE</arguments>
<package>editor</package>
<description>
プロセスからset-process-filterに入力がある場合の漢字コードを指定します。
</description>
<seealso>set-process-outcode</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-process-outcode</title>
<type>Function</type>
<arguments>set-process-outcode PROCESS CODE</arguments>
<package>editor</package>
<description>
プロセスに対してsend-process-stringをする場合の漢字コードを指定します。
</description>
<seealso>set-process-incode</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-process-filter</title>
<type>Function</type>
<arguments>set-process-filter PROCESS FILTER</arguments>
<package>editor</package>
<description>
プロセスの出力を加工するためのフィルタを指定します。
</description>
<seealso>set-process-outcode</seealso>
<seealso>set-process-incode</seealso>
<seealso>set-process-sentinel</seealso>
<seealso>process-send-string</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-status</title>
<type>Function</type>
<arguments>process-status PROCESS</arguments>
<package>editor</package>
<description>
指定されたプロセスの状態を返します。

  :run  動作中
  :exit 停止
</description>
<seealso>kill-process</seealso>
<seealso>make-process</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>process-buffer</title>
<type>Function</type>
<arguments>process-buffer PROCESS</arguments>
<package>editor</package>
<description>
プロセスが割り付けられているバッファを返します。
</description>
<seealso>buffer-process</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kill-subprocess</title>
<type>Function</type>
<arguments>kill-subprocess</arguments>
<package>editor</package>
<description>
バッファに割り付けられているプロセスを停止させます。
</description>
<seealso>kill-process</seealso>
<seealso>make-process</seealso>
<link></link>
<section>プロセス</section>
<file>process.l</file>
</chapter>

<chapter>
<title>kill-rectangle</title>
<type>Function</type>
<arguments>kill-rectangle P1 P2</arguments>
<package>editor</package>
<description>
P1とP2で指定される矩形領域をkillします。
killした矩形領域のyankには、yank-rectangleを使います。
通常の*kill-ring*とは別の領域に格納されているようです。
</description>
<seealso>kill-region</seealso>
<link></link>
<section>リージョン</section>
<file>rectangl.l</file>
</chapter>

<chapter>
<title>kill-process</title>
<type>Function</type>
<arguments>kill-process PROCESS</arguments>
<package>editor</package>
<description>
プロセスを強制的に終了させます。
</description>
<seealso>make-process</seealso>
<link></link>
<section>プロセス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>backward-kill-paragraph</title>
<type>Function</type>
<arguments>backward-kill-paragraph &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
現在のパラグラフの先頭までkillします。
</description>
<seealso>kill-paragraph</seealso>
<seealso>kill-region</seealso>
<link></link>
<section>リージョン</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>kill-paragraph</title>
<type>Function</type>
<arguments>kill-paragraph &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
現在のパラグラフの最後までkillします。
</description>
<seealso>kill-region</seealso>
<seealso>backward-kill-paragraph</seealso>
<link></link>
<section>リージョン</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>kill-line</title>
<type>Function</type>
<arguments>kill-line &amp;optional LINES</arguments>
<package>editor</package>
<description>
一行だけkillします。
ポイントが行末ならば改行コードだけをkillします。
ポイントが行末でなければ改行コードの直前までkillします。
</description>
<seealso>kill-region</seealso>
<link></link>
<section>リージョン</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>dump-xyzzy</title>
<type>Function</type>
<arguments>dump-xyzzy &amp;optional FILENAME</arguments>
<package>editor</package>
<description>
ダンプファイルをFILENAMEにして作成します。
既に作成されていても上書きします。
FILENAME省略時のファイル名は？（未確認）
</description>
<seealso>version-up-xyzzy</seealso>
<link></link>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>version-up-xyzzy</title>
<type>Function</type>
<arguments>version-up-xyzzy &amp;rest ARGS</arguments>
<package>editor</package>
<description>
亀井さんが配布しているxyzzyのアーカイブファイルをXYZZYHOMEに展開します。
別途、ダンプファイルの再作成をする必要があります。
</description>
<seealso>dump-xyzzy</seealso>
<link></link>
<section>システム</section>
<file>verup.l</file>
</chapter>

<chapter>
<title>virtual-eolp</title>
<type>Function</type>
<arguments>virtual-eolp</arguments>
<package>editor</package>
<description>
仮想行の行末にあるかを返します。
バッファが行を折り返して表示している場合に有効です。

  t     仮想行の行末にある
  nil   仮想行の行末にない
</description>
<seealso>virtual-bolp</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>virtual-bolp</title>
<type>Function</type>
<arguments>virtual-bolp</arguments>
<package>editor</package>
<description>
仮想行の行頭にあるかを返します。
バッファが行を折り返して表示している場合に有効です。

  t     仮想行の行頭にある
  nil   仮想行の行頭にない
</description>
<seealso>virtual-eolp</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>window-width</title>
<type>Function</type>
<arguments>window-width &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
指定されたウィンドウの幅をキャラクタ単位で返します。
</description>
<seealso></seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>windowp</title>
<type>Function</type>
<arguments>windowp OBJECT</arguments>
<package>editor</package>
<description>
指定されたOBJECTがウィンドウかを返します。

  t     OBJECTがウィンドウ
  nil   OBJECTはウィンドウではない
</description>
<seealso></seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>xyzzy-dumped-p</title>
<type>Function</type>
<arguments>xyzzy-dumped-p</arguments>
<package>editor</package>
<description>
起動時にxyzzyがダンプ済みかどうかを返します。

  t     ダンプ済み
  nil   ダンプ済みではない

ダンプ作業をしても再起動するまでは戻り値はtになりません。
</description>
<seealso></seealso>
<link></link>
<section>システム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>need-buffer-save-p</title>
<type>Function</type>
<arguments>need-buffer-save-p BUFFER</arguments>
<package>editor</package>
<description>
バッファが保存が必要かを返します。
need-not-saveと関連しています。

  t     バッファの保存が必要
  nil   バッファの保存が必要ではない
</description>
<seealso>need-not-save</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>zap-to-char</title>
<type>Function</type>
<arguments>zap-to-char C &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
ポイントから指定されたキャラクタまでをkillします。
</description>
<seealso></seealso>
<link></link>
<section>文字</section>
<file>cmds.l</file>
</chapter>


<chapter>
<title>package-name</title>
<type>Function</type>
<arguments>package-name PACKAGE</arguments>
<package>lisp</package>
<description>
パッケージの名称を取得します。

使用例：
  (package-name (find-package "ed"))
  =&gt; "editor"
</description>
<seealso>find-package</seealso>
<link></link>
<section>パッケージ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>refresh-tool-bars</title>
<type>Function</type>
<arguments>refresh-tool-bars</arguments>
<package>editor</package>
<description>
ツールバーをリフレッシュします。
lisp/optprop.lの中から共通設定の変更内容を、ツールバーに反映するために用
いられています。
</description>
<seealso></seealso>
<link></link>
<section>メニュー</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>unicode-char</title>
<type>Function</type>
<arguments>unicode-char CODE</arguments>
<package>editor</package>
<description>
UNICODEのコード値に対応した文字を返します。

使用例：
  ;;; UNICODEから文字を出してみる。
  (unicode-char 28450)
  =&gt; #\漢
</description>
<seealso>char-unicode</seealso>
<link></link>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-unicode</title>
<type>Function</type>
<arguments>char-unicode CHAR</arguments>
<package>editor</package>
<description>
文字のUNICODEのコード値を返します。

使用例：
  ;;; UNICODEのコード値を取得してみる。
  (char-unicode #\x00)  =&gt; 0
  (char-unicode #\a)    =&gt; 97
  (char-unicode #\漢)   =&gt; 28450
</description>
<seealso></seealso>
<link></link>
<section>文字</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>char-name</title>
<type>Function</type>
<arguments>char-name C</arguments>
<package>editor</package>
<description>
文字の英字名称を返します。
この英字名称はどこで定義されたものなのでしょうか？

使用例：
  ;;; いろいろと英字名称を見てみる。
  (char-name #\x00)     =&gt; "null"
  (char-name #\x0a)     =&gt; "line_feed"
  (char-name #\x0d)     =&gt; "carriage_return"
  (char-name #\a)       =&gt; "latin_small_letter_a"
  (char-name #\が)      =&gt; "hiragana_letter_ga"
  (char-name #\ヲ)      =&gt; "katakana_letter_wo"
  (char-name #\漢)      =&gt; nil 
</description>
<seealso></seealso>
<link></link>
<section>文字</section>
<file>misc.l</file>
</chapter>

<chapter>
<title>skip-token</title>
<type>Function</type>
<arguments>skip-token</arguments>
<package>editor</package>
<description>
多分シンボル構成文字と単語構成文字をスキップします。
（詳細不明）
</description>
<seealso></seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kanji-char-p</title>
<type>Function</type>
<arguments>kanji-char-p CHAR</arguments>
<package>editor</package>
<description>
文字CHARが漢字かを返します。
（詳細不明）
</description>
<seealso>kana-char-p</seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kana-char-p</title>
<type>Function</type>
<arguments>kana-char-p CHAR</arguments>
<package>editor</package>
<description>
文字が半角カナ文字かを返します。

  t    半角カナ文字である。
  nil  半角カナ文字でない。

カナ文字は以下の範囲です。
  Code          Char
  ----          ----
  0xa1 .. 0xb0  #\｡ .. #\ｰ
  0xb1 .. 0xdd  #\ｱ .. #\ﾝ
  0xde          #\ﾞ
  0xdf          #\ﾟ
</description>
<seealso>kanji-char-p</seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>format-drive</title>
<type>Function</type>
<arguments>format-drive &amp;optional DRIVE QUICK</arguments>
<package>editor</package>
<description>
ドライブをフォーマットします。

  DRIVE : ドライブを文字で指定します。

使用例：
  (format-drive #\a t)
  =&gt; nil
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>default-value</title>
<type>Function</type>
<arguments>default-value SYMBOL</arguments>
<package>lisp</package>
<description>
シンボルのデフォルトの値を返します。
シンボルがバッファローカルでないならば、symbol-valueと同じ値を返します。
シンボルがバッファローカルの時にデフォルトの値を持たない場合には、エラー
になります。デフォルトの値はsetq-defaultで指定します。

使用例：
  ;;; シンボルがデフォルトの値を持たない場合
  (make-local-variable 'foo)    =&gt; t
  (setq foo 123)                =&gt; 123
  (default-value 'foo)          =&gt; 変数が定義されていません: foo

  ;;; バッファローカルなシンボルの場合
  (defvar-local bar 234)        =&gt; bar
  (setq bar 345)                =&gt; 345
  (default-value 'bar)          =&gt; 234
</description>
<seealso>symbol-value</seealso>
<link></link>
<section>シンボル</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>capitalize-region</title>
<type>Function</type>
<arguments>capitalize-region FROM TO</arguments>
<package>editor</package>
<description>
リージョン内の単語をcapitalizeします。
つまり、単語の先頭を大文字に、それ以外を小文字にします。
</description>
<seealso>downcase-region</seealso>
<seealso>upcase-region</seealso>
<link></link>
<section>リージョン</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>downcase-region</title>
<type>Function</type>
<arguments>downcase-region FROM TO</arguments>
<package>editor</package>
<description>
リージョン内の単語を小文字にします。
</description>
<seealso>capitalize-region</seealso>
<seealso>upcase-region</seealso>
<link></link>
<section>リージョン</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>upcase-region</title>
<type>Function</type>
<arguments>upcase-region FROM TO</arguments>
<package>editor</package>
<description>
リージョン内の単語を大文字にします。
</description>
<seealso>capitalize-region</seealso>
<seealso>downcase-region</seealso>
<link></link>
<section>リージョン</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>enlarge-window</title>
<type>Function</type>
<arguments>enlarge-window &amp;optional EXTEND VERTICAL</arguments>
<package>editor</package>
<description>
ウィンドウの行数・桁数を変更します。
VERTICALを指定しない場合には行数を変更します。

  EXTEND   : 大きくする行数・桁数を指定します。負数を指定すると小さくなります。
  VERTICAL : 桁・行のどちらを設定するか指定します。
        t       桁数を変更する。
        nil     行数を変更する。

使用例：
  ;;; ウィンドウを変更してみる。
  (enlarge-window 2 t)  =&gt; t
  (enlarge-window 100)  =&gt; 変更できません 
</description>
<seealso></seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>selected-window</title>
<type>Function</type>
<arguments>selected-window</arguments>
<package>editor</package>
<description>
現在アクティブなウィンドウを返します。

使用例：
  ;;; 現在のウィンドウを返してみる。
  (selected-window)
  =&gt; #&lt;window 54137832&gt;
</description>
<seealso>set-window</seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>current-virtual-line-number</title>
<type>Function</type>
<arguments>current-virtual-line-number</arguments>
<package>editor</package>
<description>
現在のポイントが表示行で何行目かを返します。
</description>
<seealso>goto-virtual-line</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goto-virtual-line</title>
<type>Function</type>
<arguments>goto-virtual-line LINE</arguments>
<package>editor</package>
<description>
表示行での指定行に移動します。
ウィンドウの表示行／物理行の切替は、「共通設定」－「表示」－「行番号は表示行(D)」で行います。

参考：
  ファイルイメージ： 
    001| ABCDEFGHIJKLMNOPQR
    002| ABCDEFGHIJKLMNOPQRS
    003| ABCDEFGHIJKLMNOPQRST
    004| ABCDEFGHIJKLMNOPQRSTU
    005| ABCDEFGHIJKLMNOPQRSTUV

                    │
      ┌──────┴──────┐
      ↓                          ↓

  物理行：                        表示行：                      
    001| ABCDEFGHIJKLMNOPQR         001| ABCDEFGHIJKLMNOPQR
    002| ABCDEFGHIJKLMNOPQRS        002| ABCDEFGHIJKLMNOPQRS
    003| ABCDEFGHIJKLMNOPQRST       003| ABCDEFGHIJKLMNOPQRST
    004| ABCDEFGHIJKLMNOPQRST       004| ABCDEFGHIJKLMNOPQRST
       | U                          005| U
    005| ABCDEFGHIJKLMNOPQRST       006| ABCDEFGHIJKLMNOPQRST
       | UV                         007| UV
</description>
<seealso>goto-line</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>enum-buffers</title>
<type>Function</type>
<arguments>enum-buffers FN</arguments>
<package>editor</package>
<description>
関数がnil以外を返すまでバッファを列挙し続けます。

使用例：
  ;;; バッファを列挙し続ける。
  (enum-buffers #'(lambda (x) (and (yes-or-no-p "~S" x) x)))
  =&gt; #&lt;buffer:  *Completion*&gt;
</description>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>kill-all-buffers</title>
<type>Function</type>
<arguments>kill-all-buffers &amp;optional NOT-VERBOSE</arguments>
<package>editor</package>
<description>
全バッファをkill-bufferします。
NOT-VERBOSEで保存するか否かを指定できます。

  NOT-VERBOSE :
        t       何も確認せずに保存しようとします。
        nil     変更があるバッファは確認のダイアログ表示されます。
</description>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>kill-selected-buffer</title>
<type>Function</type>
<arguments>kill-selected-buffer</arguments>
<package>editor</package>
<description>
名前のとおりselected-bufferをkill-bufferします。

参考：
  ;;; buffer.l
  (defun kill-selected-buffer ()
    (interactive)
    (kill-buffer (selected-buffer)))
</description>
<seealso>kill-buffer</seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>toggle-read-only</title>
<type>Function</type>
<arguments>toggle-read-only &amp;optional (ARG () SV)</arguments>
<package>editor</package>
<description>
バッファの書き込み禁止をトグルします。
</description>
<seealso></seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>not-modified</title>
<type>Function</type>
<arguments>not-modified</arguments>
<package>editor</package>
<description>
バッファの変更フラグをクリアします。
つまり変更されてないことになります。
(set-buffer-modified-p nil)のinteractive版です。
</description>
<seealso>set-buffer-modified-p</seealso>
<link></link>
<section>バッファ</section>
<file>buffer.l</file>
</chapter>

<chapter>
<title>markerp</title>
<type>Function</type>
<arguments>markerp OBJECT</arguments>
<package>editor</package>
<description>
指定されたOBJECTがマーカーかを返します。

  t     OBJECTはマーカー
  nil   OBJECTはマーカーではない
</description>
<seealso></seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>regexpp</title>
<type>Function</type>
<arguments>regexpp OBJECT</arguments>
<package>editor</package>
<description>
指定されたOBJECTがコンパイル済み正規表現かを返します。

  t     OBJECTはコンパイル済み正規表現
  nil   OBJECTはコンパイル済み正規表現ではない
</description>
<seealso></seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>processp</title>
<type>Function</type>
<arguments>processp OBJECT</arguments>
<package>editor</package>
<description>
指定されたOBJECTがプロセスかを返します。

  t     OBJECTはプロセス
  nil   OBJECTはプロセスではない
</description>
<seealso></seealso>
<link></link>
<section>データ型</section>
<file></file>
</chapter>

<chapter>
<title>set-goal-column</title>
<type>Function</type>
<arguments>set-goal-column COLUMN</arguments>
<package>editor</package>
<description>
ゴールカラムを設定します。save-excursionしてもgoal-columnが破壊されない
ように使用するぐらいでしょうか。

使用例：
  ;;; goal-columnを大事にして編集してみる。
  (let ((g (goal-column)))
    (save-excursion ... )
    (set-goal-column g))
  =&gt; t  
</description>
<seealso>goal-column</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>goal-column</title>
<type>Function</type>
<arguments>goal-column</arguments>
<package>editor</package>
<description>
現在のゴールカラムを取得します。
[xyzzy:06371] あたりのスレッドを見ると、save-excursionでゴールカラムが保
存されないのは仕様のようです。
</description>
<seealso>set-goal-column</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>keymapp</title>
<type>Function</type>
<arguments>keymapp OBJECT</arguments>
<package>editor</package>
<description>
指定されたOBJECTがキーマップかを返します。

  t    OBJECTはキーマップ
  nil  OBJECTはキーマップではない
</description>
<seealso></seealso>
<link></link>
<section>データ型</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>minor-mode-map</title>
<type>Function</type>
<arguments>minor-mode-map &amp;optional BUFFER</arguments>
<package>editor</package>
<description>
set-minor-mode-mapで設定したキーマップを取得します。
</description>
<seealso>set-minor-mode-map</seealso>
<link></link>
<section>モード</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>*modules*</title>
<type>Variable</type>
<arguments></arguments>
<package>lisp</package>
<description>
ロードされたモジュールの一覧が格納されています。
(require "foo")で実際にモジュールを読み込むか否かは*modules*に登録されて
いるかどうかで決まります。モジュールの中で(provide "foo")すると、そのモ
ジュールが*modules*に追加されます。

使用例：
  ;;; モジュールの一覧を見てみる。
  *modules*
  =&gt; ( ... )
  (provide "foo")
  =&gt; ("foo" ... )
  *modules*
  =&gt; ("foo" ... )
</description>
<seealso>provide</seealso>
<link></link>
<section>システム</section>
<file>evalmacs.l</file>
</chapter>

<chapter>
<title>skip-white-backward</title>
<type>Function</type>
<arguments>skip-white-backward</arguments>
<package>editor</package>
<description>
空白文字を後方にスキップします。
シンタックステーブル上でwhitespaceとして規定されている文字を後方に
スキップします。他にも影響する要素があるようですが詳細は不明。
</description>
<seealso>skip-white-forward</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>skip-white-forward</title>
<type>Function</type>
<arguments>skip-white-forward</arguments>
<package>editor</package>
<description>
空白文字を前方にスキップします
シンタックステーブル上でwhitespaceとして規定されている文字を前方に
スキップします。他にも影響する要素があるようですが詳細は不明。
</description>
<seealso>skip-white-backward</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pos-not-visible-in-window-p</title>
<type>Function</type>
<arguments>pos-not-visible-in-window-p POINT &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
指定されたポイントPOINTがウィンドウの表示範囲内にないかを返します。

  t     表示範囲内にない。
  nil   表示範囲内にある。
</description>
<seealso></seealso>
<link></link>
<section>ウィンドウ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pos-visible-in-window-p</title>
<type>Function</type>
<arguments>pos-visible-in-window-p POINT &amp;optional WINDOW</arguments>
<package>editor</package>
<description>
ポイントがウィンドウの表示範囲内にあるかを返します。

  t     表示範囲内にある。
  nil   表示範囲内にない。
</description>
<seealso></seealso>
<link></link>
<section>ウィンドウ</section>
<file>window.l</file>
</chapter>

<chapter>
<title>syntax-close-p</title>
<type>Function</type>
<arguments>syntax-close-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARが括弧などの終了文字として規定されているかを返します。

  t     終了文字である。
  nil   終了文字でない。
</description>
<seealso>set-syntax-match</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-open-p</title>
<type>Function</type>
<arguments>syntax-open-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARが括弧などの開始文字として規定されているかを返します。

  t     開始文字である。
  nil   開始文字でない。
</description>
<seealso>set-syntax-match</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-close-tag-p</title>
<type>Function</type>
<arguments>syntax-close-tag-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがタグの終了文字として規定されているかを返します。

  t     タグの終了文字である。
  nil   タグの終了文字でない。
</description>
<seealso>set-syntax-close-tag</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-open-tag-p</title>
<type>Function</type>
<arguments>syntax-open-tag-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがタグの開始文字として規定されているかを返します。

  t     タグの開始文字である。
  nil   タグの開始文字でない。
</description>
<seealso>set-syntax-open-tag</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>


<chapter>
<title>syntax-punctuation-p</title>
<type>Function</type>
<arguments>syntax-punctuation-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARが句読点文字として規定されているかを返します。

  t     句読点文字である。
  nil   句読点文字である。
</description>
<seealso>set-syntax-punctuation</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-punctuation</title>
<type>Function</type>
<arguments>set-syntax-punctuation SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字CHARを句読点文字として規定します。
ほとんど使うことはないでしょう。
</description>
<seealso>syntax-punctuation-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-escape-p</title>
<type>Function</type>
<arguments>syntax-escape-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがエスケープ文字として規定されているかを返します。

  t     エスケープ文字である。
  nil   エスケープ文字でない。
</description>
<seealso>set-syntax-escape</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-escape</title>
<type>Function</type>
<arguments>set-syntax-escape SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字CHARをエスケープ文字として規定します。
文字列中に限らず次の一文字の構文上の機能を抑制します。

使用例：
  ;;; c-mode.l
  (set-syntax-escape *c-mode-syntax-table* #\\)
</description>
<seealso>syntax-escape-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-math-p</title>
<type>Function</type>
<arguments>syntax-math-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARが対になった区切り文字として規定されているかを返します。

  t     対になった区切り文字である。
  nil   対になった区切り文字でない。
</description>
<seealso>set-syntax-math</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-junk-p</title>
<type>Function</type>
<arguments>syntax-junk-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがゴミ文字として規定されているかを返します。

  t     ゴミ文字である。
  nil   ゴミ文字でない。
</description>
<seealso>set-syntax-junk</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-end-comment-p</title>
<type>Function</type>
<arguments>syntax-end-comment-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがコメント終了文字として規定されているかを返します。

  t     コメント終了文字である。
  nil   コメント終了文字でない。
</description>
<seealso>set-syntax-end-comment</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-start-comment-p</title>
<type>Function</type>
<arguments>syntax-start-comment-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがコメント開始文字として規定されているかを返します。

  t     コメント開始文字である。
  nil   コメント開始文字でない。
</description>
<seealso>set-syntax-start-comment</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-math</title>
<type>Function</type>
<arguments>set-syntax-math SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字CHARを対になった区切り文字として規定します。
Latexの数式モードの区切りに相当します。

使用例：
  ;;; Latex.l
  (set-syntax-math *LaTeX-mode-syntax-table* #\$)
</description>
<seealso>syntax-math-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-junk</title>
<type>Function</type>
<arguments>set-syntax-junk SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字CHARをゴミ文字として規定します。
skip-syntax-spec-forward / skip-syntax-spec-backward でゴミ文字をスキッ
プするのに役に立つかもしれません。
</description>
<seealso>syntax-junk-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-end-comment</title>
<type>Function</type>
<arguments>set-syntax-end-comment SYNTAX-TABLE CHAR &amp;optional PARSE-SEXP-IGNORE-COMMENT-P MAYBE-COMMENT-END-P</arguments>
<package>editor</package>
<description>
文字CHARをコメント終了文字として規定します。

使用例：
  ;;; perl.l
  (set-syntax-end-comment *perl-mode-syntax-table* #\LFD)
</description>
<seealso>syntax-end-comment-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-start-comment</title>
<type>Function</type>
<arguments>set-syntax-start-comment SYNTAX-TABLE CHAR &amp;optional PARSE-SEXP-IGNORE-COMMENT-P</arguments>
<package>editor</package>
<description>
文字CHARをコメント開始文字として規定します。

使用例：
  ;;; perl.l
  (set-syntax-start-comment *perl-mode-syntax-table* #\#)
</description>
<seealso>syntax-start-comment-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-end-c++-comment-p</title>
<type>Function</type>
<arguments>syntax-end-c++-comment-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがC++スタイルのコメントの終了文字として規定されているかを返します。

  t     終了文字である。
  nil   終了文字でない。
</description>
<seealso>set-syntax-end-c++-comment</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-c++-comment-p</title>
<type>Function</type>
<arguments>syntax-c++-comment-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがC++スタイルのコメントの開始文字として規定されているかを返します。

  t     開始文字である。
  nil   開始文字でない。
</description>
<seealso>set-syntax-start-c++-comment</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-end-c++-comment</title>
<type>Function</type>
<arguments>set-syntax-end-c++-comment SYNTAX-TABLE CHAR &amp;optional PARSE-SEXP-IGNORE-COMMENT-P</arguments>
<package>editor</package>
<description>
文字CHARをC++スタイルのコメントの終了文字として規定します。
開始文字と異なり、終了文字は同じ文字を二つ連ねません。

使用例：
  ;;; cc-mode.l
  (set-syntax-end-c++-comment *c++-mode-syntax-table* #\LFD)
</description>
<seealso>syntax-end-c++-comment-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-start-c++-comment</title>
<type>Function</type>
<arguments>set-syntax-start-c++-comment SYNTAX-TABLE CHAR &amp;optional PARSE-SEXP-IGNORE-COMMENT-P</arguments>
<package>editor</package>
<description>
文字CHARをC++スタイルのコメントの開始文字として規定します。
「C++スタイルのコメント」とは同じ文字を二つ連ねる形式のことを指しています。

使用例：
  ;;; cc-mode.l
  (set-syntax-start-c++-comment *c++-mode-syntax-table* #\/)
</description>
<seealso>syntax-c++-comment-p</seealso>
<seealso>set-syntax-end-c++-comment</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-end-multi-comment-2-p</title>
<type>Function</type>
<arguments>syntax-end-multi-comment-2-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがコメント終了の文字列の2文字目として規定されているかを返します。

  t     コメント終了文字列の2文字目である。
  nil   コメント終了文字列の2文字目でない。
</description>
<seealso>set-syntax-end-multi-comment</seealso>
<seealso>syntax-end-multi-comment-1-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-end-multi-comment-1-p</title>
<type>Function</type>
<arguments>syntax-end-multi-comment-1-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがコメント終了の文字列の1文字目として規定されているかを返します。

  t     コメント終了文字列の1文字目である。
  nil   コメント終了文字列の1文字目でない。
</description>
<seealso>set-syntax-end-multi-comment</seealso>
<seealso>syntax-end-multi-comment-2-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-start-multi-comment-2-p</title>
<type>Function</type>
<arguments>syntax-start-multi-comment-2-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがコメント開始の文字列の2文字目として規定されているかを返します。

  t     コメント開始文字列の2文字目である。
  nil   コメント開始文字列の2文字目でない。
</description>
<seealso>set-syntax-start-multi-comment</seealso>
<seealso>syntax-start-multi-comment-1-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-start-multi-comment-1-p</title>
<type>Function</type>
<arguments>syntax-start-multi-comment-1-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字がコメント開始の文字列の1文字目として規定されているかを返します。

  CHAR         : コメント開始の1文字目を指定します。
  SYNTAX-TABLE : シンタックステーブルを指定します。指定しないと、カレン
                 トバッファにしようされているシンタックステーブルが使用
                 されます。

  t     コメント開始文字列の1文字目である。
  nil   コメント開始文字列の1文字目でない。
</description>
<seealso>set-syntax-start-multi-comment</seealso>
<seealso>syntax-start-multi-comment-2-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-symbol-p</title>
<type>Function</type>
<arguments>syntax-symbol-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字がシンボル名を構成する文字として規定されているかを返します。
ただし単語構成文字は除きます。

  CHAR : 文字を指定します。  

  t     シンボル名を構成する文字である。
  nil   シンボル名を構成する文字でない。
</description>
<seealso>set-syntax-symbol</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-symbol-prefix-p</title>
<type>Function</type>
<arguments>syntax-symbol-prefix-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字CHARがシンボルの前置子として規定されているかを返します。

  CHAR : 文字を指定します。  

  t     シンボルの前置子である。
  nil   シンボルの前置子でない。
</description>
<seealso>set-syntax-symbol-prefix</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-symbol-prefix</title>
<type>Function</type>
<arguments>set-syntax-symbol-prefix SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字をシンボルの前置子として規定します。

  SYNTAX-TABLE : シンタクッステーブルを指定します。
  CHAR         : 文字を指定します。  

HTMLの`&amp;'(実体参照)や、Perlの`$'(変数)、`@'(配列)、`%'(連想配列)等が
相当するようです。Emacsの構文テーブルには相当するものが無いように思います。

使用例：
  ;;; perl.l
  (set-syntax-symbol-prefix *perl-mode-syntax-table* #\$)
  (set-syntax-symbol-prefix *perl-mode-syntax-table* #\@)
  (set-syntax-symbol-prefix *perl-mode-syntax-table* #\%)
</description>
<seealso>syntax-symbol-prefix-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>syntax-word-p</title>
<type>Function</type>
<arguments>syntax-word-p CHAR &amp;optional SYNTAX-TABLE</arguments>
<package>editor</package>
<description>
文字が単語を構成する文字として規定されているかを返します。

  CHAR : 判定する文字を指定します。

  t     単語を構成する文字である。
  nil   単語を構成する文字でない。
</description>
<seealso>set-syntax-word</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>set-syntax-word</title>
<type>Function</type>
<arguments>set-syntax-word SYNTAX-TABLE CHAR</arguments>
<package>editor</package>
<description>
文字を単語を構成する文字として規定します。
skip-syntax-spec-forward / skip-syntax-spec-backwardに影響します。

  SYNTAX-TABLE : シンタクッステーブルを指定します。
  CHAR         : 文字を指定します。

デフォルトでは#\0 .. #\9, #\A .. #\Z, #\a .. #\z です。
余程特殊でない限り新たに設定する必要は無いでしょう。
</description>
<seealso>syntax-word-p</seealso>
<link></link>
<section>シンタックス</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>string-replace-match</title>
<type>Function</type>
<arguments>string-replace-match STRING REPLACEMENT</arguments>
<package>editor</package>
<description>
string-matchで検索した結果を使って文字列の置換を行います。

  STRING      : string-matchで指定した文字列を指定します。
  REPLACEMENT : 置換する文字列を指定します。
                REPLACEには正規表現に部分\1-\9を含めることが可能です。

使用例：
  ;;; 文字列を置換してみる。
  (setq str "01356:00001:error message")
  =&gt; "01356:00001:error message"
  (when (string-match "\\([0-9]+\\):\\([0-9]+\\):\\(.*\\)" str)
    (setq str (string-replace-match str "\\1,\\3")))
  =&gt; "01356,error message"
</description>
<seealso>string-match</seealso>
<link></link>
<section>文字列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>delete-indentation</title>
<type>Function</type>
<arguments>delete-indentation &amp;optional ARG</arguments>
<package>editor</package>
<description>
インデントを削除し直前の行と連結します。
連結する行とされる行は、半角スペースで区切られます。

  ARG : 連結する行を指定します。
        t   次行のインデントを削除し、現在の行に連結します。
        nil 現在の行のインデントを削除し、直前の行に連結します。
</description>
<seealso></seealso>
<link></link>
<section>文字列</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>backward-word</title>
<type>Function</type>
<arguments>backward-word &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
カーソルを後方の単語に移動します。
</description>
<seealso>forward-word</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>forward-word</title>
<type>Function</type>
<arguments>forward-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを前方の単語に移動します。
</description>
<seealso>backward-word</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>fill-region-as-paragraph</title>
<type>Function</type>
<arguments>fill-region-as-paragraph FROM TO</arguments>
<package>editor</package>
<description>
リージョンを 1 つの段落として詰め込みます。
詰め込み桁数は、変数 fill-column が参照されます。
</description>
<seealso>fill-column</seealso>
<link></link>
<section>リージョン</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>fill-paragraph</title>
<type>Function</type>
<arguments>fill-paragraph</arguments>
<package>editor</package>
<description>
現在の段落を詰め込みます。
</description>
<seealso>fill-region-as-paragraph</seealso>
<link></link>
<section>文字列</section>
<file>fill.l</file>
</chapter>

<chapter>
<title>back-to-indentation</title>
<type>Function</type>
<arguments>back-to-indentation</arguments>
<package>editor</package>
<description>
カーソルをインデントの末尾（行の最初の空白でない文字）へ移動します。
</description>
<seealso></seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>re-search-backward</title>
<type>Function</type>
<arguments>re-search-backward REGEXP &amp;optional NOERROR</arguments>
<package>editor</package>
<description>
正規表現による後方検索をします。

  REGEXP  : 正規表現による検索文字列
  NOERROR : 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。
</description>
<seealso>re-search-forward</seealso>
<link></link>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>re-search-forward</title>
<type>Function</type>
<arguments>re-search-forward REGEXP &amp;optional NOERROR</arguments>
<package>editor</package>
<description>
正規表現による前方検索をします。

  REGEXP  : 正規表現による検索文字列
  NOERROR : 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。
</description>
<seealso>re-search-backward</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>transpose-words</title>
<type>Function</type>
<arguments>transpose-words &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置の単語を後方の単語と入れ換えます。
</description>
<seealso></seealso>
<link></link>
<section>文字列</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>downcase-word</title>
<type>Function</type>
<arguments>downcase-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置から単語の末尾までを小文字に変換します。
</description>
<seealso>downcase-region</seealso>
<seealso>upcase-word</seealso>
<link></link>
<section>文字列</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>upcase-word</title>
<type>Function</type>
<arguments>upcase-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置から単語の末尾までを大文字に変換します。
</description>
<seealso>upcase-region</seealso>
<seealso>downcase-word</seealso>
<link></link>
<section>文字列</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>copy-region-as-kill</title>
<type>Function</type>
<arguments>copy-region-as-kill FROM TO</arguments>
<package>editor</package>
<description>
リージョンをコピーして、キルリングに追加します。
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>region.l</file>
</chapter>

<chapter>
<title>selection-paragraph</title>
<type>Function</type>
<arguments>selection-paragraph</arguments>
<package>editor</package>
<description>
段落をセレクションにします。
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>transpose-paragraphs</title>
<type>Function</type>
<arguments>transpose-paragraphs &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
段落を次の段落と交換します。
</description>
<seealso>transpose-region</seealso>
<link></link>
<section>リージョン</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>mark-paragraph</title>
<type>Function</type>
<arguments>mark-paragraph</arguments>
<package>editor</package>
<description>
段落の末尾にマークを、先頭にポイントを設定します。
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>forward-paragraph</title>
<type>Function</type>
<arguments>forward-paragraph &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを段落の末尾に移動します。
</description>
<seealso>backward-paragraph</seealso>
<link></link>
<section>ポジション</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>backward-paragraph</title>
<type>Function</type>
<arguments>backward-paragraph &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを段落の先頭に移動します。
</description>
<seealso>forward-paragraph</seealso>
<link></link>
<section>ポジション</section>
<file>paragrph.l</file>
</chapter>

<chapter>
<title>チャンクの概要</title>
<type>Tips</type>
<arguments></arguments>
<package></package>
<description>
xyzzyの外部と入出力するためのデータを格納するオブジェクトです。
チャンク自身は以下の要素から構成されます。

        ┌──────── 16byte ───────┐
        ┏━━━━┳━━━━┳━━━━┳━━━━┓
        ┃データ長┃データ型┃格納先  ┃－      ┃
        ┗━━━━┻━━━━┻━━━━┻━━━━┛
  データ長 : チャンクが管理するデータの長さです。
             make-chunkで指定します。
  データ型 : チャンクが管理するデータの型です。
  格納先   : チャンク自体には管理するデータを内包しません。
             格納先のアドレスだけを管理します。

以下は管理イメージです。

  ;;; 使用例
  (setq chunk (si:make-chunk 'string 8)) =&gt; #&lt;chunk 0x00081010&gt;
  (si:chunk-data chunk)                  =&gt; 0x00A73DC8
  (si:pack-string chunk 0 "HELLO")       =&gt; "HELLO"

      ┌アドレス┐  ┌データ─────────────┐
      ┏━━━━━┳━━━━━┯━━━━━┯━━━━━┓
      ┃0x00081010┃0x00000008│string    │0x00A73DC8┃
      ┠─────╂─────┴─────┴─────┨
      ┃0x00081018┃...                               ┃
      ┠─────╂─────────────────┨
      ┃↓        ┃                                  ┃
      ┠─────╂─┬─┬─┬─┬─┬─┬─┬─┬─┨
      ┃0x00A73DC8┃H │E │L │L │O │\0│  │  │  ┃
      ┠─────╂─┴─┴─┴─┴─┴─┴─┴─┴─┨
      ┃0x00A73DD0┃...                               ┃
      ┠─────╂─────────────────┨
      ┃↓        ┃                                  ┃
      ┗━━━━━┻━━━━━━━━━━━━━━━━━┛

チャンクから情報を取得する関数は以下のとおりです。

  si:address-of  : チャンク自身のアドレスを返します。
  si:chunk-size  : チャンクが管理するデータの長さを返します。
  si:chunk-type  : チャンクが管理するデータの型を返します｡
  si:chunk-data  : チャンクが管理するデータの格納先のアドレスを返します。
  si:chunk-owner : データの格納先がチャンク自身が確保したものかどうかを返します。

チャンクを操作する関数は以下のとおりです。

  si:fill-chunk  : チャンクをfill？
  si:clear-chunk : チャンクをクリア？
  si:copy-chunk  : チャンクが管理するデータをコピーします。

チャンクの入出力をする関数は以下のとおりです。

  si:pack-int8          si:unpack-int8   :  8ビット符号付き整数用
  si:pack-uint8         si:unpack-uint8  :  8ビット符号無し整数用
  si:pack-int16         si:unpack-int16  : 16ビット符号付き整数用
  si:pack-uint16        si:unpack-uint16 : 16ビット符号無し整数用
  si:pack-int32         si:unpack-int32  : 32ビット符号付き整数用
  si:pack-uint32        si:unpack-uint32 : 32ビット符号無し整数用
  si:pack-float         si:unpack-float  : float用
  si:pack-double        si:unpack-double : double用
  si:pack-string        si:unpack-string : 文字列用
</description>
<seealso>si:make-chunk</seealso>
<link></link>
<section>チャンク</section>
<file></file>
</chapter>

<chapter>
<title>dde-initiate</title>
<type>Function</type>
<arguments>service topic</arguments>
<package>editor</package>
<description>
DDE 対話を確立します。引数 service はサービス名、topic はトピックで、
それぞれ文字列型です。なにを指定するかは通信する相手のマニュアルを
参照してください。正常に終了した場合、DDE チャンネルを返します。
以降の通信ではこのDDE チャンネルを使用してください。
</description>
<section>システム</section>
<seealso>dde-execute</seealso>
<seealso>dde-poke</seealso>
<seealso>dde-terminate</seealso>
<file>builtin.l</file>
</chapter>

<chapter>
<title>make-array</title>
<type>Function</type>
<arguments>dimensions &amp;rest rest &amp;key (element-type t) (initial-element () ies-p) (initial-contents () ics-p) fill-pointer adjustable displaced-to (displaced-index-offset 0)</arguments>
<package>lisp</package>
<description>
dimensionsで示される大きさ・次元の配列をつくり、それを値として返します。
もし、dimensionsがnilなら、ゼロ次元配列がつくられます。
たとえば、変数hogeを4次元の配列(＝4次元のベクトル)にするためには、

  (setf hoge (make-array 4))
  =&gt; #(nil nil nil nil)

変数fooを2x4次元の配列とするためには、

  (setf foo (make-array '(2 4)))
  =&gt; #2A((nil nil nil nil) (nil nil nil nil))

とします。
element-typeは、新しい配列の各要素の型を規定します。
initial-elementが与えられている場合、新しい配列の全要素はすべて
initial-elementに初期化されます。これに対して、initial-contentsが与えら
れている場合、新しい配列の各要素がinitial-contentsで初期化されます。
たとえば、

  (make-array '(2 4) :initial-element 10); 2x4の配列をつくる。initial-elementで初期化
  =&gt; #2A((10 10 10 10) (10 10 10 10))
  (make-array '(2 4) 
  :initial-contents '((0 1 2 3) (3 2 1 0))); 2x4の配列をつくる。initial-contentsで初期化
  =&gt; #2A((0 1 2 3) (3 2 1 0))

なお、配列の要素にアクセスするためには、arefが使われます。
</description>
<seealso>aref</seealso>
<seealso>setf</seealso>
<section>配列</section>
<file>array.l</file>
</chapter>

<chapter>
<title>aref</title>
<type>Accessor</type>
<arguments>array &amp;rest subscripts</arguments>
<package>lisp</package>
<description>
subscriptsで特定される配列の要素にアクセスします。subscriptsがなく配列が
ゼロ次元の場合は、配列のただひとつの要素にアクセスします。
具体的な使い方については、以下の例を参照してください。

使用例：
  ;;; 2x2の初期化された配列を作ります。値の取得・変更を行います。
  (setf foo (make-array '(2 2) :initial-contents '((1 2) (3 4))))
  =&gt;#2A((1 2) (3 4))
  (aref foo 1 1);配列fooの要素(1,1)の値を得る
  =&gt;4
  (setf (aref foo 1 1) 10);配列fooの要素(1,1)の値を10にする
  =&gt;10
  foo
  =&gt;#2A((1 2) (3 10))
</description>
<seealso>make-array</seealso>
<seealso>setf</seealso>
<seealso>svref</seealso>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>vector</title>
<type>Function</type>
<arguments>&amp;rest LIST</arguments>
<package>lisp</package>
<description>
要素objectsからなるベクトルをつくります。

  (setf v (vector 1 2 "oop"))
  =&gt;#(1 2 "oop")

ベクトルの各要素にアクセスするためには、svref(あるいはaref)が使われます。
</description>
<seealso>svref</seealso>
<seealso>aref</seealso>
<seealso>setf</seealso>
<seealso>make-array</seealso>
<section>配列</section>
<file>array.l</file>
</chapter>

<chapter>
<title>svref</title>
<type>Accessor</type>
<arguments>SIMPLE-VECTOR INDEX</arguments>
<package>lisp</package>
<description>
arefと同じですが、svrefはベクトル(一次元配列)のみにアクセスできます。つ
まり、ベクトルhogeがあるとき、(svref hoge 2)は(aref hoge 2)と同じ意味で
す。ただし、fooが2x2配列の場合は、svrefでアクセスすることはできません。
</description>
<seealso>aref</seealso>
<seealso>setf</seealso>
<seealso>vector</seealso>
<section>配列</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>pre-selection-p</title>
<type>Function</type>
<arguments></arguments>
<package>editor</package>
<description>
セレクションが存在すれば t しなければ nil を返します。
</description>
<seealso>セレクション</seealso>
<seealso>selection-point</seealso>
<seealso>selection-mark</seealso>
<link></link>
<section>ポジション</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>hide-restricted-region</title>
<type>Variable</type>
<arguments></arguments>
<package>editor</package>
<description>
narrow-to-regionした領域を非表示にするか薄く表示するかを制御します。

  t   : 非表示にします。
  nil : 薄く表示します。
</description>
<seealso>narrow-to-region</seealso>
<link></link>
<section>リージョン</section>
<file></file>
</chapter>

<chapter>
<title>si:md5</title>
<type>Function</type>
<arguments>input-string-or-stream</arguments>
<package>system</package>
<description>
MD5ハッシュ値を得ます。

  INPUT-STRING-OR-STREAM : 入力の文字列または入力ストリームを指定します。

使用例：  
  (si:md5 "ほげほげ")
  =&gt; "11e100e3eb6e6171d9681ba6641794e3"
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>印刷時のヘッダやフッタに関する表記</title>
<type>Tips</type>
<arguments></arguments>
<description>
印刷時のヘッダやフッタに関する表記方法です。以下は 
  Toy's xyzzy memo - Data Library -
  http://www.carabiner-systems.com/xyzzy/data.html)
からの引用です。

--- 引用 ---
印刷時のヘッダやフッタに関する表記 
header and footer 1999/12/25　Written by Tetsuya Kamei [xyzzy:03752] 

  %f   ファイル名
  %F   ファイル名 (ディレクトリ付き)
  %b   バッファ名
  %p   ページ番号
  %P   総ページ数

  %Y   西暦 (YYYY)
  %y   西暦 (YY)
  %m   月   (1～12)
  %0m  月   (01～12)
  %*m  月   (January～December)
  %:m  月   (Jan～Dec)
  %d   日   (1～31)
  %0d  日   (01～31)
  %*w  曜日 (Sunday～Saturday)
  %:w  曜日 (Sun～Sat)
  %w   曜日 (日～土)
  %h   時   (0～23)
  %0h  時   (00～23)
  %H   時   (0～11)
  %0H  時   (00～11)
  %:H  時   (1～12)
  %0:H 時   (01～12)
  %*H       (AM/PM)
  %*:H      (am/pm)
  %M   分   (0～59)
  %0M  分   (00～59)
  %s   秒   (0～59)
  %0s  秒   (00～59)

  %-   横線

  %l   以前を左詰め
  %r   以降を右詰め
       指定されない部分は中央揃え

  それ以外の文字はそのまま
  --------------------------------------------------------------------------------
  (デフォルト)
    [ヘッダ] %F%l%r%:w, %0d %:m %Y %0h:%0M:%0s
    [フッタ] - %p - 
</description>
<section>検索・正規表現</section>
<file></file>
</chapter>

<chapter>
<title>open-filer</title>
<type>Function</type>
<arguments>open-filer</arguments>
<package>editor</package>
<description>
ファイラを開きます。[C-c C-f]
filerのinteractive版です。
</description>
<seealso>filer</seealso>
<link></link>
<section>ファイラー</section>
<file>filer.l</file>
</chapter>

<chapter>
<title>ime-register-word-dialog</title>
<type>Function</type>
<arguments>ime-register-word-dialog</arguments>
<package>editor</package>
<description>
単語/用例登録ダイヤログを表示します。[C-c C-r]
セレクションがあれば、セレクションの文字列を語句とします。
</description>
<seealso></seealso>
<link></link>
<section>ダイアログ</section>
<file>kanji.l</file>
</chapter>

<chapter>
<title>ime-push-composition-string</title>
<type>Function</type>
<arguments>ime-push-composition-string &amp;optional NODELETE</arguments>
<package>editor</package>
<description>
セレクションの確定済仮名文字を非確定状態にします。[C-c C-p]
</description>
<seealso></seealso>
<link></link>
<section>文字列</section>
<file>kanji.l</file>
</chapter>

<chapter>
<title>delete-last-ime-composition</title>
<type>Function</type>
<arguments>delete-last-ime-composition</arguments>
<package>editor</package>
<description>
IME 変換直後であれば、直前に変換した文字列を削除します。[C-c C-d]
</description>
<seealso></seealso>
<link></link>
<section>文字列</section>
<file>kanji.l</file>
</chapter>

<chapter>
<title>rewind-ime-composition</title>
<type>Function</type>
<arguments>rewind-ime-composition &amp;optional NODELETE POP</arguments>
<package>editor</package>
<description>
直前に IME で変換した文字列を非確定状態に戻します。[C-c C-c]
変換直後でなければ、直前に変換した文字列を非確定状態で挿入します。
</description>
<seealso></seealso>
<link></link>
<section>文字列</section>
<file>kanji.l</file>
</chapter>

<chapter>
<title>scroll-up-both-window</title>
<type>Function</type>
<arguments>scroll-up-both-window</arguments>
<package>editor</package>
<description>
現在のウィンドウと、次のウィンドウを同時に上スクロールします。[S-C-Down]
</description>
<seealso></seealso>
<link></link>
<section>ウィンドウ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>scroll-down-both-window</title>
<type>Function</type>
<arguments>scroll-down-both-window</arguments>
<package>editor</package>
<description>
現在のウィンドウと、次のウィンドウを同時に下スクロールします。[S-C-Up]
</description>
<seealso></seealso>
<link></link>
<section>ウィンドウ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>selection-forward-word</title>
<type>Function</type>
<arguments>selection-forward-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前方の単語までをセレクションにします。[S-C-Right]
</description>
<seealso>selection-backward-word</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-backward-word</title>
<type>Function</type>
<arguments>selection-backward-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
後方の単語までをセレクションにします。[S-C-Left]
</description>
<seealso>selection-forward-word</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>mark-dialog-box</title>
<type>Function</type>
<arguments>mark-dialog-box</arguments>
<package>editor</package>
<description>
マークダイヤログを表示します。[C-F2]

マークダイヤログからは、グローバルマークを設定することができ、複数のポイ
ント間を移動することができます。

  移動   : 選択したマークに移動します。
  追加   : マークを追加します。
  削除   : 選択したマークを削除します。
  全削除 : 全てのマークを削除します。
</description>
<seealso></seealso>
<link></link>
<section>ダイアログ</section>
<file>gmark.l</file>
</chapter>

<chapter>
<title>show-html-help</title>
<type>Function</type>
<arguments>show-html-help</arguments>
<package>editor</package>
<description>
カーソル位置の文字列を HTML Help から検索します。
*html-help-path* に設定されたヘルプファイルが使用されます。

*html-help-path* の値は、「共通設定」-「ディレクトリ」-「HTML ヘルプ」-
「COL/CHMファイル」から設定できるみたいです。
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file>winhelp.l</file>
</chapter>

<chapter>
<title>show-winhelp</title>
<type>Function</type>
<arguments>show-winhelp</arguments>
<package>editor</package>
<description>
カーソル位置の文字列を WinHelp から検索します。[C-F1]
*winhelp-path* に設定されたヘルプファイルが使用されます。
</description>
<seealso></seealso>
<link></link>
<section>その他</section>
<file>winhelp.l</file>
</chapter>

<chapter>
<title>kill-selection-to-clipboard</title>
<type>Function</type>
<arguments>kill-selection-to-clipboard</arguments>
<package>editor</package>
<description>
セレクションを削除し、クリップボードに転送します。[C-Delete]
矩形選択状態であれば、 kill-rectangle-selection-to-clipboard
を実行します。
</description>
<seealso>kill-region-to-clipboard</seealso>
<seealso>kill-rectangle-selection-to-clipboard</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>fast-scroll-up</title>
<type>Function</type>
<arguments>fast-scroll-up</arguments>
<package>editor</package>
<description>
高速に上スクロールします。[C-Down]
</description>
<seealso>fast-scroll-down</seealso>
<link></link>
<section>バッファ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>fast-scroll-down</title>
<type>Function</type>
<arguments>fast-scroll-down</arguments>
<package>editor</package>
<description>
高速に下スクロールします。[C-Up]
</description>
<seealso>fast-scroll-up</seealso>
<link></link>
<section>バッファ</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>selection-next-virtual-line</title>
<type>Function</type>
<arguments>selection-next-virtual-line &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
次の表示行までをセレクションにします。[S-Down]
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-forward-char</title>
<type>Function</type>
<arguments>selection-forward-char &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前方の文字までをセレクションにします。[S-Right]
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-previous-virtual-line</title>
<type>Function</type>
<arguments>selection-previous-virtual-line &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前の表示行までをセレクションにします。[S-Up]
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-backward-char</title>
<type>Function</type>
<arguments>selection-backward-char &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
後方の文字までをセレクションにします。[S-Left]
</description>
<seealso></seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-next-page</title>
<type>Function</type>
<arguments>selection-next-page &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
次ページまでをセレクションにします。[S-PageDown]
</description>
<seealso>selection-previous-page</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>selection-previous-page</title>
<type>Function</type>
<arguments>selection-previous-page &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前ページまでをセレクションにします。[S-PageUp]
</description>
<seealso>selection-next-page</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>start-selection-as-region</title>
<type>Function</type>
<arguments>start-selection-as-region</arguments>
<package>editor</package>
<description>
文字選択モードを開始します。[S-F6]
文字選択モードが開始されている場合は、矩形選択モードに切替えます。
矩形選択モードが開始されている場合は、文字選択モードに切替えます。
行選択モードが開始されている場合は、選択モードを解除します。
</description>
<seealso>start-selection-as-line</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>start-selection-as-line</title>
<type>Function</type>
<arguments>start-selection-as-line</arguments>
<package>editor</package>
<description>
行選択モードを開始します。[F6]
セレクションが存在する場合は、セレクションを解除します。
</description>
<seealso>start-selection-as-region</seealso>
<link></link>
<section>リージョン</section>
<file>select.l</file>
</chapter>

<chapter>
<title>repeat-backward-search</title>
<type>Function</type>
<arguments>repeat-backward-search</arguments>
<package>editor</package>
<description>
前回検索した文字列を再度後方検索します。[S-F5]

前回の検索が正規表現によるものであれば正規表現を使って、そうでなければ
そのように実行されます。
</description>
<seealso>repeat-forward-search</seealso>
<seealso>search-forward-again</seealso>
<seealso>re-search-forward-again</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>repeat-forward-search</title>
<type>Function</type>
<arguments>repeat-forward-search</arguments>
<package>editor</package>
<description>
前回検索した文字列を再度前方検索します。[F5]

前回の検索が正規表現によるものであれば正規表現を使って、そうでなければ
そのように実行されます。
</description>
<seealso>repeat-backward-search</seealso>
<seealso>search-forward-again</seealso>
<seealso>re-search-forward-again</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>apps-popup</title>
<type>Function</type>
<arguments>apps-popup</arguments>
<package>editor</package>
<description>
ポップアップメニューを表示します。[Apps]

メニューは、*app-popup-menu* に定義されたものが使用されます。
</description>
<seealso>mouse-menu-popup</seealso>
<link></link>
<section>メニュー</section>
<file>mouse.l</file>
</chapter>

<chapter>
<title>redo</title>
<type>Function</type>
<arguments>redo</arguments>
<package>editor</package>
<description>
元に戻した処理を再度実行します。[C-_],[S-End],[F12]

buffer-can-redo-p が t の時のみ実行可能です。
</description>
<seealso>buffer-can-redo-p</seealso>
<link></link>
<section>バッファ</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>search-backward</title>
<type>Function</type>
<arguments>search-backward PATTERN &amp;optional NOERROR</arguments>
<package>editor</package>
<description>
後方検索をします。[C-r]

  PATTERN: 検索文字列
  NOERROR: 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。
</description>
<seealso>search-forward</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>search-forward</title>
<type>Function</type>
<arguments>search-forward PATTERN &amp;optional NOERROR</arguments>
<package>editor</package>
<description>
前方検索をします。[C-s]

  PATTERN: 検索文字列
  NOERROR: 文字列が見つからなかったときの動作を指定します。
        t   nil を返します。
        nil エラーメッセージを出力します。
</description>
<seealso>search-backward</seealso>
<link></link>
<section>検索・正規表現</section>
<file>search.l</file>
</chapter>

<chapter>
<title>open-line</title>
<type>Function</type>
<arguments>open-line &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置を変えないで改行を挿入します。[C-o]
</description>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>newline</title>
<type>Function</type>
<arguments>newline &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
改行を挿入します。[RET]
</description>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>delete-backward-char-or-selection</title>
<type>Function</type>
<arguments>delete-backward-char-or-selection &amp;optional (N 1)</arguments>
<package>editor</package>
<description>
セレクションがあればセレクション全体を、そうでなければカーソルの後方の
文字を削除します。[C-h]
</description>
<seealso>delete-char-or-selection</seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>mark-sexp</title>
<type>Function</type>
<arguments>mark-sexp &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前方のS式の末尾にマークを設定します。[ESC NUL]
</description>
<seealso></seealso>
<link></link>
<section>関数</section>
<file>sexp.l</file>
</chapter>

<chapter>
<title>split-line</title>
<type>Function</type>
<arguments>split-line</arguments>
<package>editor</package>
<description>
カーソル位置から行末までのテキストを縦に 1 行下げ、2 行に分割します。[ESC C-o]
</description>
<seealso></seealso>
<link></link>
<section>テキスト</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>beginning-of-defun</title>
<type>Function</type>
<arguments>beginning-of-defun &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを関数定義の先頭に移動します。[ESC C-a]
</description>
<seealso></seealso>
<link></link>
<section>関数</section>
<file>sexp.l</file>
</chapter>

<chapter>
<title>end-of-defun</title>
<type>Function</type>
<arguments>end-of-defun &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソルを関数定義の末尾に移動します。[ESC C-e]
</description>
<seealso></seealso>
<link></link>
<section>関数</section>
<file>sexp.l</file>
</chapter>

<chapter>
<title>lisp-complete-symbol</title>
<type>Function</type>
<arguments>lisp-complete-symbol</arguments>
<package>editor</package>
<description>
Lisp のシンボル名を補完します。[ESC TAB]
</description>
<seealso></seealso>
<link></link>
<section>シンボル</section>
<file>lispmode.l</file>
</chapter>

<chapter>
<title>beginning-of-buffer</title>
<type>Function</type>
<arguments>beginning-of-buffer</arguments>
<package>editor</package>
<description>
カーソルをバッファの先頭に移動します。[ESC &lt;]
元あったカーソル位置にはマークを設定します。
</description>
<seealso>end-of-buffer</seealso>
<seealso>set-mark-command</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>end-of-buffer</title>
<type>Function</type>
<arguments>end-of-buffer</arguments>
<package>editor</package>
<description>
カーソルをバッファの末尾に移動します。[ESC &gt;]
元あったカーソル位置にはマークを設定します。
</description>
<seealso></seealso>
<seealso>set-mark-command</seealso>
<link></link>
<section>ポジション</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>mark-word</title>
<type>Function</type>
<arguments>mark-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置前方の単語の末尾にマークを設定します。[ESC @]
カーソルが単語の途中にある場合は、その単語の末尾にマークを設定します。
</description>
<seealso>set-mark-command</seealso>
<seealso>forward-word</seealso>
<link></link>
<section>リージョン</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>capitalize-word</title>
<type>Function</type>
<arguments>capitalize-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
前方の単語の先頭の文字を大文字に、それ以外の文字を小文字に変換します。
[ESC c]
カーソルが単語の途中にある場合は、カーソル位置の文字を大文字に、それ以
降の文字を小文字に変換します。
</description>
<seealso>capitalize-region</seealso>
<seealso>forward-word</seealso>
<link></link>
<section>文字列</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>backward-kill-word</title>
<type>Function</type>
<arguments>backward-kill-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置から後方の単語の先頭までを切り取り、キルリングに追加します。
[ESC C-h]
カーソルが単語の途中にある場合は、カーソル位置からその単語の先頭までが、
対象となります。
</description>
<seealso>kill-word</seealso>
<link></link>
<section>リージョン</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>kill-word</title>
<type>Function</type>
<arguments>kill-word &amp;optional (ARG 1)</arguments>
<package>editor</package>
<description>
カーソル位置から前方の単語の末尾までを切り取り、キルリングに追加します。
[ESC d]
カーソルが単語の途中にある場合は、カーソル位置からその単語の末尾までが、
対象となります。
</description>
<seealso>kill-region</seealso>
<seealso>forward-word</seealso>
<link></link>
<section>リージョン</section>
<file>cmds.l</file>
</chapter>

<chapter>
<title>delete-file-in-archive</title>
<type>Function</type>
<arguments>delete-file-in-archive ARCHIVE-FILE &amp;rest FILES</arguments>
<package>editor</package>
<description>
アーカイブから指定したファイルを削除します。

  ARCHIVE-FILE : アーカイブを指定します。
  FILES        : 削除するファイルを指定します。

使用例：
  ;;; c:/tmp/foo.lzh から xyz.c を削除します。
  (delete-file-in-archive "c:/tmp/foo.lzh" "xyz.c")
</description>
<seealso>create-archive</seealso>
<seealso>extract-archive</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>extract-archive</title>
<type>Function</type>
<arguments>extract-archive ARCHIVE-FILE TO-DIRECTORY &amp;rest FILES</arguments>
<package>editor</package>
<description>
アーカイブを展開します。

ARCHIVE-FILE : 展開するアーカイブを指定します。
TO-DIRECTORY : 展開するディレクトリを指定します。
FILES        : 展開するファイルを指定します。指定しない場合は、全てのフ
               ァイルが展開されます。

使用例：
  ;;; d:/foo.lzh を c:/tmp に展開します。
  (extract-archive "d:/foo.lzh" "c:/tmp")
</description>
<seealso>create-archive</seealso>
<seealso>delete-file-in-archive</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>cddddr</title>
<type>Function</type>
<arguments>cddddr X</arguments>
<package>lisp</package>
<description>
cddddr を返します。

  (cddddr X) = (cdr (cdr (cdr (cdr X))))
</description>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdddar</title>
<type>Function</type>
<arguments>cdddar X</arguments>
<package>lisp</package>
<description>
cdddar を返します。

  (cdddar X) = (cdr (cdr (cdr (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cddadr</title>
<type>Function</type>
<arguments>cddadr X</arguments>
<package>lisp</package>
<description>
cddadr を返します。

  (cddadr X) = (cdr (cdr (car (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cddaar</title>
<type>Function</type>
<arguments>cddaar X</arguments>
<package>lisp</package>
<description>
cddaar を返します。

  (cddaar X) = (cdr (cdr (car (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdaddr</title>
<type>Function</type>
<arguments>cdaddr X</arguments>
<package>lisp</package>
<description>
cdaddr を返します。

  (cdaddr X) = (cdr (car (cdr (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdadar</title>
<type>Function</type>
<arguments>cdadar X</arguments>
<package>lisp</package>
<description>
cdadar を返します。

  (cdadar X) = (cdr (car (cdr (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdaadr</title>
<type>Function</type>
<arguments>cdaadr X</arguments>
<package>lisp</package>
<description>
cdaadr を返します。

  (cdaadr X) = (cdr (car (car (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdaaar</title>
<type>Function</type>
<arguments>cdaaar X</arguments>
<package>lisp</package>
<description>
cdaaar を返します。

  (cdaaar X) = (cdr (car (car (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cadddr</title>
<type>Function</type>
<arguments>cadddr X</arguments>
<package>lisp</package>
<description>
cadddr を返します。

  (cadddr X) = (car (cdr (cdr (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caddar</title>
<type>Function</type>
<arguments>caddar X</arguments>
<package>lisp</package>
<description>
caddar を返します。

  (caddar X) = (car (cdr (cdr (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cadadr</title>
<type>Function</type>
<arguments>cadadr X</arguments>
<package>lisp</package>
<description>
cadadr を返します。

  (cadadr X) = (car (cdr (car (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cadaar</title>
<type>Function</type>
<arguments>cadaar X</arguments>
<package>lisp</package>
<description>
cadaar を返します。

  (cadaar X) = (car (cdr (car (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caaddr</title>
<type>Function</type>
<arguments>caaddr X</arguments>
<package>lisp</package>
<description>
caaddr を返します。

  (caaddr X) = (car (car (cdr (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caadar</title>
<type>Function</type>
<arguments>caadar X</arguments>
<package>lisp</package>
<description>
caadar を返します。

  (caadar X) = (car (car (cdr (car X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caaadr</title>
<type>Function</type>
<arguments>caaadr X</arguments>
<package>lisp</package>
<description>
caaadr を返します。

  (caaadr X) = (car (car (car (cdr X))))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caaaar</title>
<type>Function</type>
<arguments>caaaar X</arguments>
<package>lisp</package>
<description>
caaaar を返します。

  (caaaar X) = (car (car (car (car X))))
</description>
<seealso>car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdddr</title>
<type>Function</type>
<arguments>cdddr X</arguments>
<package>lisp</package>
<description>
cdddr を返します。

  (cdddr X) = (cdr (cdr (cdr X)))
</description>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cddar</title>
<type>Function</type>
<arguments>cddar X</arguments>
<package>lisp</package>
<description>
cddar を返します。

  (cddar X) = (cdr (cdr (car X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdadr</title>
<type>Function</type>
<arguments>cdadr X</arguments>
<package>lisp</package>
<description>
cdadr を返します。

  (cdadr X) = (cdr (car (cdr X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdaar</title>
<type>Function</type>
<arguments>cdaar X</arguments>
<package>lisp</package>
<description>
cdaar を返します。

  (cdaar X) = (cdr (car (car X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caddr</title>
<type>Function</type>
<arguments>caddr X</arguments>
<package>lisp</package>
<description>
caddr を返します。

  (caddr X) = (car (cdr (cdr X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cadar</title>
<type>Function</type>
<arguments>cadar X</arguments>
<package>lisp</package>
<description>
cadar を返します。

  (cadar X) = (car (cdr (car X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caadr</title>
<type>Function</type>
<arguments>caadr X</arguments>
<package>lisp</package>
<description>
caadr を返します。

  (caadr X) = (car (car (cdr X)))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caaar</title>
<type>Function</type>
<arguments>caaar X</arguments>
<package>lisp</package>
<description>
caaar を返します。

  (caaar X) = (car (car (car X)))
</description>
<seealso>car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cddr</title>
<type>Function</type>
<arguments>cddr X</arguments>
<package>lisp</package>
<description>
cddr を返します。

  (cddr X) = (cdr (cdr X))
</description>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cdar</title>
<type>Function</type>
<arguments>cdar X</arguments>
<package>lisp</package>
<description>
cdar を返します。

  (cdar X) = (cdr (car X))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>cadr</title>
<type>Function</type>
<arguments>cadr X</arguments>
<package>lisp</package>
<description>
cadr を返します。

  (cadr X) = (car (cdr X))
</description>
<seealso>car</seealso>
<seealso>cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>caar</title>
<type>Function</type>
<arguments>caar X</arguments>
<package>lisp</package>
<description>
caar を返します。

  (caar X) = (car (car X))
</description>
<seealso>car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>fourth</title>
<type>Function</type>
<arguments>fourth X</arguments>
<package>lisp</package>
<description>
cadddr の別名です。全く同じ動きをします。
</description>
<seealso>cadddr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>third</title>
<type>Function</type>
<arguments>third X</arguments>
<package>lisp</package>
<description>
caddr の別名です。全く同じ動きをします。
</description>
<seealso>caddr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>find-file-in-archive</title>
<type>Function</type>
<arguments>find-file-in-archive ARCNAME FILENAME</arguments>
<package>editor</package>
<description>
アーカイブからファイルを展開して開きます。

  ARCNAME  : アーカイブを指定します。
  FILENAME : 展開するファイルを指定します。

使用例：
  (find-file-in-archive "C:/foo/bar.lzh" "hoge/fuga.txt")
</description>
<seealso>extract-archive</seealso>
<seealso>find-file</seealso>
<link></link>
<section>ファイルシステム</section>
<file>files.l</file>
</chapter>

<chapter>
<title>archiver-dll-config-dialog</title>
<type>Function</type>
<arguments>archiver-dll-config-dialog DLL &amp;optional MODE</arguments>
<package>editor</package>
<description>
アーカイバの設定ダイヤログを表示します。

  DLL  : 設定するアーカイバを指定します。
  MODE : （詳細不明）

使用例：
  (archiver-dll-config-dialog :unlha32)
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>archiver-dll-version</title>
<type>Function</type>
<arguments>archiver-dll-version DLL</arguments>
<package>editor</package>
<description>
アーカイバのバージョンを取得します。

  DLL  : アーカイバを指定します。

使用例：
  (archiver-dll-version :unrar32)
  =&gt; "0.09"
</description>
<seealso></seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>list-archive</title>
<type>Function</type>
<arguments>list-archive ARCHIVE-FILE &amp;optional FILE-NAME-ONLY</arguments>
<package>editor</package>
<description>
アーカイブのファイル名一覧を取り出します。

  ARCHIVE-FILE   : 一覧を取得するアーカイブを指定します。
  FILE-NAME-ONLY : 戻り値の形式を指定します。
        t   ファイル名(ディレクトリ名)のみを返します。
        nil ファイル名(ディレクトリ名)、属性、サイズ、タイムスタンプを
            返します。

使用例：
  (list-archive "foo.lzh")
</description>
<seealso>create-archive</seealso>
<link></link>
<section>ファイルシステム</section>
<file>builtin.l</file>
</chapter>

<chapter>
<title>safe-cddddr</title>
<type>Function</type>
<arguments>safe-cddddr X</arguments>
<package>lisp</package>
<description>
safe-cddddr を返します。

  (safe-cddddr X) = (safe-cdr (safe-cdr (safe-cdr (safe-cdr X))))
</description>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdddar</title>
<type>Function</type>
<arguments>safe-cdddar X</arguments>
<package>lisp</package>
<description>
safe-cdddar を返します。

  (safe-cdddar X) = (safe-cdr (safe-cdr (safe-cdr (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cddadr</title>
<type>Function</type>
<arguments>safe-cddadr X</arguments>
<package>lisp</package>
<description>
safe-cddadr を返します。

  (safe-cddadr X) = (safe-cdr (safe-cdr (safe-car (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cddaar</title>
<type>Function</type>
<arguments>safe-cddaar X</arguments>
<package>lisp</package>
<description>
safe-cddaar を返します。

  (safe-cddaar X) = (safe-cdr (safe-cdr (safe-car (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdaddr</title>
<type>Function</type>
<arguments>safe-cdaddr X</arguments>
<package>lisp</package>
<description>
safe-cdaddr を返します。

  (safe-cdaddr X) = (safe-cdr (safe-car (safe-cdr (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdadar</title>
<type>Function</type>
<arguments>safe-cdadar X</arguments>
<package>lisp</package>
<description>
safe-cdadar を返します。

  (safe-cdadar X) = (safe-cdr (safe-car (safe-cdr (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdaadr</title>
<type>Function</type>
<arguments>safe-cdaadr X</arguments>
<package>lisp</package>
<description>
safe-cdaadr を返します。

  (safe-cdaadr X) = (safe-cdr (safe-car (safe-car (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdaaar</title>
<type>Function</type>
<arguments>safe-cdaaar X</arguments>
<package>lisp</package>
<description>
safe-cdaaar を返します。

  (safe-cdaaar X) = (safe-cdr (safe-car (safe-car (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cadddr</title>
<type>Function</type>
<arguments>safe-cadddr X</arguments>
<package>lisp</package>
<description>
safe-cadddr を返します。

  (safe-cadddr X) = (safe-car (safe-cdr (safe-cdr (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caddar</title>
<type>Function</type>
<arguments>safe-caddar X</arguments>
<package>lisp</package>
<description>
safe-caddar を返します。

  (safe-caddar X) = (safe-car (safe-cdr (safe-cdr (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cadadr</title>
<type>Function</type>
<arguments>safe-cadadr X</arguments>
<package>lisp</package>
<description>
safe-cadadr を返します。

  (safe-cadadr X) = (safe-car (safe-cdr (safe-car (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cadaar</title>
<type>Function</type>
<arguments>safe-cadaar X</arguments>
<package>lisp</package>
<description>
safe-cadaar を返します。

  (safe-cadaar X) = (safe-car (safe-cdr (safe-car (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caaddr</title>
<type>Function</type>
<arguments>safe-caaddr X</arguments>
<package>lisp</package>
<description>
safe-caaddr を返します。

  (safe-caaddr X) = (safe-car (safe-car (safe-cdr (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caadar</title>
<type>Function</type>
<arguments>safe-caadar X</arguments>
<package>lisp</package>
<description>
safe-caadar を返します。

  (safe-caadar X) = (safe-car (safe-car (safe-cdr (safe-car X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caaadr</title>
<type>Function</type>
<arguments>safe-caaadr X</arguments>
<package>lisp</package>
<description>
safe-caaadr を返します。

  (safe-caaadr X) = (safe-car (safe-car (safe-car (safe-cdr X))))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caaaar</title>
<type>Function</type>
<arguments>safe-caaaar X</arguments>
<package>lisp</package>
<description>
safe-caaaar を返します。

  (safe-caaaar X) = (safe-car (safe-car (safe-car (safe-car X))))
</description>
<seealso>safe-car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdddr</title>
<type>Function</type>
<arguments>safe-cdddr X</arguments>
<package>lisp</package>
<description>
safe-cdddr を返します。

  (safe-cdddr X) = (safe-cdr (safe-cdr (safe-cdr X)))
</description>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cddar</title>
<type>Function</type>
<arguments>safe-cddar X</arguments>
<package>lisp</package>
<description>
safe-cddar を返します。

  (safe-cddar X) = (safe-cdr (safe-cdr (safe-car X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdadr</title>
<type>Function</type>
<arguments>safe-cdadr X</arguments>
<package>lisp</package>
<description>
safe-cdadr を返します。

  (safe-cdadr X) = (safe-cdr (safe-car (safe-cdr X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdaar</title>
<type>Function</type>
<arguments>safe-cdaar X</arguments>
<package>lisp</package>
<description>
safe-cdaar を返します。

  (safe-cdaar X) = (safe-cdr (safe-car (safe-car X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caddr</title>
<type>Function</type>
<arguments>safe-caddr X</arguments>
<package>lisp</package>
<description>
safe-caddr を返します。

  (safe-caddr X) = (safe-car (safe-cdr (safe-cdr X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cadar</title>
<type>Function</type>
<arguments>safe-cadar X</arguments>
<package>lisp</package>
<description>
safe-cadar を返します。

  (safe-cadar X) = (safe-car (safe-cdr (safe-car X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caadr</title>
<type>Function</type>
<arguments>safe-caadr X</arguments>
<package>lisp</package>
<description>
safe-caadr を返します。

  (safe-caadr X) = (safe-car (safe-car (safe-cdr X)))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caaar</title>
<type>Function</type>
<arguments>safe-caaar X</arguments>
<package>lisp</package>
<description>
safe-caaar を返します。

  (safe-caaar X) = (safe-car (safe-car (safe-car X)))
</description>
<seealso>safe-car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cddr</title>
<type>Function</type>
<arguments>safe-cddr X</arguments>
<package>lisp</package>
<description>
safe-cddr を返します。

  (safe-cddr X) = (safe-cdr (safe-cdr X))
</description>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cdar</title>
<type>Function</type>
<arguments>safe-cdar X</arguments>
<package>lisp</package>
<description>
safe-cdar を返します。

  (safe-cdar X) = (safe-cdr (safe-car X))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-cadr</title>
<type>Function</type>
<arguments>safe-cadr X</arguments>
<package>lisp</package>
<description>
safe-cadr を返します。

  (safe-cadr X) = (safe-car (safe-cdr X))
</description>
<seealso>safe-car</seealso>
<seealso>safe-cdr</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>safe-caar</title>
<type>Function</type>
<arguments>safe-caar X</arguments>
<package>lisp</package>
<description>
safe-caar を返します。

  (safe-caar X) = (safe-car (safe-car X))
</description>
<seealso>safe-car</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>tenth</title>
<type>Function</type>
<arguments>tenth X</arguments>
<package>lisp</package>
<description>
list の 10 番目の要素を返します。

  (tenth X) = (nth 9 X)

使用例：
  (tenth '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 0
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>ninth</title>
<type>Function</type>
<arguments>ninth X</arguments>
<package>lisp</package>
<description>
list の 9 番目の要素を返します。

  (ninth X) = (nth 8 X)

使用例：
  (ninth '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 9
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>eighth</title>
<type>Function</type>
<arguments>eighth X</arguments>
<package>lisp</package>
<description>
list の 8 番目の要素を返します。

  (eighth X) = (nth 7 X)

使用例：
  (eighth '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 8
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>seventh</title>
<type>Function</type>
<arguments>seventh X</arguments>
<package>lisp</package>
<description>
list の 7 番目の要素を返します。

  (seventh X) = (nth 6 X)

使用例：
  (seventh '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 7
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>sixth</title>
<type>Function</type>
<arguments>sixth X</arguments>
<package>lisp</package>
<description>
list の 6 番目の要素を返します。

  (sixth X) = (nth 5 X)

使用例：
  (sixth '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 6
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

<chapter>
<title>fifth</title>
<type>Function</type>
<arguments>fifth X</arguments>
<package>lisp</package>
<description>
list の 5 番目の要素を返します。

  (fifth X) = (nth 4 X)

使用例：
  (fifth '(1 2 3 4 5 6 7 8 9 0))
  =&gt; 5
</description>
<seealso>nth</seealso>
<link></link>
<section>リスト</section>
<file>list.l</file>
</chapter>

</book>

<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja-JP">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta http-equiv="Content-Style-Type" content="text/css">
    <meta http-equiv="Content-Script-Type" content="text/javascript">
    <base href="http://tsofthome.appspot.com/">
    <link rel="stylesheet" href="style/base.css" type="text/css">
    <link rel="shortcut icon" href="image/favicon.ico">
    <title>ecma-262.5_07</title>
  </head>
  <body>
    <div class="s0">
      <h1>ecma-262.5_07</h1>
    </div>
    <hr>
    <div class="s0">
      <a href="/">インデックス</a> ≫
      <a href="ecmascript.html">ECMA-262第5版 日本語訳</a> ≫
      ecma-262.5_07
    </div>
    <hr>
    <pre>
* 7 Lexical Conventions

* 7 字句


The source text of an ECMAScript program is first converted into a sequence of input elements, which are tokens, line terminators, comments, or white space. The source text is scanned from left to right, repeatedly taking the longest possible sequence of characters as the next input element.

ECMAScriptプログラムのソーステキストは、最初にトークン、行終端記号、コメント、空白文字、といった入力要素の並びに変換されます。ソーステキストは左から右にスキャンされ、次の入力要素として可能なもっとも長い並びを取得することを繰り返します。


There are two goal symbols for the lexical grammar. The InputElementDiv symbol is used in those syntactic grammar contexts where a leading division (/) or division-assignment (/=) operator is permitted. The InputElementRegExp symbol is used in other syntactic grammar contexts.

字句文法には二つの目標記号があります。InputElementDivシンボルは除算演算子(/)もしくは除算代入演算子(/=)で続けることが許可されている構文文法で使用されます。InputElementRegExpシンボルはそれ以外の構文文法で使用されます。


NOTE There are no syntactic grammar contexts where both a leading division or division-assignment, and a leading RegularExpressionLiteral are permitted. This is not affected by semicolon insertion (see 7.9); in examples such as the
following:

注意：除算演算子もしくは除算代入演算子と、RegularExpressionLiteralの両方を続けることが許されるような構文文法は存在しません。これはセミコロンの自動挿入(7.9)に影響うけることはありません。以下は例です。


a = b
/hi/g.exec(c).map(d);


where the first non-whitespace, non-comment character after a LineTerminator is slash (/) and the syntactic context allows division or division-assignment, no semicolon is inserted at the LineTerminator. That is, the above example is interpreted in the same way as:

LineTerminatorに続く最初の非空白文字かつ非コメント文字がスラッシュ(/)であり構文文脈上除算演算子や除算代入演算子が許される箇所では、LineTerminatorの場所にセミコロンは挿入されません。つまり上記の例は以下と同じように解釈されます。


a = b / hi / g.exec(c).map(d);


Syntax

構文


  InputElementDiv ::
    WhiteSpace
    LineTerminator
    Comment
    Token
    DivPunctuator


  InputElementRegExp ::
    WhiteSpace
    LineTerminator
    Comment
    Token
    RegularExpressionLiteral


* 7.1 Unicode Format-Control Characters

* 7.1 Unicodeフォーマット制御文字


The Unicode format-control characters (i.e., the characters in category “Cf” in the Unicode Character Database such as LEFT-TO-RIGHT MARK or RIGHT-TO-LEFT MARK) are control codes used to control the formatting of a range of text in the absence of higher-level protocols for this (such as mark-up languages).

Unicodeフォーマット制御文字(例えば、LEFT-TO-RIGHT MARKもしくはRIGHT-TO-LEFT MARKのようなUnicode文字データベースにおけるカテゴリ"Cf"の文字)は、(例えばマークアップ言語のような)より高次のプロトコルでは欠落するような文字の範囲のフォーマットを制御するために使われる制御コードです。


It is useful to allow format-control characters in source text to facilitate editing and display. All format control characters may be used within comments, and within string literals and regular expression literals.

ソーステキスト中のフォーマット制御文字を許すことは編集機能や表示機能にとって役に立ちます。すべてのフォーマット制御文字はコメントや文字列リテラルや正規表現リテラルにおいて使われるでしょう。


&lt;ZWNJ&gt; and &lt;ZWJ&gt; are format-control characters that are used to make necessary distinctions when forming words or phrases in certain languages. In ECMAScript source text, &lt;ZWNJ&gt; and &lt;ZWJ&gt; may also be used in an identifier after the first character.

&lt;ZWNJ&gt;と&lt;ZWJ&gt;は、特定の言語で単語や語句を形成する時に、それらを区別するのに不可欠なフォーマット制御文字です。&lt;ZWNJ&gt;と&lt;ZWJ&gt;は最初の文字の後に識別されるよう使われます。


&lt;BOM&gt; is a format-control character used primarily at the start of a text to mark it as Unicode and to allow detection of the text's encoding and byte order. &lt;BOM&gt; characters intended for this purpose can sometimes also appear after the start of a text, for example as a result of concatenating files. &lt;BOM&gt; characters are treated as white space characters (see 7.2).

&lt;BOM&gt;は主にテキストの先頭で、Unicodeであると示したり、テキストの符号化方法やバイトオーダーを判断できるようにするフォーマット制御文字です。この目的で使われる&lt;BOM&gt;文字はテキストの先頭に現れます、例えばファイルを結合した結果をみると、&lt;BOM&gt;文字は空白文字として扱われます(7.2)。


The special treatment of certain format-control characters outside of comments, string literals, and regular expression literals is summarized in Table 1.

このような、コメント、文字列リテラル、正規表現リテラルの外側におけるフォーマット制御文字の特別な扱いは、表1にまとめられています。


Table 1 - Format-Control Character Usage
--------------- ----------------------- ----------- ----------------------------
Code Unit Value Name                    Formal Name Usage
--------------- ----------------------- ----------- ----------------------------
\u200C          Zero width non-joiner   &lt;ZWNJ&gt;      IdentifierPart
\u200C          Zero width joiner       &lt;ZWJ&gt;       IdentifierPart
\uFEFF          Byte Order Mark         &lt;BOM&gt;       Whitespace
--------------------------------------- ----------- ----------------------------

表1 - フォーマット制御文字の使い方
--------------- ----------------------- ----------- ----------------------------
コード単位      名前                    形式名称    使用箇所
--------------- ----------------------- ----------- ----------------------------
\u200C          Zero width non-joiner   &lt;ZWNJ&gt;      IdentifierPart
\u200C          Zero width joiner       &lt;ZWJ&gt;       IdentifierPart
\uFEFF          Byte Order Mark         &lt;BOM&gt;       Whitespace   
--------------- ----------------------- ----------- ----------------------------


* 7.2 White Space

* 7.2 空白文字


White space characters are used to improve source text readability and to separate tokens (indivisible lexical units) from each other, but are otherwise insignificant. White space characters may occur between any two tokens and at the start or end of input. White space characters may also occur within a StringLiteral or a RegularExpressionLiteral (where they are considered significant characters forming part of the literal value) or within a Comment, but cannot appear within any other kind of token.

空白文字はソーステキストの可読性を高めると共に、それらを(目に見えない字句上の単位である)トークンに分割しますが、それ以外は大して重要ではありません。空白文字は二つのトークンの間や、入力の最初と最後に現れる文字です。また、StringLiteralやRegularExpressionLiteral(その場合にはリテラル値の一部分を構成する意味のある文字と思われます)、コメントの中にも現れますが、それ以外のどんな種類のトークンの中には現れることはありません。


The ECMAScript white space characters are listed in Table 2.

ECMAScriptの空白文字を表2に示します。


Table 2 - Whitespace Characters
----------------------- ------------------- ------------------------------------
Code Unit Value         Name                Formal Name
----------------------- ------------------- ------------------------------------
\u0009                  Tab                 &lt;TAB&gt;
\u000B                  Vertical Tab        &lt;VT&gt;
\u000C                  Form Feed           &lt;FF&gt;
\u0020                  Space               &lt;SP&gt;
\u00A0                  No-break space      &lt;NBSP&gt;
\uFEFF                  Byte Order Mark     &lt;BOM&gt;
Other category “Zs”   Any other Unicode   &lt;USP&gt;
                        “space separator”
----------------------- ------------------- ------------------------------------

表2 - 空白文字
--------------- --------------------------- ----------------------------------
コード単位      名称                        形式名称
--------------- --------------------------- ------------------------------------
\u0009          Tab                         &lt;TAB&gt;
\u000B          Vertical Tab                &lt;VT&gt;
\u000C          Form Feed                   &lt;FF&gt;
\u0020          Space                       &lt;SP&gt;
\u00A0          No-break space              &lt;NBSP&gt;
\uFEFF          Byte Order Mark             &lt;BOM&gt;
カテゴリZs      Unicodeの他の空白文字区切り &lt;USP&gt;
------------ ------------------------------ ------------------------------------


ECMAScript implementations must recognize all of the white space characters defined in Unicode 3.0. Later editions of the Unicode Standard may define other white space characters. ECMAScript implementations may recognize white space characters from later editions of the Unicode Standard.

ECMAScriptの実装はUnicode 3.0で定義されている空白文字のすべてを認識しなければなりません。Unicode Standardの以後の版では、この他の空白文字が定義されているかもしれませんが、ECMAScriptの実装ではUnicode Standardの最新の版の空白文字を認識できるでしょう。


Syntax

構文


  WhiteSpace ::
    &lt;TAB&gt;
    &lt;VT&gt;
    &lt;FF&gt;
    &lt;SP&gt;
    &lt;NBSP&gt;
    &lt;BOM&gt;
    &lt;USP&gt;


* 7.3 Line Terminators

* 7.3 改行文字


Like white space characters, line terminator characters are used to improve source text readability and to separate tokens (indivisible lexical units) from each other. However, unlike white space characters, line terminators have some influence over the behaviour of the syntactic grammar. In general, line terminators may occur between any two tokens, but there are a few places where they are forbidden by the syntactic grammar. Line terminators also affect the process of automatic semicolon insertion (7.9). A line terminator cannot occur within any token except a StringLiteral. Line terminators may only occur within a StringLiteral token as part of a LineContinuation.

改行文字は、空白文字のようにソーステキストの可読性を高めると共に、それらを(目に見えない字句上の単位である)トークンに分割します。ただし、空白文字とは異なり、改行文字は構文文法の振る舞いに影響を与えます。一般的に、改行文字は二つのトークンの間に現れますが、構文文法によって禁止されている箇所がいくつかあります。また、改行文字はセミコロンの自動挿入(7.9)に影響を与えます。改行文字はStringLiteralを除くトークンの間には現れることはできません。改行文字はStringLiteralトークンの中にLineContinuationの一部としてのみ現れることができます。


A line terminator can occur within a MultiLineComment (7.4) but cannot occur within a SingleLineComment.

改行文字はMultiLineComment(7.4)の中に現れることができますが、SingleLineCommentの中には現れることはできません。


Line terminators are included in the set of white space characters that are matched by the \s class in regular expressions.

改行文字は正規表現における\sクラスにマッチする空白文字の集合に含まれます。


The ECMAScript line terminator characters are listed in Table 3.

ECMAScriptの改行文字を表3に示します。


Table 3 - Line Terminator Characters
--------------- ------------------- --------------------------------------------
Code Unit Value Name                Formal Name
--------------- ------------------- --------------------------------------------
\u000A          Line Feed           &lt;LF&gt;
\u000D          Carriage Return     &lt;CR&gt;
\u2028          Line separator      &lt;LS&gt;
\u2029          Paragraph separator &lt;PS&gt;
--------------- ------------------- --------------------------------------------

表3 - 改行文字
--------------- ------------------- --------------------------------------------
コード単位      名称                形式名称
--------------- ------------------- --------------------------------------------
\u000A          Line Feed           &lt;LF&gt;
\u000D          Carriage Return     &lt;CR&gt;
\u2028          Line separator      &lt;LS&gt;
\u2029          Paragraph separator &lt;PS&gt;
--------------- ------------------- --------------------------------------------


Only the characters in Table 3 are treated as line terminators. Other new line or line breaking characters are treated as white space but not as line terminators. The character sequence &lt;CR&gt;&lt;LF&gt; is commonly used as a line terminator. It should be considered a single character for the purpose of reporting line numbers.

表3の文字だけが改行文字として扱われます。他の新規行や改行を表す文字は空白文字として扱われ、改行文字としては扱われません。&lt;CR&gt;&lt;LF&gt;という文字の並びは、一般的に改行コードとして扱われます。&lt;CR&gt;&lt;LF&gt;は番号を出力する目的においてはひとつの改行文字として扱われるべきです。


Syntax

構文


  LineTerminator ::
    &lt;LF&gt;
    &lt;CR&gt;
    &lt;LS&gt;
    &lt;PS&gt;


  LineTerminatorSequence ::
    &lt;LF&gt;
    &lt;CR&gt; [lookahead not_a_member_of &lt;LF&gt; ]
    &lt;LS&gt;
    &lt;PS&gt;
    &lt;CR&gt; &lt;LF&gt;


* 7.4 Comments

* 7.4 コメント


Comments can be either single or multi-line. Multi-line comments cannot nest.

コメント(Comment)は単一行もしくは複数行のいずれかです。複数行コメントはネストすることはできません。


Because a single-line comment can contain any character except a LineTerminator character, and because of the general rule that a token is always as long as possible, a single-line comment always consists of all characters from the // marker to the end of the line. However, the LineTerminator at the end of the line is not considered to be part of the single-line comment; it is recognised separately by the lexical grammar and becomes part of the stream of input elements for the syntactic grammar. This point is very important, because it implies that the presence or absence of single-line comments does not affect the process of automatic semicolon insertion (see 7.9).

行コメントは改行文字を除くいかなる文字も含むことができることと、トークンはいつでもできる限り長くマッチさせるという一般的なルールにより、行コメントはいつも//マーカーから行末までのすべての文字から構成されます。ただし、行末のLineTerminatorは行コメントの一部として扱われません。行コメントと改行文字は字句構文によって別々に認識され、構文文法にとっては入力要素のストリームの一部となります。この点は、行コメントの存在するしないに関わらず、セミコロンの自動挿入(7.9)には何の影響も与えないことになるため重要です。


Comments behave like white space and are discarded except that, if a MultiLineComment contains a line terminator character, then the entire comment is considered to be a LineTerminator for purposes of parsing by the syntactic grammar.

コメントは空白文字のように振る舞ます。また、複数行コメントに改行文字が含まれている場合に構文文法の解析の都合上LineTerminatorとして扱われることを除けば、コメントは読み捨てられます。


Syntax

構文


  Comment ::
    MultiLineComment
    SingleLineComment


  MultiLineComment ::
    /* MultiLineCommentChars[opt] */


  MultiLineCommentChars ::
    MultiLineNotAsteriskChar MultiLineCommentChars[opt]
    * PostAsteriskCommentChars[opt]


  PostAsteriskCommentChars ::
    MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars[opt]
    * PostAsteriskCommentChars[opt]


  MultiLineNotAsteriskChar ::
    SourceCharacter but not asterisk *


  MultiLineNotForwardSlashOrAsteriskChar ::
    SourceCharacter but not forward-slash /or asterisk *


  SingleLineComment ::
    // SingleLineCommentChars[opt]


  SingleLineCommentChars ::
    SingleLineCommentChar SingleLineCommentChars[opt]


  SingleLineCommentChar ::
    SourceCharacter but not LineTerminator


* 7.5 Tokens

* 7.5 トークン


Syntax

構文


  Token ::
    IdentifierName
    Punctuator
    NumericLiteral
    StringLiteral


NOTE The DivPunctuator and RegularExpressionLiteral productions define tokens, but are not included in the Token production.

注意：DivPunctuatorとRegularExpressionLiteralの生成規則はトークン(Token)を定義しますが、トークンの生成規則に含まれません。


* 7.6 Identifier Names and Identifiers

* 7.6 識別名と識別子


Identifier Names are tokens that are interpreted according to the grammar given in the “Identifiers” section of chapter 5 of the Unicode standard, with some small modifications. An Identifier is an IdentifierName that is not a ReservedWord (see 7.6.1). The Unicode identifier grammar is based on both normative and informative character categories specified by the Unicode Standard. The characters in the specified categories in version 3.0 of the Unicode standard must be treated as in those categories by all conforming ECMAScript implementations. This standard specifies specific character additions: The dollar sign ($) and the underscore (_) are permitted anywhere in an IdentifierName.

識別名はUnicode standardの第5節"Indentifiers"の構文を少し修正したものとして解釈されます。識別子はReservedWord(7.6.1)ではないUnicode識別名です。Unicode識別子の構文は、Unicode Standardによって指定されたnormativeとinformative文字のカテゴリに基盤にしています。Unicode standardの第3版で指定された文字は、すべてのECMAScriptの適合する実装でそれらのカテゴリとして扱われなければなりません。標準仕様は特定の文字を追加します。ドル記号($)とアンダースコア(_)は、識別名として指定できるどこでも使えます。


Unicode escape sequences are also permitted in an IdentifierName, where they contribute a single character to the IdentifierName, as computed by the CV of the UnicodeEscapeSequence (see 7.8.4). The \ preceding the UnicodeEscapeSequence does not contribute a character to the IdentifierName. A UnicodeEscapeSequence cannot be used to put a character into an IdentifierName that would otherwise be illegal. In other words, if a \ UnicodeEscapeSequence sequence were replaced by its UnicodeEscapeSequence's CV, the result must still be a valid IdentifierName that has the exact same sequence of characters as the original IdentifierName. All interpretations of identifiers within this specification are based upon their actual characters regardless of whether or not an escape sequence was used to contribute any particular characters.

Unicodeのエスケープシーケンスもまた識別名の中での使うことができます。そこでは、それらはUnicodeEscapeSequence(7.8.4)のCVによって計算された識別名の一文字となります。UnicodeEscapeSequenceの前の\は識別名の一部にはなりません。ただし、UnicodeEscapeSequenceを使って違反させるように、識別名へ文字を入れることはできません。言い換えると、もし\とUnicodeEscapeSequenceという並びをそのCVで置き換えた場合に、その結果が依然として識別名として正確に同じ文字の並びである有効な識別名でなければなりません。この仕様における識別子のすべての解釈方法は、どの文字でエスケープシーケンスが使用されているかに関係なく、実際の文字に掛かっています。


Two IdentifierName that are canonically equivalent according to the Unicode standard are not equal unless they are represented by the exact same sequence of code units (in other words, conforming ECMAScript implementations are only required to do bitwise comparison on IdentifierName values). The intent is that the incoming source text has been converted to normalised form C before it reaches the compiler.

Unicode standard上で正規化され等価な二つの識別名は、正確に同じコード単位の並びで表現されない限り同じではなりません(言い換えると、ECMAScriptに適合した実装は、識別名に関する値のビット単位の比較だけが求められています)。これは入力されるソーステキストはコンパイラに到達する前に正規化形式Cに変換されていることを意図しています。


ECMAScript implementations may recognize identifier characters defined in later editions of the Unicode Standard. If portability is a concern, programmers should only employ identifier characters defined in Unicode

ECMAScriptの実装によってはUnicode Standardの以後の版で定義されている識別子の文字を認識するかもしれません。移植性を考慮するのであれば場合には、プログラマはUnicode 3.0で定義されている識別子の文字だけを採用すべきでしょう。


Syntax

構文


  Identifier ::
    IdentifierName but not ReservedWord


  IdentifierName ::
    IdentifierStart
    IdentifierName IdentifierPart


  IdentifierStart ::
    UnicodeLetter
    $
    _
    \ UnicodeEscapeSequence


  IdentifierPart ::
    IdentifierStart
    UnicodeCombiningMark
    UnicodeDigit
    UnicodeConnectorPunctuation
    &lt;ZWNJ&gt;
    &lt;ZWJ&gt;


  UnicodeLetter
    any character in the Unicode categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.


  UnicodeCombiningMark
    any character in the Unicode categories “Non-spacing mark (Mn)” or “Combining spacing mark (Mc)”


  UnicodeDigit
    any character in the Unicode category “Decimal number (Nd)”


  UnicodeConnectorPunctuation
    any character in the Unicode category “Connector punctuation (Pc)”


  UnicodeEscapeSequence
    see 7.8.4.


* 7.6.1 Reserved Words

* 7.6.1 予約語


A reserved word is an IdentifierName that cannot be used as an Identifier.

予約語とは識別子としては使うことができない識別名のことです。


Syntax

構文


  ReservedWord ::
    Keyword
    FutureReservedWord
    NullLiteral
    BooleanLiteral


* 7.6.1.1 Keywords

* 7.6.1.1 キーワード


The following tokens are ECMAScript keywords and may not be used as Identifiers in ECMAScript programs.

以下のトークンはECMAScriptのキーワードです。ECMAScriptプログラムでは識別子としては使えません。


Syntax

構文


  Keyword :: one of
    break       do          instanceof  typeof
    case        else        new         var
    catch       finally     return      void
    continue    for         switch      while
    debugger    function    this        with
    default     if          throw
    delete      in          try


* 7.6.1.2 Future Reserved Words

* 7.6.1.2 将来の予約語


The following words are used as keywords in proposed extensions and are therefore reserved to allow for the possibility of future adoption of those extensions.

以下の単語は提案済みの拡張の中でキーワードとして使われています。将来におけるそれらの拡張の採用の可能性を許すために予約されています。


Syntax

構文


  FutureReservedWord :: one of
    class       enum        extends     super
    const       export      import


The following tokens are also considered to be FutureReservedWords when they occur within strict mode code (see 10.1.1). The occurrence of any of these tokens within strict mode code in any context where the occurrence of a FutureReservedWord would produce an error must also produce an equivalent error:

以下のトークンもstrictモード(10.1.1)ではFutureReservedWordとして扱われます。strictモードのコードの範囲であれば、FutureReservedWordが現れることでエラーが発生しうる文脈でこれらのトークンが現れたならば、同じようにエラーを発生させなければいけません。


    implements  let         private     public      yield
    interface   package     protected   static


* 7.7 Punctuators

* 7.7 区切り文字


Syntax

構文


  Punctuator :: one of
    {       }       (       )       [       ]
    .       ;       ,       &lt;       &gt;       &lt;=
    &gt;=      ==      !=      ===     !==
    +       -       *       %       ++      --
    &lt;&lt;      &gt;&gt;      &gt;&gt;&gt;     &amp;       |       ^
    !       ~       &amp;&amp;      ||      ?       :
    =       +=      -=      *=      %=      &lt;&lt;=
    &gt;&gt;=     &gt;&gt;&gt;=    &amp;=      |=      ^=


  DivPunctuator :: one of
    /       /=


* 7.8 Literals

* 7.8 リテラル


Syntax

構文


  Literal ::
    NullLiteral
    BooleanLiteral
    NumericLiteral
    StringLiteral
    RegularExpressionLiteral


* 7.8.1 Null Literals

* 7.8.1 Nullリテラル


Syntax

構文


  NullLiteral ::
    null


Semantics

意味


The value of the null literal null is the sole value of the Null type, namely null.

nullリテラルの値であるnullはNull型の唯一の値、つまりnullです。


* 7.8.2 Boolean Literals

* 7.8.2 Booleanリテラル


Syntax

構文


  BooleanLiteral ::
    true
    false


Semantics

意味


The value of the Boolean literal true is a value of the Boolean type, namely true.
The value of the Boolean literal false is a value of the Boolean type, namely false.

Booleanリテラルの値であるtrueはBoolean型の値、つまりtrueです。
Booleanリテラルの値であるfalseはBoolean型の値、つまりfalseです。


* 7.8.3 Numeric Literals

* 7.8.3 数値リテラル


Syntax

構文


  NumericLiteral ::
    DecimalLiteral
    HexIntegerLiteral


  DecimalLiteral ::
    DecimalIntegerLiteral . DecimalDigits[opt] ExponentPart[opt]
    . DecimalDigits ExponentPart[opt]
    DecimalIntegerLiteral ExponentPart[opt]


  DecimalIntegerLiteral ::
    0
    NonZeroDigit DecimalDigits[opt]


  DecimalDigits ::
    DecimalDigit
    DecimalDigits DecimalDigit


  DecimalDigit :: one of
    0 1 2 3 4 5 6 7 8 9


  NonZeroDigit :: one of
    1 2 3 4 5 6 7 8 9


  ExponentPart ::
    ExponentIndicator SignedInteger


  ExponentIndicator :: one of
    e E


  SignedInteger ::
    DecimalDigits
    + DecimalDigits
    - DecimalDigits


  HexIntegerLiteral ::
    0x HexDigit
    0X HexDigit
    HexIntegerLiteral HexDigit


  HexDigit :: one of
    0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F


The source character immediately following a NumericLiteral must not be an IdentifierStart or DecimalDigit.

数値リテラルに直ぐに続くソース文字は、IdentifierStartもしくはDecimalDigitであることはありません。


NOTE For example:

注意：例えば...


    3in


is an error and not the two input elements 3 and in.

..."3in"はエラーとなります。"3"と"in"という二つの入力にはなりません。


Semantics

意味


A numeric literal stands for a value of the Number type. This value is determined in two steps: first, a mathematical value (MV) is derived from the literal; second, this mathematical value is rounded as described below.

数値リテラルはNumber型の値を表します。この値は二つのステップで決められます。まず始めにリテラルに由来する数学的値(MV)、続いてこの数学的値が以下のルールで丸められます。


- The MV of NumericLiteral :: DecimalLiteral is the MV of DecimalLiteral.
- The MV of NumericLiteral :: HexIntegerLiteral is the MV of HexIntegerLiteral.
- The MV of DecimalLiteral :: DecimalIntegerLiteral . is the MV of DecimalIntegerLiteral.
- The MV of DecimalLiteral :: DecimalIntegerLiteral . DecimalDigits is the MV of DecimalIntegerLiteral plus (the MV of DecimalDigits times 10^(-n)), where n is the number of characters in DecimalDigits.
- The MV of DecimalLiteral :: DecimalIntegerLiteral . ExponentPart is the MV of DecimalIntegerLiteral times 10^e, where e is the MV of ExponentPart.
- The MV of DecimalLiteral :: DecimalIntegerLiteral . DecimalDigits ExponentPart is (the MV of DecimalIntegerLiteral plus (the MV of DecimalDigits times 10^(-n))) times 10^e, where n is the number of characters in DecimalDigits and e is the MV of ExponentPart.
- The MV of DecimalLiteral :: . DecimalDigits is the MV of DecimalDigits times 10^(-n), where n is the number of characters in DecimalDigits.
- The MV of DecimalLiteral :: . DecimalDigits ExponentPart is the MV of DecimalDigits times 10^(e-n), where n is the number of characters in DecimalDigits and e is the MV of ExponentPart.
- The MV of DecimalLiteral :: DecimalIntegerLiteral is the MV of DecimalIntegerLiteral.
- The MV of DecimalLiteral :: DecimalIntegerLiteral ExponentPart is the MV of DecimalIntegerLiteral times 10e , where e is the MV of ExponentPart.
- The MV of DecimalIntegerLiteral :: 0 is 0.
- The MV of DecimalIntegerLiteral :: NonZeroDigit DecimalDigits is (the MV of NonZeroDigit times 10^n) plus the MV of DecimalDigits, where n is the number of characters in DecimalDigits.
- The MV of DecimalDigits :: DecimalDigit is the MV of DecimalDigit.
- The MV of DecimalDigits :: DecimalDigits DecimalDigit is (the MV of DecimalDigits times 10) plus the MV of DecimalDigit.
- The MV of ExponentPart :: ExponentIndicator SignedInteger is the MV of SignedInteger.
- The MV of SignedInteger :: DecimalDigits is the MV of DecimalDigits.
- The MV of SignedInteger :: + DecimalDigits is the MV of DecimalDigits.
- The MV of SignedInteger :: - DecimalDigits is the negative of the MV of DecimalDigits.
- The MV of DecimalDigit :: 0 or of HexDigit :: 0 is 0.
- The MV of DecimalDigit :: 1 or of NonZeroDigit :: 1 or of HexDigit :: 1 is 1.
- The MV of DecimalDigit :: 2 or of NonZeroDigit :: 2 or of HexDigit :: 2 is 2.
- The MV of DecimalDigit :: 3 or of NonZeroDigit :: 3 or of HexDigit :: 3 is 3.
- The MV of DecimalDigit :: 4 or of NonZeroDigit :: 4 or of HexDigit :: 4 is 4.
- The MV of DecimalDigit :: 5 or of NonZeroDigit :: 5 or of HexDigit :: 5 is 5.
- The MV of DecimalDigit :: 6 or of NonZeroDigit :: 6 or of HexDigit :: 6 is 6.
- The MV of DecimalDigit :: 7 or of NonZeroDigit :: 7 or of HexDigit :: 7 is 7.
- The MV of DecimalDigit :: 8 or of NonZeroDigit :: 8 or of HexDigit :: 8 is 8.
- The MV of DecimalDigit :: 9 or of NonZeroDigit :: 9 or of HexDigit :: 9 is 9.
- The MV of HexDigit :: a or of HexDigit :: A is 10.
- The MV of HexDigit :: b or of HexDigit :: B is 11.
- The MV of HexDigit :: c or of HexDigit :: C is 12.
- The MV of HexDigit :: d or of HexDigit :: D is 13.
- The MV of HexDigit :: e or of HexDigit :: E is 14.
- The MV of HexDigit :: f or of HexDigit :: F is 15.
- The MV of HexIntegerLiteral :: 0x HexDigit is the MV of HexDigit.
- The MV of HexIntegerLiteral :: 0X HexDigit is the MV of HexDigit.
- The MV of HexIntegerLiteral :: HexIntegerLiteral HexDigit is (the MV of HexIntegerLiteral times 16) plus the MV of HexDigit.

以下では、nはDicimalDigitsの文字の長さ、eはExponentPartのMVの値です。
- NumericLiteralが DecimalLiteral の場合、
    MVの値はDecimalLiteralの値です。
- NumericLiteralが HexIntegerLiteral の場合、
    MVの値はHexIntegerLiteralの値です。
      例：0xffff
- DecimalLiteralが DecimalIntegerLiteral . の場合、
    MVの値はDecimalIntegerLiteralの値です。
      例：1234.
- DecimalLiteralが DecimalIntegerLiteral . DecimalDigits の場合、
    MVの値は (DecimalIntegerLiteral + DecimalDigits * 10^(-n)) です。
      例：1234.567 = (1234 + 567 * 10^(-3))
- DecimalLiteralが DecimalIntegerLiteral . ExponentPart の場合、
    MVの値は (DecimalIntegerLiteral * 10^e) です。
      例：1234.e+5 = (1234 * 10^5)
- DecimalLiteralが DecimalIntegerLiteral . DecimalDigits ExponentPart の場合、
    MVの値は ((DecimalIntegerLiteral + DecimalDigits * 10^(-n)) * 10^e) です。
      例：1234.567e+8 = (1234 + 567 * 10^8)
- DecimalLiteralが . DecimalDigits ExponentPart の場合、
    MVの値は (DecimalDigits * 10^(-n)) です。
      例：123 = (123 * 10^(-3))
- DecimalLiteralが . DecimalDigits ExponentPart の場合、
    MVの値は (DecimalDigits * 10^(e-n)) です。
      例：123+e4 = (123 * 10 (4-3))
- DecimalLiteralが DecimalIntegerLiteral の場合、
    MVの値は DecimalIntegerLiteral の値です。
      例：1234
- DecimalLiteralが DecimalIntegerLiteral ExponentPart の場合、
    MVの値は (DecimalIntegerLiteral * 10^e)) です。
      例：1234e+5 = (1234 * 10^5)
- DecimalLiteralが 0 の場合、
    MVの値は 0 です。
      例：0
- DecimalLiteralが NonZeroDigit DecimalDigits の場合、
    MVの値は (NonZeroDigit * 10^n + DecimalDigits) です。
      例：1234 = (1 * 10^3 + 234)
- DecimalDigitsが DecimalDigit の場合、
    MVの値は DecimalDigit です。
      例：1
- DecimalDigitsが DecimalDigits DecimalDigit の場合、
    MVの値は (DecimalDigits * 10 + DecimalDigit) です。
      例：1234 = ((((1 * 10 + 2) * 10 + 3) * 10 + 4)))
- ExponentPartが ExponentIndicator SignedInteger の場合、
    MVの値は SignedInteger の値です。
- SignedIntegerが DecimalDigits の場合、
    MVの値は DecimalDigits の値です。
- SignedIntegerが + DecimalDigits の場合、
    MVの値は DecimalDigits の値です。
- SignedIntegerが - DecimalDigits の場合、
    MVの値は (DecimalDigits * (-1)) の値です。
- DecimalDigitもしくはHexDigitが 0 の場合、
    MVの値は 0 です。
- DecimalDigitもしくはNonZeroDigitもしくはHexDigitが 1...9 の場合、
    MVの値はそれぞれ 1...9 です。
- HexDigitが a...f もしくは A...F の場合、
    MVの値はそれぞれ 10...15 です。
- HexIntegerLiteralが 0x HexDigit もしくは 0X HexDigit の場合、
    MVの値は HexDigit の値です。
- HexIntegerLiteralが HexIntegerLiteral HexDigit の場合、
    MVの値は (HexIntegerLiteral * 16 + HexDigit) の値です。


Once the exact MV for a numeric literal has been determined, it is then rounded to a value of the Number type. If the MV is 0, then the rounded value is +0; otherwise, the rounded value must be the Number value for the MV (as specified in 8.5), unless the literal is a DecimalLiteral and the literal has more than 20 significant digits, in which case the Number value may be either the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a 0 digit or the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a 0 digit and then incrementing the literal at the 20th significant digit position. A digit is significant if it is not part of an ExponentPart and
- it is not 0; or
- there is a nonzero digit to its left and there is a nonzero digit, not in the ExponentPart, to its right.

数値リテラルに対して厳密なMVの値が定まると、次に数値への丸めが行われます。もしMVが0ならば、丸められた値は+0になります。そうでなければ、リテラルがDecimalLiteralで有効桁数が20桁を越える場合でなければ、丸められた値は(8.5で示されるように)MVに対する数値にならなければなりません。有効桁数が20桁を越えるような場合では、数値は、有効桁数の20桁より後の桁を0で置き換えて作られたリテラルのMVに対する数値、もしくは、有効桁数の20桁より後の桁を0で置き換えて作られたリテラルのMVに対する数値の20桁目を1加算した数値となります。数字は、それがExponentPartでなければ有効桁になります。かつ...
- 0ではない。もしくは...
- その桁の左側に0でない数字があること、かつ、ExponentPartを除くその桁の右側に0でない数字があること。
...であれば有効桁になります。


A conforming implementation, when processing strict mode code (see 10.1.1), must not extend the syntax of NumericLiteral to include OctalIntegerLiteral as described in B.1.1.

適合する実装では、strictモード(10.1.1)で処理している場合には、B.1.1で述べているようにOctalIntegerLiteralを含むようにNumericLiteralの構文を拡張してはいけません。


* 7.8.4 String Literals

* 7.8.4 文字列リテラル


A string literal is zero or more characters enclosed in single or double quotes. Each character may be represented by an escape sequence. All characters may appear literally in a string literal except for the closing quote character, backslash, carriage return, line separator, paragraph separator, and line feed. Any character may appear in the form of an escape sequence.

文字列リテラルは、単一引用符もしくは二重引用符で括られたゼロもしくはそれ以上の長さの文字です。文字はエスケープシーケンスで表現されているかもしれません。文字列を閉じる引用符や、バックスラッシュ、carriage return、行区切り文字、段落の区切り文字、line feedを除くすべての文字は、文字列リテラルの中にそのまま現れます。どの文字もエスケープシーケンスの形式で現れることができます。


Syntax

構文


  StringLiteral ::
    " DoubleStringCharacters[opt] "
    ' SingleStringCharacters[opt] '


  DoubleStringCharacters ::
    DoubleStringCharacter DoubleStringCharacters[opt]


  SingleStringCharacters ::
    SingleStringCharacter SingleStringCharacters[opt]


  DoubleStringCharacter ::
    SourceCharacter but not double-quote "or backslash \or LineTerminator
    \ EscapeSequence
    LineContinuation


  SingleStringCharacter ::
    SourceCharacter but not single-quote 'or backslash \or LineTerminator
    \ EscapeSequence
    LineContinuation


  LineContinuation ::
    \ LineTerminatorSequence


  EscapeSequence ::
    CharacterEscapeSequence0 [lookahead not_a_member_of DecimalDigit]
    HexEscapeSequence
    UnicodeEscapeSequence


  CharacterEscapeSequence ::
    SingleEscapeCharacter
    NonEscapeCharacter


  SingleEscapeCharacter :: one of
    ' " \ b f n r t v


  NonEscapeCharacter ::
    SourceCharacter but not EscapeCharacter or LineTerminator


  EscapeCharacter ::
    SingleEscapeCharacter
    DecimalDigit
    x
    u


  HexEscapeSequence ::
    x HexDigit HexDigit


  UnicodeEscapeSequence ::
    u HexDigit HexDigit HexDigit HexDigit


The definitions of the nonterminal HexDigit is given in 7.6. SourceCharacter is defined in clause 6.

非終端記号HexDigitの定義は7.6節で与えました。SourceCharacterは6節で与えました。


Semantics

意味


A string literal stands for a value of the String type. The String value (SV) of the literal is described in terms of character values (CV) contributed by the various parts of the string literal. As part of this process, some characters within the string literal are interpreted as having a mathematical value (MV), as described below or in 7.8.3.

文字列リテラルは文字列値を表します。リテラルの文字列値(String Value, SV)は文字列リテラルの様々な種類から構成される文字値(Character Value, CV)という意味で述べられている。この過程において、文字列リテラルのいくつかの文字は、7.8.3節で以前述べたようなMV値を保持しているかのように解釈されます。


- The SV of StringLiteral :: "" is the empty character sequence.
- The SV of StringLiteral :: '' is the empty character sequence.
- The SV of StringLiteral :: "DoubleStringCharacters" is the SV of DoubleStringCharacters.
- The SV of StringLiteral :: 'SingleStringCharacters' is the SV of SingleStringCharacters.
- The SV of DoubleStringCharacters :: DoubleStringCharacter is a sequence of one character, the CV of DoubleStringCharacter.
- The SV of DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters is a sequence of the CV of DoubleStringCharacter followed by all the characters in the SV of DoubleStringCharacters in order.
- The SV of SingleStringCharacters :: SingleStringCharacter is a sequence of one character, the CV of SingleStringCharacter.
- The SV of SingleStringCharacters :: SingleStringCharacter SingleStringCharacters is a sequence of the CV of SingleStringCharacter followed by all the characters in the SV of SingleStringCharacters in order.
- The SV of LineContinuation :: \LineTerminatorSequence is the empty character sequence.
- The CV of DoubleStringCharacter :: SourceCharacter but not double-quote "or backslash \or LineTerminator is the SourceCharacter character itself.
- The CV of DoubleStringCharacter :: \ EscapeSequence is the CV of the EscapeSequence.
- The CV of SingleStringCharacter :: SourceCharacter but not single-quote ' or backslash \ or LineTerminator is the SourceCharacter character itself.
- The CV of SingleStringCharacter :: \ EscapeSequence is the CV of the EscapeSequence.
- The CV of EscapeSequence :: CharacterEscapeSequence is the CV of the CharacterEscapeSequence.
- The CV of EscapeSequence :: 0 [lookahead not_a_member_of DecimalDigit] is a &lt;NUL&gt; character (Unicode value 0000).
- The CV of EscapeSequence :: HexEscapeSequence is the CV of the HexEscapeSequence.
- The CV of EscapeSequence :: UnicodeEscapeSequence is the CV of the UnicodeEscapeSequence.
- The CV of CharacterEscapeSequence :: SingleEscapeCharacter is the character whose code unit value is determined by the SingleEscapeCharacter according to Table 4:

- StringLiteral が "" の場合、
    SVの値は空の文字の並びです。
- StringLiteral が '' の場合、
    SVの値は空の文字の並びです。
- StringLiteral が " DoubleStringCharacters " の場合、
    SVの値はDoubleStringCharactersの値です。
- StringLiteral が ' SingleStringCharacters ' の場合、
    SVの値はSingleStringCharactersの値です。
- DoubleStringCharacters が DoubleStringCharacter 一文字の場合、
    SVの値はDoubleStringCharacterのCVの値からなるひとつの文字の並びになります。
- DoubleStringCharacters が DoubleStringCharacter DoubleStringCharacters の場合
    SVの値はDoubleStringCharacterのCVの値にDoubleStringCharactersのSVの値のすべての文字を続けたものの並びになります。
- SingleStringCharacters が SingleStringCharacter 一文字の場合、
    SVの値はSingleStringCharacterのCVの値からなるひとつの文字の並びになります。
- SingleStringCharacters が SingleStringCharacter SingleStringCharacters の場合
    SVの値はSingleStringCharacterのCVの値にSingleStringCharactersのSVの値のすべての文字を続けたものの並びになります。
- LineContinuation が \ LineTerminatorSequence の場合、
    SVの値は空の文字の並びです。
- DoubleStringCharacter が、二重引用符 " でも、バックスラッシュ \ でも LineTerminator でもない SourceCharacter の場合、
    CVの値はその文字自身になります。
- DoubleStringCharacter が \ EscapeSequence の場合、
    CVの値はEscapeSequenceの値です。
- SingleStringCharacter が、引用符 ' でも、バックスラッシュ \ でも LineTerminator でもない SourceCharacter の場合、
    CVの値はその文字自身になります。
- SingleStringCharacter が \ EscapeSequence の場合、
    CVの値はEscapeSequenceの値です。
- EscapeSequence が CharacterEscapeSequence の場合、
    CVの値はCharacterEscapeSequenceの値です。
- EscapeSequence が 0 [lookahead not_a_member_of DecimalDigit] の場合、
    CVの値は&lt;NUL&gt;文字です。(Unicode値 0000)
- EscapeSequence が HexEscapeSequence の場合、
    CVの値はHexEscapeSequenceの値です。
- EscapeSequence が UnicodeEscapeSequence の場合、
    CVの値はUnicodeEscapeSequenceの値です。
- CharacterEscapeSequence が SingleEscapeCharacter の場合、
    CVの値は表4のSingleEscapeCharacterによってそのコード単位が決まる文字です。


Table 4 - String Single Character Escape Sequences
--------------- --------------- ----------------------- ------------------------
Escape Sequence Code Unit Value Name                    Symbol
--------------- --------------- ----------------------- ------------------------
\b              \u0008          backspace               &lt;BS&gt;
\t              \u0009          horizontal tab          &lt;HT&gt;
\n              \u000A          line feed (new line)    &lt;LF&gt;
\v              \u000B          vertical tab            &lt;VT&gt;
\f              \u000C          form feed               &lt;FF&gt;
\r              \u000D          carriage return         &lt;CR&gt;
\"              \u0022          double quote            "
\'              \u0027          single quote            '
\\              \u005C          backslash               \
--------------- --------------- ----------------------- ------------------------

表4 - 文字列の単一文字のエスケープシーケンス
----------------------- ----------- ----------------------- --------------------
エスケープシーケンス    コード単位  名前                    シンボル
----------------------- ----------- --- ------------------- --------------------
\b                      \u0008      backspace               &lt;BS&gt;
\t                      \u0009      horizontal tab          &lt;HT&gt;
\n                      \u000A      line feed (new line)    &lt;LF&gt;
\v                      \u000B      vertical tab            &lt;VT&gt;
\f                      \u000C      form feed               &lt;FF&gt;
\r                      \u000D      carriage return         &lt;CR&gt;
\"                      \u0022      double quote            "
\'                      \u0027      single quote            '
\\                      \u005C      backslash               \
----------------------- ----------- ----------------------- --------------------


- The CV of CharacterEscapeSequence :: NonEscapeCharacter is the CV of the NonEscapeCharacter.
- The CV of NonEscapeCharacter :: SourceCharacter but not EscapeCharacter or LineTerminator is the SourceCharacter character itself.
- The CV of HexEscapeSequence :: x HexDigit HexDigit is the character whose code unit value is (16 times the MV of the first HexDigit) plus the MV of the second HexDigit.
- The CV of UnicodeEscapeSequence :: u HexDigit HexDigit HexDigit HexDigit is the character whose code unit value is (4096 times the MV of the first HexDigit) plus (256 times the MV of the second HexDigit) plus (16 times the MV of the third HexDigit) plus the MV of the fourth HexDigit.

- CharacterEscapeSequence が NonEscapeCharacter の場合、
    CVの値はNonEscapeCharacterの値です。
- NonEscapeCharacter が、EscapeCharacter もしくは LineTerminator 以外の SourceCharacter の場合、
    CVの値はSourceCharacterの文字のそのものです。
- HexEscapeSequence が、x HexDigit HexDigit の場合、
    CVの値は (最初のHexDigitのMVの値 * 16) + 次のHexDigitのMVの値であるコード単位の文字になります。
- UnicodeEscapeSequence が、u HexDigit HexDigit HexDigit HexDigit の場合、
    CVの値は (最初のHexDigitのMVの値 * 4096) + (二つ目のHexDigitのMVの値 * 256) + (三つ目のHexDigitのMVの値 x 16) + 四つ目のHexDigitのMV値であるコード単位の文字になります。


A conforming implementation, when processing strict mode code (see 10.1.1), may not extend the syntax of EscapeSequence to include OctalEscapeSequence as described in B.1.2.

適合する実装では、strictモードのコード(10.1.1)を処理する場合は、B.1.2で述べられているOctalEscapeSequenceを含むEscapeSequenceの構文の拡張は行わないかもしれません。


NOTE A line terminator character cannot appear in a string literal, except as part of a LineContinuation to produce the empty character sequence. The correct way to cause a line terminator character to be part of the String value of a string literal is to use an escape sequence such as \n or \u000A.

注意：空の文字の並びを作り出すためのLineContinuationの一部である場合を除いて、文字列リテラルには改行文字は現れることはできません。文字列リテラルrの文字列値の一部として改行文字を含ませる正しい方法は、\n や \u000A といったエスケープシーケンスを使うことです。


* 7.8.5 Regular Expression Literals

* 7.8.5 正規表現リテラル


A regular expression literal is an input element that is converted to a RegExp object (see 15.10) each time the literal is evaluated. Two regular expression literals in a program evaluate to regular expression objects that never compare as === to each other even if the two literals' contents are identical. A RegExp object may also be created at runtime by new RegExp (see 15.10.4) or calling the RegExp constructor as a function (15.10.3).

正規表現リテラルは、リテラルが評価されるたびにRegExpオブジェクト(15.10)へと変換される入力要素です。プログラム上の二つの正規表現リテラルは
二つのリテラルの内容が互いに同一であっても、===で比較しても同じにならないようにオブジェクトへと評価します。RegExpオブジェクトはnew RegExp(15.10.4)によって実行時に作られるかもしれませんし、RegExpコンストラクタを関数として呼び出すかもしれません。


The productions below describe the syntax for a regular expression literal and are used by the input element scanner to find the end of the regular expression literal. The Strings of characters comprising the RegularExpressionBody and the RegularExpressionFlags are passed uninterpreted to the regular expression constructor, which interprets them according to its own, more stringent grammar. An implementation may extend the regular expression constructor's grammar, but it must not extend the RegularExpressionBody and RegularExpressionFlags productions or the productions used by these productions.

以下の生成規則は正規表現リテラルの構文を述べており、正規表現リテラルの終端を探すために入力要素のスキャナによって使われます。RegularExpressionBodyとRegularExpressionFlagsを含む文字列は解釈されないまま正規表現コンストラクタに渡され、そこで更に厳しい文法で解釈されます。
実装では正規表現コンストラクタの文法を拡張しているかもしれませんが、RegularExpressionBodyとRegularExpressoinFlagの生成規則やこれらを使っている生成規則を拡張してはいけません。


Syntax

構文


  RegularExpressionLiteral ::
    / RegularExpressionBody / RegularExpressionFlags


  RegularExpressionBody ::
    RegularExpressionFirstChar RegularExpressionChars


  RegularExpressionChars ::
    [empty]


  RegularExpressionChars RegularExpressionChar
    RegularExpressionFirstChar ::
    RegularExpressionNonTerminator but not *or \or / or [
    RegularExpressionBackslashSequence
    RegularExpressionClass


  RegularExpressionChar ::
    RegularExpressionNonTerminator but not \or / or [
    RegularExpressionBackslashSequence
    RegularExpressionClass


  RegularExpressionBackslashSequence ::
    \ RegularExpressionNonTerminator


  RegularExpressionNonTerminator ::
    SourceCharacter but not LineTerminator


  RegularExpressionClass ::
    [ RegularExpressionClassChars ]


  RegularExpressionClassChars ::
    [empty]


  RegularExpressionClassChars RegularExpressionClassChar
    RegularExpressionClassChar ::
    RegularExpressionNonTerminator but not ]or \
    RegularExpressionBackslashSequence


  RegularExpressionFlags ::
    [empty]
    RegularExpressionFlags IdentifierPart


NOTE Regular expression literals may not be empty; instead of representing an empty regular expression literal, the characters // start a single-line comment. To specify an empty regular expression, use: /(?:)/.

注意：正規表現リテラルは空ではないだろうことから、空の正規表現リテラルを表現する代わりに、//という文字の並びは行コメントを開始します。空の正規表現を指定する場合には/(?:)/を使います。


Semantics

意味


A regular expression literal evaluates to a value of the Object type that is an instance of the standard built-in constructor RegExp. This value is determined in two steps: first, the characters comprising the regular expression's RegularExpressionBody and RegularExpressionFlags production expansions are collected uninterpreted into two Strings Pattern and Flags, respectively. Then each time the literal is evaluated, a new object is created as if by the expression new RegExp(Pattern, Flags) where RegExp is the standard built-in constructor with that name. The newly constructed object becomes the value of the RegularExpressionLiteral. If the call to new RegExp would generate an error as specified in 15.10.4.1, the error must be treated as an early error (Clause 16).

正規表現リテラルは標準組み込みのコンストラクタRegExpのインスタンスであるオブジェクトの値へと評価します。値は二つのステップで決められます。まず最初に、正規表現のRegularExpressionBodyとRegularExpressionFlagsの生成規則の展開したものを含む文字の並びは、未解釈のまま二つの文字列PatternとFlagsへとそれぞれ集められます。次に、リテラルが評価されるたびに、標準組み込みのコンストラクタであるRegExpを、式new Regexp(Pattern, Flags)で呼び出されたかのようにして新しいオブジェクトが作られます。新しく作られたオブジェクトはRegularExpressionLiteralの値になります。new Regexpへの呼び出しが15.10.4.1で示されているエラーを起こした場合には、エラーは初期エラー(16)として扱わなければいけません。


* 7.9 Automatic Semicolon Insertion

* 7.9 セミコロンの自動挿入


Certain ECMAScript statements (empty statement, variable statement, expression statement, do-while statement, continue statement, break statement, return statement, and throw statement) must be terminated with semicolons. Such semicolons may always appear explicitly in the source text. For convenience, however, such semicolons may be omitted from the source text in certain situations. These situations are described by saying that semicolons are automatically inserted into the source code token stream in those situations.

いくつかのECMAScriptのステートメントは...
- 空のステートメント
- 変数のステートメント
- 式ステートメント
- do-whileステートメント
- continueステートメント
- breakステートメント
- returnステートメント
- throwステートメント
...セミコロンで終わらなければいけません。そういったセミコロンはソーステキスト上にいつも明示的に現れます。しかしながら、利便性のために特定の状況ではそういったセミコロンはソーステキストから省略されます。これらの状況は「そういう状況下でソースコードのトークンのストリームにセミコロンが自動挿入された」と言うことによって述べられます。


* 7.9.1 Rules of Automatic Semicolon Insertion

* 7.9.1 セミコロンの自動挿入のルール


There are three basic rules of semicolon insertion:

セミコロンの自動挿入には3つの基本的なルールがあります。


1. When, as the program is parsed from left to right, a token (called the offending token) is encountered that is not allowed by any production of the grammar, then a semicolon is automatically inserted before the offending token if one or more of the following conditions is true:

1. プログラムが左から右へと解析されるとして、文法のどの生成規則でも許されない(offendingと呼ばれる)トークンが現れたときに、以下のひとつ以上の条件を満たしたらoffendingトークンの前に自動的にセミコロンが挿入されます。


- The offending token is separated from the previous token by at least one LineTerminator.
- The offending token is }.

- offendingトークンが前のトークンと少なくともひとつのLineTerminatorによって分けられていること。
- offendingトークンが } であること。


2. When, as the program is parsed from left to right, the end of the input stream of tokens is encountered and the parser is unable to parse the input token stream as a single complete ECMAScript Program, then a semicolon is automatically inserted at the end of the input stream.

2. プログラムが左から右へと解析されるとして、トークンの入力ストリームの終わりが現れ、解析器が入力トークンのストリームを単一の完全なECMAScriptプログラムとして解析できなかった場合に、そのときに入力ストリームの終わりにセミコロンが自動的に挿入されます。


3. When, as the program is parsed from left to right, a token is encountered that is allowed by some production of the grammar, but the production is a restricted production and the token would be the first token for a terminal or nonterminal immediately following the annotation “[no LineTerminator here]” within the restricted production (and therefore such a token is called a restricted token), and the restricted token is separated from the previous token by at least one LineTerminator, then a semicolon is automatically inserted before the restricted token. However, there is an additional overriding condition on the preceding rules: a semicolon is never inserted automatically if the semicolon would then be parsed as an empty statement or if that semicolon would become one of the two semicolons in the header of a for statement (see 12.6.3). However, there is an additional overriding condition on the preceding rules: a semicolon is never inserted automatically if the semicolon would then be parsed as an empty statement or if that semicolon would become one of the two semicolons in the header of a for statement (see 12.6.3).

3. プログラムが左から右へと解析されるとして、文法上のある生成規則で許されるトークンが現れた場合に、ただし、その生成規則は制限された生成規則であり、制限された生成規則上で"[no LineTerminator here]"という注記にすぐに続く最初の終端記号もしくは非終端記号のトークン(そのためトークンは制限されたトークンと呼ばれます)であり、制限されたトークンが少なくともひとつ以上のLineTerminatorによって前のトークンから分けられている場合には、制限されたトークンの前にセミコロンが自動挿入されます。しかしながら、このルールには追加の上書きされる条件があります。セミコロンが空のステートメントとして解析されたり、セミコロンがforステートメント(12.6.3)の先頭部分の二つのセミコロンになったりする場合には、セミコロンは自動挿入されません。


NOTE The following are the only restricted productions in the grammar:

注意：以下は文法において制限されている生成規則だけです。


  PostfixExpression :
    LeftHandSideExpression [no LineTerminator here] ++
    LeftHandSideExpression [no LineTerminator here] --


  ContinueStatement :
    continue [no LineTerminator here] Identifier[opt] ;


  BreakStatement :
    break [no LineTerminator here] Identifier[opt] ;


  ReturnStatement :
    return [no LineTerminator here] Expression[opt] ;


  ThrowStatement :
    throw [no LineTerminator here] Expression ;


The practical effect of these restricted productions is as follows:

これらの制限された生成規則の影響は以下のとおりです。


When a ++ or -- token is encountered where the parser would treat it as a postfix operator, and at least one LineTerminator occurred between the preceding token and the ++ or -- token, then a semicolon is automatically inserted before the ++ or -- token.

解析器が後置演算子として扱う場所で ++ もしくは -- トークンが現れた場合、かつ、前のトークンと ++ もしくは -- トークンの間に少なくともひとつ以上のLineTerminatorが現れていた場合、そのときには ++ もしくは -- トークンの前にセミコロンが自動挿入されます。


When a continue, break, return, or throw token is encountered and a LineTerminator is encountered before the next token, a semicolon is automatically inserted after the continue, break, return, or throw token.

continue、break、return、throwトークンが現れた場合、かつ、次のトークンの前にLineTerminatorが現れた場、contineu、break、return、throwトークンの後にセミコロンが自動挿入されます。


The resulting practical advice to ECMAScript programmers is:

ECMAScriptのプログラマ向けに実践的なアドバイスをするとすれば...


A postfix ++ or -- operator should appear on the same line as its operand.

後置演算子の ++ や -- は、オペランドとして同じ行に現れるべきです。


An Expression in a return or throw statement should start on the same line as the return or throw token.

returnやthrowステートメントの中の式は、returnやthrowトークンと同じ行から始めるべきです。


A Identifier in a break or continue statement should be on the same line as the break or continue token.

breakやcontinueステートメントの中の識別子は、breakやcontinueトークンと同じ行にあるべきです。


* 7.9.2 Examples of Automatic Semicolon Insertion

* 7.9.2 セミコロンの自動挿入の例


The source

このソースコードは...


{ 1 2 } 3


is not a valid sentence in the ECMAScript grammar, even with the automatic semicolon insertion rules. In contrast, the source

...ECMAScriptの文法では有効ではありませんし、セミコロンの自動挿入を行ってさえ有効にはなりません。対照的に...


{ 1
2 } 3


is also not a valid ECMAScript sentence, but is transformed by automatic semicolon insertion into the following:

...このソースコードもECMAScriptの文法では有効ではありませんが、セミコロンが自動挿入され以下のように変形されることで...


{ 1
;2 ;} 3;


which is a valid ECMAScript sentence.

...有効なECMAScriptの文になります。


The source

このソースコードは...


for (a; b
)


is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion because the semicolon is needed for the header of a for statement. Automatic semicolon insertion never inserts one of the two semicolons in the header of a for statement.

...ECMAScriptの有効な文ではありませんし、セミコロンがforステートメントの先頭部分に必要なので、セミコロンの自動挿入によって変更されることもありません。セミコロンの自動挿入が、forステートメントの先頭部分の二つのセミコロンのうちのひとつを挿入するということは決してありません。


The source

このソースコードは...


return
a + b


is transformed by automatic semicolon insertion into the following:

...セミコロンの自動挿入によって以下のように変形されます。


return;
a + b;


NOTE The expression a + b is not treated as a value to be returned by the return statement, because a LineTerminator separates it from the token return.

注意：式 a + b はreturnステートメントによって返されるべき値として扱われません。何故ならば、LineTerminatorがそれらをトークンreturnから分けているからです。


The source

このソースコードは...


a = b
++c


is transformed by automatic semicolon insertion into the following:

...セミコロンの自動挿入によって以下のように変形されます。


a = b;
++c;


NOTE The token ++ is not treated as a postfix operator applying to the variable b, because a LineTerminator occurs between b and ++.

注意：トークン++は変数bに対する後置演算子としては扱われません。何故ならば、LineTerminatorがbと++の間に現れているからです。


The source

このソースコードは...


if (a &gt; b)
else c = d


is not a valid ECMAScript sentence and is not altered by automatic semicolon insertion before the else token, even though no production of the grammar applies at that point, because an automatically inserted semicolon would then be parsed as an empty statement.

...ECMAScriptの有効な文ではありませんし、この箇所に文法の生成規則が適用されることもありませんが、自動挿入されたセミコロンは空のステートメントとして解析されるため、elseトークンの前にセミコロンが自動挿入されて変更されることもありません。


The source

このソースコードは...


a = b + c
(d + e).print()


is not transformed by automatic semicolon insertion, because the parenthesised expression that begins the second line can be interpreted as an argument list for a function call:

...セミコロンの自動挿入によって変更されることはありません。何故ならば、二行目から始まる括弧でくくられた式が関数呼び出しの引数のリストとして解釈されるかもしれないからです。


a = b + c(d + e).print()


In the circumstance that an assignment statement must begin with a left parenthesis, it is a good idea for the programmer to provide an explicit semicolon at the end of the preceding statement rather than to rely on automatic semicolon insertion.

ある状況においては代入文を左括弧で始めなければならないことを考慮すると、セミコロンの自動挿入に頼るよりも前のステートメントの最後に明示的にセミコロンを入れる方がプログラマにとってはよいやり方です。

    </pre>
    <hr>
    <div class="s0">
      Copyright 2013 YAMAMOTO TAIZO All Rights Reserved.
    </div>
  </body>
</html>

補足 D (参考情報)



第3版との互換性に影響を与える第5版における修正と明示


全体：
第3版の仕様において、"as if by the expression new Array()"という語句の意味は誤解される内容でした。第5版の仕様では、標準組み込みオブジェクトや標準組み込みメソッドのすべての内部参照や内部呼び出しのテキストは、対応する名前付きプロパティの動的な値ではなく、実際の組み込みオブジェクトが使われるという意図を明示することによってはっきりされました。

11.8.2, 11.8.3, 11.8.5：
ECMAScriptでは通常は左から右に向かって評価しますが、第3版の仕様における>演算子や<=演算子では、部分的に右から左に向かって評価していました。これらの演算子のために完全に左から右に向かって評価するように仕様が訂正されました。なお、この評価順序の変化は、評価処理において副作用を伴う場合にだけ潜在的に観測されるようなものです。

11.1.4：
第5版では、ArrayInitialiserの後ろのカンマが配列の長さを増やさないということをはっきりさせました。これは第3版からの意味的な変更ではありませんが、以前はこれを間違って解釈していた実装があるかもしれません。

11.2.3：
第5版ではアルゴリズムのステップ２やステップ３の順番を予約しています。第1版から第3版で指定されていた元々の順番は、引数の評価の副作用がMemberExpressionの評価の結果に影響を与えられるという点で、間違っていました。

12.4：
第3版において、tryステートメントのcatch節へ渡される例外パラメタの名前を解決するためのスコープとして使用するために、new Object()によって作られたかのようにしてオブジェクトが作られています。もし、実際の例外オブジェクトが関数であり、それがcatch節で呼び出されると、callのthis値としてスコープオブジェクトが渡されるでしょう。関数のボディ部はそのthis値で新しいプロパティを定義し、それらのプロパティの名前は関数が終わった後のcatch節のスコープにおいて見える識別子にバインディングされます。第5版では、例外パラメタが関数として呼び出される際には、this値としてundefinedが渡されるようになりました。

13：
第3版において、生成規則FunctionExpressionのIdentifierのアルゴリズムでは、スコープチェーンに対してnew Object()によって作られたかようにしてオブジェクトを追加しています。これは関数の名前を探すためのスコープとして使用するためです。そういったオブジェクトに適用された識別子の解決ルール(第3版 10.1.4)は、必要であれば、識別子の解決が試みられた際にオブジェクトのプロトタイプチェーンに従います。これはObject.prototypeのすべてのプロパティがスコープの識別子として見えていることを意味します。実際、第3版のほとんどの実装ではこれは実装されていません。第5版では、関数の名前をバインドするためにDeclarative Environment Recordを使うことでそのことを変更しています。

14：
第3版において、生成規則 SourceElements : SourceElements SourceElement のアルゴリズムは文の結果の値を、ブロックと同じようなやり方に則らずに、間違った伝え方をしていました。これはProgramのテキストを評価する際に、eval関数において結果として間違った結果が生成されることになります。実際に第3版のほとんどの実装では、第3版で示されていたよりも正しい実装がされていました。

15.10.6：
RegExp.prototypeは、Objectのインスタンスというよりも今ではRegexpオブジェクトとなっています。Object.prototype.toStringで確認できる[[Class]]内部プロパティの値は、"Object"ではなく"RegExp"です。
 

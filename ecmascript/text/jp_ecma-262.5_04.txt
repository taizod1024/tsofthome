4 概要


この節にはECMAScript言語の非規定的な概要が含まれています。

ECMAScriptはそのホスト環境において計算したりオブジェクトを操作したりするためのオブジェクト指向なプログラミング言語です。ここで定義されているECMAScriptはここで自己完結するものではありません。実際にこの仕様において外部データの入力や計算結果の出力に関する規定はありません。その代わりにECMAScriptのプログラムの実行環境は、この仕様において述べられているオブジェクトやその他の機能だけではなく、固有の環境に依存したオブジェクトを提供することが想定されています。そのオブジェクトの説明や挙動については、ECMAScriptのプログラムからアクセス可能な固有プロパティや呼び出せる固有の関数をその実行環境が提供する、ということを除いてこの仕様の範囲外です。

スクリプト言語は、既存システムの機能の操作・カスタマイズ・自動化を行うために使われるプログラミング言語です。そのような既存のシステムでは、役に立つ機能はユーザーインターフェイスを介して既に提供されているので、スクリプト言語はそういった機能をプログラムで制御し公開するための仕組みとなります。この方法では、既存のシステムはスクリプト言語が必要とする要件を満たしているオブジェクトや機能のホスト環境と言えます。スクリプト言語はプロのプログラマとそうでないプログラマの両方が使用するためのものなのです。

元々、ECMAScriptは、Webベースのクライアントサーバアーキテクチャの一部として、ブラウザにおけるWebページを活性化したりサーバでの計算処理を行う仕組みを提供するためのWeb用のスクリプト言語として設計されました。ECMAScriptは様々な種類のホスト環境のためのコアなスクリプト機能を提供しています。そのため特定のホスト環境によらないコアなスクリプト言語がこの文書では定められています。

ECMAScriptのいくつかの機能は他のプログラミング言語で使われているものとよく似ています。特に以下で述べられているJava、Self、Schemeに似ています。

- Gosling, James, Bill Joy and Guy Steele. The Java. Language Specification. Addison Wesley Publishing Co.,1996.
- Ungar, David, and Smith, Randall B. Self: The Power of Simplicity. OOPSLA '87 Conference Proceedings, pp.227.241, Orlando, FL, October 1987.
- IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.


4.1 Webスクリプト


Webブラウザはクライアントでの計算のためのホスト環境、例えば、ウィンドウ、メニュー、ポップアップメニュー、ダイアログボックス、テキストエリア、アンカー、フレーム、履歴、Cookie、入出力を表すオブジェクトが含まれているホスト環境を提供します。更に、ホスト環境はスクリプトのコードを、例えばフォーカスの変更、ページやイメージのロード、アップロード、エラー、停止、セレクション、フォームの投稿、マウスの操作などといったイベントに結びつけます。スクリプトのコードはHTMLの間に現れ、表示されたページは、ユーザインターフェースの要素や静的もしくは動的に生成されたテキストや画像を組み合わせたものになります。ユーザの応答に対してスクリプトのコードが反応するので、メインのプログラムがそれらの応答を処理する必要はありません。

一方で、Webサーバはサーバでの計算のための別のホスト環境、例えば、リクエスト、クライアント、ファイル、共有データのロックをする仕組みを表現するオブジェクトを含むホスト環境を提供します。Webを基盤とするアプリケーションにとってはユーザインターフェースを提供する際に、ブラウザ側とサーバ側のスクリプトを一緒に使うことで、クライアントとサーバ間での分散処理が可能になります。

ECMAScriptをサポートするWebブラウザやサーバは、ECMAScriptの実行環境を満たす個々のホスト環境を提供しています。


4.2 言語概要


以降は、ECMAScriptの非形式的な概要であり、これが言語のすべてを述べている訳ではありません。また、この概要が適切な標準仕様の一部という訳でもありません。

ECMAScriptはオブジェクトを基盤としています。例えば、基本的な言語自体やホスト環境の機能はオブジェクトによって提供されており、ECMAScriptのプログラムの実行はオブジェクト同士のやりとりによって構成されています。ECMAScriptのオブジェクトは、個々のプロパティがどのように使われるかを定めた0個以上の属性を伴ったプロパティの集合です。例えば、プロパティに関する書き込み属性がfalseに設定されている場合には、プロパティの値を変更しようと試みるいかなるECMAScriptのコードの実行もうまくいきません。また、プロパティは他のオブジェクト、プリミティブ値、関数を含むコンテナでもあります。プリミティブ値は以下の組み込み型のいずれかになります。
- Undefined
- Null
- Boolean
- Number
- String
オブジェクトはその他の組み込み型のオブジェクトのいずれかになります。そして関数は呼び出し可能なオブジェクトです。プロパティを通してあるオブジェクトに関連付けられた関数はメソッドとなります。

ECMAScriptではECMAScriptのエンティティの定義をまとめた組み込みオブジェクトの集合を定義しています。これらの組み込みオブジェクトには以下が含まれます。
- Globalオブジェクト
- Objectオブジェクト
- Functionオブジェクト
- Arrayオブジェクト
- Stringオブジェクト
- Booleanオブジェクト
- Numberオブジェクト
- Mathオブジェクト
- Dateオブジェクト
- RegExpオブジェクト
- JSONオブジェクト
- Errorオブジェクト
  - Error
  - EvalError
  - RangeError
  - ReferenceError
  - SyntaxError
  - TypeError
  - URIError

また、ECMAScriptは組み込み演算子の集合を定義しています。
- 単項演算子
- 乗算演算子
- 加算演算子
- ビットシフト演算子
- 関係演算子
- 等価演算子
- バイナリビット演算子
- バイナリ論理演算
- 代入演算子
- カンマ演算子

ECMAScriptのシンタックスは意図的にJavaのシンタックスに似ています。ECMAScriptのシンタックスはスクリプト言語を使いやすくするために緩くされています。例えば、変数は型が宣言されていることを要求されませんし、プロパティに関連付けられた型が宣言されていることも要求されませんし、定義された関数はそれらが呼び出される前にテキスト上でその宣言が現れていることも要求されません。


4.2.1 オブジェクト


ECMAScriptはC++、Smalltalk、Javaのようなクラスを使っていません。代わりにオブジェクトが様々な方法で作られます。例えばリテラル記法によって作られたり、オブジェクトを作成しそれからプロパティに初期値を代入してオブジェクトの全体もしくは部分を初期化するような実行コードを伴うコンストラクタによって作られます。コンストラクタはプロトタイプに基づく継承とプロパティの共有を行うために用いられるprototypeと名付けられたプロパティを持つ関数です。オブジェクトはnew式においてコンストラクタを使うことで作成されます。例えばnew Date(2009,11)は新しいDateオブジェクトが作成されます。newを用いずにコンストラクタを呼び出した結果がどのようになるかは、個々のコンストラクタに依存します。例えばDate()という呼びだしはオブジェクトではなく現在日時を表す文字列を返します。

コンストラクタによって作成されたすべてのオブジェクトはコンストラクタのプロトタイププロパティの値への暗黙の参照(オブジェクトのプロトタイプと呼ばれる暗黙の参照)を持ちます。更にプロトタイプ自体がそのプロトタイプに対してはNullではない暗黙の参照を持つ場合があります。そのためこのことはプロトタイプチェーンと呼ばれます。オブジェクトのプロパティへの参照が作られると、その参照はその名前のプロパティを含むプロパティチェーンにおいてその名前のプロパティを持つ最初のオブジェクトのプロパティへの参照となります。言い換えると最初にオブジェクト自身がそのプロパティを持っていることが試されます。
もしオブジェクトがその名前のプロパティを持っていれば、それが参照すべきプロパティです。
もしオブジェクトがその名前のプロパティを持っていなければ、次にオブジェクトのプロトタイプがそのプロパティを持っているかどうかが試されます。
そしてこれが繰り返されます。

クラスベースのオブジェクト指向言語では一般的に状態はインスタンスが持ち、メソッドはクラスが持ち、継承は構造と挙動だけに限定されていました。一方ECMAScriptでは、状態とメソッドはオブジェクトが持ち、構造・挙動・状態のすべてが継承されます。

図1 オブジェクト／プロトタイプの関係
                                          +-->
                                          |
                                        +-+---------+
                  +====================>| CFp       |
                  |                     |  CFP1     |
                  |   +---------------->|           |
                  |   | +-------------->|           |
                  |   | | +------------>|           |
                  |   | | | +---------->|           |
                  |   | | | | +-------->|           |
                  |   | | | | |         +-----------+
                  |   | | | | |
                  |   | | | | +-----------------------+
                  |   | | | +-----------------+       |
                  |   | | +-----------+       |       |
    +-->          |   | +-----+       |       |       |
    |             |   |       |       |       |       |
  +-+-----------+ | +-+---+ +-+---+ +-+---+ +-+---+ +-+---+
  | CF          | | | cf1 + | cf2 | | cf3 | | cf4 | | cf5 |
  |  prototype ===+ |  q1 | |  q1 | |  q1 | |  q1 | |  q1 |
  |  P1         |   |  q2 | |  q2 | |  q2 | |  q2 | |  q2 |
  |  P2         |   |     | |     | |     | |     | |     |
  +-------------+   +-----+ +-----+ +-----+ +-----+ +-----+
  ===> 明示的なプロトタイプのプロパティ
  ---> 暗黙的なプロトタイプのリンク

そのオブジェクトのプロトタイプが持つ特定のプロパティを直接持っていないすべてのオブジェクトは、そのプロパティと値を共有します。図1はこのことを図示しています。

CFはコンストラクタです(同時にオブジェクトでもあります)。new式によって5個のオブジェクトが作られます(cf1, cf2, cf3, cf4, cf5)。これらのいずれのオブジェクトもq1とq2という名前のプロパティを持っています。実線の矢印は暗黙のプロトタイプの関係性を表しています。例えばcf3のプロトタイプはCFpです。コンストラクタCFは自分自身がP1とP2という二つのプロパティを持っていますが、それらはCFp, cf1, cf2, cf3, cf4, cf5からは見えません。CFpの中のCFP1はq1, q2, CFP1という名前ではないCFpの暗黙のプロトタイプチェーンにおける何らかのプロパティであり、cf1, cf2, cf3, cf4, cf5で共有されます。CFとCFpの間に暗黙のプロトタイプのリンクがないことに注目しましょう。

クラスベースのオブジェクト指向言語とは違ってプロパティに値を代入することで動的にオブジェクトにプロパティを追加できます。つまり、コンストラトされたオブジェクトのプロパティのすべてもしくは一部に対して、必ずしも名前を付けたり値を代入したりする必要はありません。上の図では、CFpのプロパティに対して新しい値を代入することで、cf1, cf2, cf3, cf4, cf5に対して共有の新しいプロパティを追加することができます。


4.2.2 厳格なECMAScript


ECMAScriptは言語において使用できるいくつかの機能の使い方を制限したいと考えているユーザがいる可能性があることを認識しています。セキュリティの観点から、エラーが発生しやすいと彼らが考えている機能を避けるためであったり、エラーチェックを強化したりするためであったり、彼ら自身の他の理由のために、そう考えているのでしょう。この可能性をサポートするためにECMAScriptでは言語の厳格な派生を定義しています。この厳格な派生では、標準のECMAScriptのシンタックスやセマンティクスのいくつかを取り除き、いくつかの機能の詳細なセマンティクスを修正しています。この厳格な派生では標準の場合では厳密にはエラーとして指定されていない状況であっても、エラーの例外をスローして報告されなければならない追加のエラー条件を指定します。

このECMAScriptの厳格な派生はstrictモードと一般的に呼ばれています。ECMAScriptでstrictモードを選択すること、そして、strictモードのシンタックスとセマンティクスを使うことは、ECMAScriptの個々のコード単位で明示的に行われます。strictモードはシンタックス上コード単位で行われるため、strictモードではコード単位の局所的な影響範囲にだけ制限が課せられます。strictモードは複数のコード単位に渡るようなECMAScriptのセマンティクスの面からの制限を課したり修正したりすることはありません。ひとつのECMAScriptプログラムがstrictモードと標準モードのコード単位から構成される場合もあります。このような場合にはコード単位でstrictモードと定義されたコードの実行時だけstrictモードが適用されます。

この仕様に従うためにECMAScriptの実装では、完全に制限のない標準モードのECMAScriptとこの仕様で定義されているstrictモードのECMAScriptを実装する必要があります。更に制限のない標準モードのコード単位とstrictモードのコード単位をひとつのプログラムに組み合わせられるようにサポートしなければなりません。


4.3 定義


この文書のために以下の通り用語と定義を定めます。


4.3.1 型


この仕様の8節で定義されているデータの値の集合です。


4.3.2 プリミティブ値


8節で定義している、Undefined, Null, Boolean, Number, Stringのどれかの型のメンバです。

注意：プリミティブ値は言語の実装においてもっとも低レベルにおいて直接的に表現されるデータです。


4.3.3 オブジェクト


Object型のメンバです。

注意：あるオブジェクトはプロパティの集合であり、ひとつのプロトタイプオブジェクトを持ちます。プロトタイプはnull値の場合があります。


4.3.4 コンストラクタ


オブジェクトを作成し初期化するFunctionオブジェクトです。

注意：コンストラクタのプロトタイププロパティの値は継承を実装しプロパティを共有するために用いられます。


4.3.5 プロトタイプ


他のオブジェクトとプロパティを共有するためのオブジェクトです。

注意：コンストラクタがオブジェクトを作る際に、プロパティの参照を解決するために、オブジェクトはコンストラクタのプロトタイププロパティを暗黙的に参照します。コンストラクタのプロトタイププロパティは、プログラムのconstructor.prototypeという式で参照されますし、オブジェクトのプロトタイプに追加されたプロパティは、そのプロトタイプを共有するすべてのオブジェクトの継承によって共有されます。


4.3.6 ネイティブオブジェクト


ホスト環境ではなくこの仕様において意味的に完全に定義されるECMAScriptの実装上のオブジェクトです。

注意：標準のネイティブオブジェクトは、この仕様において定義されています。いくつかのネイティブオブジェクトは組み込みであり、その他はECMAScriptのプログラムの実行時に作られます。


4.3.7 組み込みオブジェクト


ホスト環境に依存しないECMAScriptの実装によって提供されるオブジェクトであり、ECMAScriptのプログラムの実行開始時点から存在します。

注意：標準組み込みオブジェクトはこの仕様で定義されています。そして、特定のECMAScriptの実装ではそれ以外のものを明示し定義しているかもしれません。すべての組み込みオブジェクトはネイティブオブジェクトです。組み込みコンストラクタは、コンストラクタである組み込みオブジェクトです。


4.3.8 ホストオブジェクト


ECMAScriptの実行環境を補完するためにホスト環境によって提供されるオブジェクトです。

注意：ネイティブオブジェクトではないすべてのオブジェクトはホストオブジェクトです。


4.3.9 undefined値


変数に値が代入されていない場合に使われるプリミティブ値です。


4.3.10 Undefined型


値がundefined値の場合の型です。


4.3.11 null値


いかなるオブジェクト値も存在しないことを表現するプリミティブ値です。


4.3.12 Null型


値がnullの場合の型です。


4.3.13 Boolean値


Boolean型のメンバです。

注意：Boolean値にはtrueとfalseという二つの値だけが存在します。


4.3.14 Boolean型


プリミティブ値であるtrueとfalseからなる型です。


4.3.15 Booleanオブジェクト


標準組み込みのBooleanコンストラクタのインスタンスであるオブジェクトのメンバです。

注意：Booleanオブジェクトは、引数としてBoolean値が与えられたnew式でBooleanコンストラクタを実行した場合に作られます。結果のオブジェクトは、Boolean値を持つ内部プロパティを持ちます。Booleanオブジェクトは強制的にBoolean値に変換されます。


4.3.16 文字列値


順序が決まっている0もしくは16ビットの符号無し整数の並びのプリミティブ値です。

注意：文字列値はString型のメンバです。並びの整数値は、UTF-16の中のひとつの16ビットの値を表します。ただし、ECMAScriptは16ビットの符合なし整数でなければならないこと以外は値に対していかなる制約も要求もしていません。


4.3.17 String型


文字列値が取りうる値の集合です。


4.3.18 Stringオブジェクト


標準組み込みのStringコンストラクタのインスタンスであるオブジェクト型のメンバです。

注意：Stringオブジェクトは、文字列値を引数として与えて、new式でStringコンストラクタを呼び出すことで作成されます。結果のオブジェクトは、文字列値を値に持つ内部的なプロパティを持ちます。Stringコンストラクタを関数として呼び出すことで、Stringオブジェクトを文字列値に強制変換することができます(15.5.1)。


4.3.19 数値


倍精度64ビットバイナリ形式IEEE 754に相当するプリミティブ値です。

注意：数値はNumber型のメンバであり、数そのものの表現です。


4.3.20 Number型


数値が取りうる値の集合です。数値には特別な、NaN、正の無限大、負の無限大が含まれます。


4.3.21 Numberオブジェクト


標準組み込みのNumberコンストラクタのインスタンスであるオブジェクトのメンバです。

注意：Numberオブジェクトは、数値を引数として与えて、new式でNumberコンストラクタを呼び出すことで作成されます。結果のオブジェクトは、値が数値である内部的なプロパティを持ちます。Numberコンストラクタを関数として呼び出すことで、Numberオブジェクトを数値に強制変換することができます(15.7.1)。


4.3.22 無限大


正の無限大である数値です。


4.3.23 NaN


IEEE 754の"Not-a-Number"値である数値です。


4.3.24 関数


標準組み込みのFunctionコンストラクタのインスタンスであり、サブルーチンとして呼び出されるオブジェクトの型のメンバです。

注意：名前付きのプロパティに加えて、関数には実行可能なコードと呼び出された時にどのように振る舞うかを決定する状態が含まれています。関数のコードはECMAScriptで書かれているかもしれませんし、そうでないかもしれません。


4.3.25 組み込み関数


関数である組み込みオブジェクトです。

注意：組み込み関数の例としてparseIntとMath.expが含まれます。実装によってはこの仕様では触れない実装に依存した組み込み関数が提供される場合があります。


4.3.26 プロパティ


オブジェクトの一部を構成する名前と値の間の関連です。

注意：プロパティの形式によっては、値はデータの値(プリミティブ値、オブジェクト、関数)として直接的に、もしくは、アクセサ関数の対によって関節的に表現されます。


4.3.27 メソッド


プロパティの値である関数です。

注意：関数がオブジェクトのメソッドとして呼ばれると、オブジェクトがthis値として関数に渡されます。


4.3.28 組み込みメソッド


組み込み関数であるメソッドです。

注意：標準組み込みメソッドはこの仕様で定義されています。ECMAScriptの実装によっては、追加の組み込みメソッドを明示し提供することもあります。


4.3.29 属性


プロパティのいくつかの特性を定義する内部的な値です。


4.3.30 固有プロパティ


オブジェクト自体に直接的に含まれるプロパティです。


4.3.31 継承したプロパティ


オブジェクトにとっては固有プロパティではないが、オブジェクトのプロトタイプでは固有プロパティもしくは継承したプロパティであるプロパティです。

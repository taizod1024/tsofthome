8 型


この仕様のアルゴリズムでは型に関連付られた値を操作します。取り得る値の型は、この節で厳密に定義されています。型はさらにECMAScript言語の型と仕様の型へとサブクラス化されています。

ECMAScript言語の型は、ECMAScript言語を使うECMAScriptのプログラマによって直接的に操作される値に相当します。ECMAScript言語の型はUndefined, Null, Boolean, String, Number, Objectです。

仕様の型は、ECMAScript言語の構造とECMAScript言語の型のセマンティクスで述べられるアルゴリズムで使われるメタな値に相当します。この仕様の型は、参照、リスト、補完、プロパティ記述子、プロパティ識別子、レキシカル環境、環境レコードです。仕様の型の値は仕様が産み出したものであり、必ずしもECMAScriptの実装における任意の特定のエンティティに対応しているとは限りません。仕様の型の値は、ECMAScriptの式の評価の中間結果を記述するために使用されますが、ECMAScript言語の変数のオブジェクトや値のプロパティとして保存することはできません。

この仕様において"Type(x)"という表記は、この節で定義されるECMAScript言語の型と仕様の型を参照するときの"xの型"という表記の短縮形です。


8.1 Undefined型


Undefined型は厳密にたったひとつの値を持ちます。undefinedと呼ばれる値です。値が代入されていない変数の値はundefinedです。


8.2 Null型


Null型は厳密にひとつの値を持ちます。nullと呼ばれる値です。


8.3 Boolean型


Boolean型は二つの値を持つ論理的なエンティティです。trueとfalseと呼ばれる二つの値です。


8.4 String型


String型は16ビットの符号無し整数値("要素")のゼロ個以上の順序が決定された並びの集合です。String型は一般的に実行中のECMAScriptプログラムでテキストデータを表現するために使われます。その場合には、文字列の中のどの要素もコード単位の値(6.)として扱われます。どの要素も並びの中である位置を占有している見なされます。これらの位置は非負の整数でインデックスされています。(もし最初の要素があれば)最初の要素は位置0です。(次の要素があれば)次の要素は位置1です。以下同じです。文字列の長さは要素の個数です(例えば、16ビットの値です)。空の文字列は長さ0であり、そのためひとつも要素を含みません。

文字列が実テキストデータが含むときは、どの要素も単一のUTF-16コード単位であると見なされます。文字列の実ストレージの形式にどうであるかに関わらず、文字列の中の文字は、UTF-16を使って表現されたかのように、コード単位の要素の初期の位置によって番号付けられます。(後で述べる場合を除きますが)文字列のすべての操作は、文字列を分離されていない16ビット符号無し整数の並びとして操作します。このことは、結果の文字列が正規化されていることを保証しませんし、言語に依存した結果を保証しません。

注意：このデザインの背景は、文字列処理の実装を可能な限りシンプルでパフォーマンスを高く保つためです。外部(例えば、ユーザの入力、ファイルからの読み込み、ネットワーク越しの受信、...)から実行環境に入ってくるテキストデータは、実行中のプログラムが参照する前にUnicode Normalised Form Cの形式に変換されるべきということを意図しています。これはテキストを受信すると同時に(追加のオーバーヘッドを課すことなしに)元々の文字エンコーディングからUnicodeへの変換されるのが普通です。ECMAScriptのソースコードはNormalized Form Cであることを勧めているため、Unicodeエスケープシーケンスがそれらに含まれていない場合には、(もしソーステキストが正規化されていることが保証されているならば)文字列リテラルもまた正規化されていることが保証されます。
【訳注】Unicode Normalized Form C：文字が合成済みとなっている形式。例えば a + umlaut → ä


8.5 Number型


Number型は厳密に18437736874454810627(=2^64-2^53+3)個の値を取ります。二進浮動小数点演算用としてIEEE標準において規定されている倍精度64ビットIEEE754形式の値で表現できる値です。IEEE標準の"Not-a-Number"を表す個々の9007199254740990(=2^53-2)個の値は、ECMAScriptの中においてNaN値という特別なひとつの値として表現されておりこれを除きます(NaN値はプログラムの式NaNによって生成されることに注意しましょう)。実装によっては、外部コードが様々なNot-a-Number値を区別して検知するかもしれませんが、そういった振る舞いは実装依存であり、ECMAScriptコードにとってはすべてのNaN値は個々に区別できません。
【訳注】IEE754-2008 64ビットバイナリ形式
------- ----------- ------  ------  ------  --------------------------------
種類                符号    指数部  仮数部  値の個数                 
                    1bit    11bit   52bit                 
------- ----------  ------  ------  ------  --------------------------------
NaN     －          任意    2047    0以外   2^1x1       x(2^52-1)=2^53-2   
無限大  －          任意    2047    0       2^1x1       x1       =2        
有限数  ゼロ        任意    0       0       2^1x1       x1       =2     
        正規化数    任意    1-2046  任意    2^1x(2^11-2)x2^52    =2^64-2^54
        非正規化数  任意    0       0以外   2^1x(2^52-1)         =2^53-2   
------- ----------  ------  ------  ------  --------------------------------
IEE754-2008 64ビットバイナリでは合計=2^64個
ECMAScriptのNumber型はNaNが2^53-2 → 1に減っているのでその分個数が異なる。

二つの特別な値があります。無限大と負の無限大と呼ばれる値です。簡単に言えば、これらの値はそれぞれ+∞と-∞というシンボルを説明する目的で参照されます。(これらの二つの無限の数値はプログラムの式+Infinity(もしくは単にInfinity)と-Infinityによって作られていることに注意しましょう。)

その他の18437736874454810624(=2^64-2^53)個の値は有限数と呼ばれます。これらの半分は正の数値で、半分は負の数値です。すべての有限の正の数値と同じ大きさの対応する負の数値があります。

正のゼロと負のゼロがあることに気をつけましょう。簡単に言えば、これらの値はそれぞれ+0と-0という二つのシンボルを説明する目的で参照されます。(二つの異なるゼロという数値はプログラムの式+0(もしくは単に0)と-0によって作られていることに注意しましょう。)

18437736874454810622(=2^64-2^53-2)個のゼロではない有限数には二つの種類があります。

それらの18428729675200069632(=2^64-2^54)個は正規化されており、以下の形式を取ります。

s * m * 2^e 

ここでsは+1もしくは-1、mは2^53より小さく2^52より小さくはない値、eは-1074から971までの値です。

残りの9007199254740990(=2^53-2)個は正規化されておらず、以下の形式を取ります。

s * m * 2^e

ここでsは+1もしくは-1、mは2^52より小さい値、eは-1074です。

絶対値が2^53より大きくはないすべての正の整数と負の整数はNumber型で表現されます。(実際に整数0は二つの表現、+0と-0で表現されます。)

有限数は、それがゼロではなく(上記の二つの形式のいずれかを)表現するのに使用している整数mが奇数であれば奇数サインを持っており、そうでなければ偶数サインを持っています。

この仕様では xがゼロではない実在の数学的な量(πのように無理数かもしれません)を表現する場合に、"xの数値"という語句は以下のやり方に従って選ばれた数値を意味します。- Number型のすべての有限数の集合を考えます。
- 集合から-0を除きます
- 集合にNumber型で表現できないことを意味する二つの値2^1024(= +1 * 2^53 * 2^971)と-2^1024(= -1 * 2^53 * 2^971)を追加します。
- 集合からxに最も近い要素を選びます。もし二つの値がxと全く同じだけ近かったら、偶数サインを持っている側が選ばれます。この目的のために二つの追加の値2^1024と-2^1024は偶数サインを持っていると見なします。
- 最終的に...
  - +2^1024が選ばれたならば、それを+∞に置き換えます。
  - -2^1024が選ばれたならば、それを-∞に置き換えます。
  - もし+0が選ばれたならば、ｘが0より小さいときだけ-0に置き換えます。
  - その他の値は変更しないまま使われます。
この結果がxの数値になります。(この手続きはIEEE754の最近接丸め(偶数)モードの振る舞いに厳密に相当します。)

いくつかのECMAScriptにおける操作では、-2^31から2^31-1までの整数の範囲、もしくは、0から2^32-1までの整数の範囲だけを扱います。これらの操作はNumber型のいかなる値も受け付けますが、最初にそれぞれの値を2^32個の整数値のいずれかに変換してから行います。それぞれ9.5および9.6のToInt32およびToUint32演算の記述を見てください。


8.6 オブジェクト型


オブジェクトはプロパティのコレクションです。プロパティは、名前付きのデータプロパティか、名前付きのアクセサプロパティか、内部プロパティのいずれかです。

- 名前付きのデータプロパティは、名前とECMAScript言語の値およびBoolean型の属性の集合を関連付けています。
- 名前付きのアクセサプロパティは、名前とひとつもしくは二つのアクセサ関数およびBoolean型の属性の集合を関連付けています。アクセサ関数はプロパティに関連付けられたECMAScript言語の値の格納もしくは取得するために使われます。
- 内部プロパティは名前を持ちません、ECMAScript言語の操作からは直接はアクセスすることはできません。内部プロパティは純粋に仕様上の目的のために存在します。

名前付きの(非内部な)プロパティへのアクセス方法には二種類あります。getとputです。これらはそれぞれ取得と代入に相当します。


8.6.1 プロパティの属性


この仕様において属性は名前付きプロパティの状態を定義し説明するために使用されています。名前付きデータプロパティは名前と表5で示されている属性を関連付けます。

表5 - 名前付きデータプロパティの属性
--------------------------------------------------------------------------------
属性名
値のドメイン
内容
--------------------------------------------------------------------------------
[[Value]]
型すべて
読み込みプロパティによって取得された値です。
--------------------------------------------------------------------------------
[[Writable]]
Boolean
もしfalseならば[[Put]]によるプロパティの変更コードは失敗します。
--------------------------------------------------------------------------------
[[Enumerable]]
Boolean
もしtrueならば、for-in列挙(12.6.4)ができ、そうでなれければ列挙できないと言います。
--------------------------------------------------------------------------------
[[Configurable]]
Boolean
もしfalseならば、プロパティの削除、プロパティのアクセサプロパティへの変更、([[Value]]ではなく)属性の変更は失敗します。
--------------------------------------------------------------------------------

名前付きアクセサプロパティは表6で示されている属性と関連付けます。

表6 - 名前付きアクセサデータプロパティの属性
--------------------------------------------------------------------------------
属性名
値のドメイン
内容
--------------------------------------------------------------------------------
[[Get]]
Object or Undefined
もし値がオブジェクトならば関数オブジェクトです。プロパティのgetアクセスが行われた場合には、関数の[[Call]]内部メソッド(8.6.2)が空の引数リストで呼び出され、プロパティの値を返します。
--------------------------------------------------------------------------------
[[Set]]
Object or Undefined
もし値がオブジェクトならば関数オブジェクトです。プロパティのSetアクセスが行われた場合には、関数の[[Call]]内部メソッド(8.6.2)が代入する値のひとつの引数リストで呼び出されます。プロパティの[[Set]]内部メソッドの影響は、必須ではありませんが、それに連なるプロパティの[[Get]]内部メソッドによって返される値に影響を与えます。
--------------------------------------------------------------------------------
[[Enumerable]]
Boolean
もしtrueならばfor-in列挙(12.6.4)ができ、そうでなれければ列挙できないと言います。
--------------------------------------------------------------------------------
[[Configurable]]
Boolean
もしfalseならばプロパティの削除および変更、属性の変更は失敗します。
--------------------------------------------------------------------------------

もし名前付きプロパティに関する仕様において属性の値が明示的に示されていない場合は、表7で定義されている初期値が使われます。

表7 - 属性の初期値
------------------- -----------------------------------------------------------
属性名              初期値
------------------- -----------------------------------------------------------
[[Value]]           undefined 
[[Get]]             undefined 
[[Set]]             undefined 
[[Writable]]        false 
[[Enumerable]]      false 
[[Configurable]]    false 
------------------- -----------------------------------------------------------


8.6.2 オブジェクトの内部プロパティとメソッド


この仕様ではオブジェクトの値の意味を定義するために様々な内部プロパティを使用します。これらの内部プロパティはECMAScript言語の一部ではありません。それらは説明する目的のためにこの仕様によって定義されています。ECMAScriptの実装はここで述べられている作法に従って内部プロパティを作りだし操作しているかのごとく振る舞わなければいけません。内部プロパティの名前は二重大括弧[[ ]]で括られています。アルゴリズムがオブジェクトの内部プロパティを使用して、オブジェクトがその内部プロパティを実装していない場合には、TypeError例外がスローされます。

表8は、この仕様によって使われているすべてのECMAScriptのオブジェクトへ適用可能な内部プロパティのサマリです。テーブル９は、この仕様によって使われているいくつかのECMAScriptオブジェクトへのみ適用可能な内部プロパティのサマリです。これらのテーブルの記述は、改めてこの文書において特定の種類のネイティブなECMAScriptなオブジェクトについて述べていない限りは、そのオブジェクトの振る舞いを示しています。この文書で述べられている特定のホストオブジェクトの制限において一貫性を保っている限りは、いくらかは実装依存の振る舞いをしながらも、ホストオブジェクトはこれらの内部プロパティをサポートします。

以降の表の"値の型のドメイン"列は内部プロパティに関連した値の型を定義しています。型の名前は、以下の追加の名前によって8節の拡張で定義した型を参照します。
- "any"は、ECMAScript言語の型のどれかであることを意味します。
- "primitive"は、Undefined, Null, Boolean, String, Numberのどれかであることを意味します。
- "SpecOp"は、内部プロパティが内部メソッドの抽象操作の仕様で定義された手続きを提供していることを意味します。"SpecOp"には説明的なパラメタの名前のリストが続きます。パラメタ名が型名と同じならば、名前はパラメタの型を述べています。もし"SpecOp"が値を返すのであれば、そのパラメタリストには"→"と返される値の型が続きます。

表8 - すべてのオブジェクトに共通の内部プロパティ
--------------------------------------------------------------------------------
内部プロパティ
値の型のドメイン
内容
--------------------------------------------------------------------------------
[[Prototype]]
Object or Null
オブジェクトのプロトタイプです。
--------------------------------------------------------------------------------
[[Class]]
String
オブジェクトのクラス定義を示す文字列です。
--------------------------------------------------------------------------------
[[Extensible]]
Boolean
もしtrueならば、固有プロパティがオブジェクトに追加されているかもしれません。
--------------------------------------------------------------------------------
[[Get]]
SpecOp(propertyName) → any
名前付きプロパティの値を返します。
--------------------------------------------------------------------------------
[[GetOwnProperty]]
SpecOp (propertyName) → Undefined or Property Descriptor
このオブジェクトの名前付き固有プロパティのプロパティ記述子を返します。オブジェクト固有のものがなければundefinedを返します。
--------------------------------------------------------------------------------
[[GetProperty]]
SpecOp(propertyName) → Undefined or Property Descriptor
このオブジェクトの完全実装された名前付きプロパティのプロパティ記述子を返します。プロパティがなければundefinedを返します。
--------------------------------------------------------------------------------
[[Put]]
SpecOp(propertyName, any, Boolean)
指定された名前付きプロパティを第二引数の値に設定します。フラグで設定失敗時の処理を制御します。
--------------------------------------------------------------------------------
[[CanPut]]
SpecOp(propertyName) → Boolean
PropertyNameで[[Put]]の操作が実施できるかどうかを示すBoolean値を返します。
--------------------------------------------------------------------------------
[[HasProperty]]
SpecOp(propertyName) → Boolean
与えられた名前のプロパティをオブジェクトが既に持っているかどうかを示すBoolean値を返します。
--------------------------------------------------------------------------------
[[Delete]]
SpecOp(propertyName, Boolean) → Boolean
オブジェクトから与えられた名前の固有プロパティを削除します。フラグで削除失敗時の処理を制御します。
--------------------------------------------------------------------------------
[[DefaultValue]]
SpecOp(Hint) → primitive
ヒントは文字列です。オブジェクトの初期値を返します。
--------------------------------------------------------------------------------
[[DefineOwnProperty]]
SpecOp (propertyName, PropertyDescriptor, Boolean) → Boolean
プロパティ記述子によって述べられた状態を名前付きの固有プロパティが持つように作成もしくは変更します。フラグで作成変更失敗時の処理を制御します。
--------------------------------------------------------------------------------

(ホストオブジェクトを含む)すべてのオブジェクトは表8で示された内部プロパティのすべてを実装しなければいけません。ただし、いくつかのオブジェクトにとっては、[[DefaultValue]]内部メソッドは単にTypeErrorをスローするだけでしょう。

すべてのオブジェクトは[[Prototype]]と呼ばれる内部プロパティを持っています。このプロパティの値はnullもしくはあるオブジェクトであり、継承を実装するために使用されます。ネイティブオブジェクトがホストオブジェクトを[[Prototype]]として持てるかどうかは実装に掛かっています。すべての[[Prototype]]チェーンは有限の長さです(つまり、あるオブジェクトから始まる[[Prototype]]内部プロパティの再帰的な参照は、最終的にはnull値へと通じなければいけません)。[[Prototype]]オブジェクトの名前付けされたデータプロパティは、参照のために継承される(子供のオブジェクトのプロパティとして見える)のであり、更新のためではありません。名前付きアクセサプロパティは参照と更新の両方のために継承されます。

すべてのECMAScriptオブジェクトも、オブジェクトに名前付きプロパティを追加できるかどうかを制御するBoolean値の[[Extensible]]内部プロパティを持っています。もし[[Extensible]]内部プロパティの値がfalseの場合、オブジェクトには追加の名前付きプロパティを追加することはできません。更に、もし[[Extensible]]がfalseならば、オブジェクトの[[Class]]および[[Prototype]]内部プロパティは変更できません。一旦、[[Extensible]]内部プロパティの値をfalseに設定したら、後でtrueに変更することはできません。

注意：この仕様は、オブジェクトの[[Class]]および[[Prototype]]内部プロパティを変更したり、[[Extensible]]の値をfalseからtrueへ変更するようにプログラムすることができるECMAScriptの演算子や組み込み関数が存在しないことを定義しています。

[[Class]]、[[Prototype]]、[[Extensible]]を変更するような実装に依存した拡張は、前の段落で定義された不変性に違反してはいけません。

すべての組み込みオブジェクトの[[Class]]内部プロパティの値は、この仕様で定義されています。ホストオブジェクトの[[Class]]内部プロパティの値は、以下のもの以外の何らかの文字列です。
- "Arguments"
- "Array"
- "Boolean"
- "Date"
- "Error"
- "Function"
- "JSON"
- "Math"
- "Number"
- "Object"
- "RegExp"
- "String"
[[Class]]内部プロパティの値は、内部的にオブジェクトの種類を区別するために使用されます。この仕様は、Obuject.prototype.toString(15.2.4.2)を除いて、この値にアクセスするプログラムにとっては何の意味も持たない点に注意してください。

他に示されない限り、ネイティブなECMAScriptのオブジェクトの共通の内部メソッドは、8.12で述べられているように振る舞います。Arrayオブジェクトは[[DefineOwnProperty]]内部メソッド(15.4.5.1)とは少し異なる実装ですし、Stringオブジェクトは[[GetOwnProperty]]内部メソッド(15.5.5.2)とは少し異なります。Argumentsオブジェクト(10.6)は[[Get]]、[[GetOwnProperty]]、[[DefineOwnProperty]]、[[Delete]]とは異なります。Functionオブジェクト(15.3)も[[Get]]とは異なります。

他に示されていなければ、ホストオブジェクトはこれらの内部メソッドをどんな方法でも実装するでしょう。例えば、ひとつの可能性として、あるホストオブジェクトについて[[Get]]と[[Put]]は実際にプロパティをfetchしstoreしますが、[[HasProperty]]についてはいつもfalseを返すかもしれません。しかし、もしホストオブジェクトの内部プロパティで示された操作が実装でサポートされていなければ、その操作が試みられた時はTypeErrorをスローしなければなりません。

ホストオブジェクトの[[GetOwnProperty]]内部メソッドは、ホストオブジェクトのどのプロパティについても以下の不変性を満たさなければなりません。

- もしプロパティがデータプロパティであり、時に応じて異なる値を返すのであれば、値を変更する仕組みが他の内部メソッドを通して用意されていない限り[[Writable]]と[[Configurable]]属性のどちらか、または、両方はtrueでなければなりません。
- もしプロパティかデータプロパティであり、[[Writable]]と[[Configurable]]が両方ともfalseならば、[[GetOwnProperty]]のすべての呼び出しにおいてプロパティの[[Value]]属性としてSameValue(9.12)が返されなければなりません。
- もし[[Writable]]以外の属性が時とともに変化したり、プロパティが無くなったりするのであれば、[[Configurable]]属性はtrueでなければなりません。
- もし[[Writable]]属性がfalseからtrueに変化するのであれば、[[Configurable]]はtrueでなければなりません。
- もしホストオブジェクトの[[Extensible]]内部プロパティの値がECMAScriptのコードによってfalseになることがあり、[[GetOwnProperty]]の呼び出し結果でプロパティが存在しないとされたならば、以降の呼び出しでもプロパティが存在しないとされなければなりません。

ホストオブジェクトの[[DefineOwnProperty]]内部メソッドは、ホストオブジェクトの[[Extensible]]内部プロパティがECMAScriptのコードによってfalseになることがあれば、ホストオブジェクトに新しいプロパティの追加を許してはいけません。

もしホストオブジェクトのコードに[[Extensible]]内部プロパティがECMAScriptのコードによってfalseになることがあれば、それ以降trueになることはできません。

表9 - 特定のオブジェクトでだけ定義されている内部プロパティ
--------------------------------------------------------------------------------
内部プロパティ
値の型のドメイン
内容
--------------------------------------------------------------------------------
[[PrimitiveValue]]
primitive
オブジェクトに関連した内部状態の情報です。標準の組み込みECMAScriptのオブジェクトのBoolean, Date, Number, Stringオブジェクトが[[PrimitiveValue]]を実装しています。
--------------------------------------------------------------------------------
[[Construct]]
SpecOp(a List of any) → Object 
オブジェクトを作成します。new演算子を通して呼び出されます。SpecOp引数にはnew演算子へ渡される引数です。この内部メソッドを実装するオブジェクトはコンストラクタと呼ばれます。
--------------------------------------------------------------------------------
[[Call]]
SpecOp(any, a List of any) → any or Reference 
オブジェクトに関連した実行コードです。call式を通して呼び出されます。SpecOp引数はこのオブジェクトと関数呼び出しの式へ渡される引数が含まれたリストです。この内部メソッドを実装したオブジェクトは呼び出し可能と呼ばれます。ホストオブジェクトである呼び出し可能なオブジェクトは参照値を返します。
--------------------------------------------------------------------------------
[[HasInstance]]
SpecOp(any) → Boolean 
引数がこのオブジェクトによって作成されたオブジェクトであるかどうかを示すBoolean値を返します。標準の組み込みECMAScriptオブジェクトのFunctionオブジェクトだけが[[HasInstance]]を実装しています。
--------------------------------------------------------------------------------
[[Scope]]
Lexical Environment
Functionオブジェクトが実行される環境を定義するレキシカル環境です。標準の組み込みECMAScriptオブジェクトのFunctionオブジェクトだけが[[Scope]]を実装しています。
--------------------------------------------------------------------------------
[[FormalParameters]]
List of Strings
関数のFormalParameterListの識別子の文字列を含む空であることも可能なリストです。標準の組み込みECMAScriptオブジェクトのFunctionオブジェクトだけが[[FormalParameterList]]を実装しています。
--------------------------------------------------------------------------------
[[Code]]
ECMAScript code
関数のECMAScriptコードです。標準の組み込みECMAScriptオブジェクトのFunctionオブジェクトだけが[[Code]]を実装しています。
--------------------------------------------------------------------------------
[[TargetFunction]]
Object
標準の組み込みのFunction.prototype.bindメソッドを使って作られた関数オブジェクトの対象の関数です。Function.prototype.bindを使って作られたECMAScriptオブジェクトだけが[[TargetFunction]]内部プロパティを持っています。
--------------------------------------------------------------------------------
[[BoundThis]]
any 
標準の組み込みのFunction.prototype.bindメソッドを使って作られた関数オブジェクトの前に設定されていた値です。
--------------------------------------------------------------------------------
[[BoundArguments]]
List of any 
標準の組み込みのFunction.prototype.bindメソッドを使って作られた関数オブジェクトの前に設定されていた引数の値です。Function.prototype.bindを使って作られたECMAScriptオブジェクトだけが[[BoundArguments]]内部プロパティを持っています。
--------------------------------------------------------------------------------
[[Match]]
SpecOp(String, index) → MatchResult 
正規表現のマッチをテストし、MatchResultの値(15.10.2.1)を返します。標準の組み込みのECMAScriptオブジェクトのRegExpオブジェクトだけが[[Match]]を実装しています。
--------------------------------------------------------------------------------
[[ParameterMap]]
Object
引数オブジェクト(10.6)のプロパティと関連付けられた関数の仮引数とのマッピングです。引数オブジェクトであるECMAScriptオブジェクトだけが[[ParameterMap]]内部プロパティを持ちます。
--------------------------------------------------------------------------------


8.7 参照型


参照型は、delete、typeof、代入演算子といった演算子の振る舞いを説明するために使われます。例えば、代入演算子の左辺のオペランドでは参照を生成することが期待されています。代入の振る舞いは代入演算子の左辺のオペランドの構文形式をケース分析することによって完全に説明することもできますが、ひとつ難しいことがあります。参照を返す関数呼び出しが許されていることです。この可能性は純粋にホスオブジェクトのために認められています。この仕様では参照を返すような組み込みECMAScript関数は定義されていませんし、ユーザ定義関数が必ず参照を返すという決まりはありません(これ以外に構文のケース分析を使わない理由は、仕様の多くの箇所に長ったらしく無様な影響を与えるためです)。

参照は名前のバインディングで解決されます。参照は3つのコンポーネント、既定値、被参照名、boolean値であるstrict参照フラグから構成されます。既定値は、undefined、オブジェクト、Boolean、文字列、数値もしくは環境レコードのいずれかです。既定値がundefinedであることは参照がバインディングで解決されないことを示しています。参照名は文字列です。以下の抽象操作はこの仕様において参照のコンポーネントにアクセスするために使われます。

- GetBase(V) 参照Vの規定値コンポーネントを返します。
- GetReferencedName(V) 参照Vの参照名コンポーネントを返します。
- IsStrictReference(V) 参照Vのstrict参照コンポーネントを返します。
- HasPrimitiveBase(V) 規定値がBoolean, String, Numberならばtrueを返します。
- IsPropertyReference(V) 規定値がオブジェクトもしくはHasPrimitiveBase(V)がtrueならtrueを返します。それ以外はfalseを返します。
- IsUnresolvableReference(V) 規定値がundefinedならばtrueを返します。それ以外はfalseを返します。
【訳注】抽象操作とコンポーネント
--------------------------- -------------------------
抽象操作                    コンポーネント
--------------------------- -------------------------
GetBase(V)                  the base value
GetReferencedName(V)        the referenced name
IsStrictReference(V)        the strict reference flag
--------------------------- -------------------------
【訳注】抽象操作と規定値
--------------------------- ---------------------------------------
抽象操作                    規定値
                            ----------- ------- ------- -----------
                            undefined   object  boolean environment
                                                string
                                                number
--------------------------- ----------- ------- ------- ------------
IsUnresolvableReference(V)  true        false  false    false
IsPropertyReference(V)      false       true   true     false
HasPrimitiveBase(V)         false       false  true     false
--------------------------- ----------- ------- ------- ------------

この仕様において、以下の抽象操作は参照を操作するために使われます。


8.7.1 GetValue ( V )


1. Type(V)が参照でなければ、Vそのものを返します。
2. GetBase(V)の呼び出し結果をbaseとします。
3. もしIsUnresolvableReference(V)ならば、ReferenceErrorをスローします。
4. もしIsPropertyReference(V)ならば...
  a. もしHasPrimitiveBase(V)がfalseならば、getをbaseの[[Get]]内部メソッドにします。そうでなければ、getは以下で定義する特別な[[Get]]内部メソッドにします。
  b. this値としてbaseを使いget内部メソッドを呼び出した結果を返します。引数としてGetReferencedName(V)を渡します。
5. そうでなければ、baseは環境レコードである筈です。
  a. 引数としてGetReferencedName(V)とIsStrictReference(V)を与えたbaseのGetBindingValue(10.2.1)の具象メソッドの呼び出しの結果を返します。

以下の[[Get]]内部メソッドは、Vがプリミティブ値であるプロパティへの参照である場合にGetValueによって使われます。this値としてbaseを使い、プロパティPを引数として呼び出されます。以下のステップで行われます。

1. ToObject(base)の呼び出し結果をOとします。
2. 名前がPであるプロパティを引数としてOの[[GetProperty]]内部メソッドの呼び出し結果をdescとします。
3. もしdescがundefinedならば、undefinedを返します。
4. もしIsDataDescriptor(desc)がtrueならば、desc.[[Value]]を返します。
5. そうでなければ、IsAccessorDescriptor(desc)はtrudeでなければなりません。desc.[[Get]]をgetterにします。
6. もしgetterがundefinedならば、undefinedを返します。
7. this値としてbaseを使い、引数無しでgetterの[[Call]]内部メソッドを呼び出した結果を返します。

注意：ステップ１で作られたオブジェクトは上記のメソッドの外部からはアクセスすることはできません。実装によっては実際のオブジェクトの生成はしないようにしているかもしれません。この内部メソッドを使った実際のプロパティへのアクセスが目に見える影響を与える状況というのは、アクセサ関数を呼び出すときだけです。


8.7.2 PutValue ( V, W )


1. Type(V)が参照でなければ、ReferenceErrorをスローします。
2. GetBase(V)の呼び出し結果をbaseとします。
3. もしIsUnresolvableReference(V)ならば...
  a. もしIsStrictReference(V)がtrueならば...
    i. ReferenceErrorをスローします。
  b. そうでなければ、this値としてbase、プロパティ名としてGetReferencedName(V)、値としてW、Throwフラグとしてfalseを使って、Globalオブジェクトの[[Put]]内部メソッドを呼び出します。
4. そうでなくIsPropertyReference(V)ならば...
  a. もしHasPrimitiveBase(V)がfalseならば、putをbaseの[[Put]]内部メソッドにします。そうでなければ、putは以下で定義する特別な[[Put]]内部メソッドにします。
  b. this値としてbase、プロパティ名としてGetReferencedName(V)、値としてW、Throwフラグとしてfalseを使って、put内部メソッドを呼び出します。
5. そうでなければ、baseが環境レコードである参照である筈です。ならば...
  a. GetReferencedName(V), W, IsStrictReference(V)を引数として、baseのSetMutableBinding(10.2.1)具象メソッドを呼び出します。

以下の[[Put]]内部メソッドはVがプリミティブ型の既定値であるプロパティ参照である場合にPutValueによって使われます。this値としてbase、引数としてプロパティP、値W、BooleanフラグのThrowを使って呼び出されます。以下のステップで行われます。

1. ToObject(base)の呼び出し結果をOとします。
2. もしOの[[CanPut]]内部メソッドを引数Pで呼び出した結果がfalseならば...
  a. もしThrowがtrueならば、TypeErrorをスローします。
  b. そうでなければ、そのまま終わります。
3. Oの[[GetOwnProperty]]内部メソッドを引数Pで呼び出した結果をownDescとします。
4. もしIsDataDescriptor(ownDesc)がtrueならば...
  a. もしThrowがtrueならば、TypeErrorをスローします。
  b. そうでなければ、そのまま終わります。
5. Oの[[GetProperty]]内部メソッドを引数Pで呼び出した結果をdescとします。これはそれ固有プロパティか、継承されたアクセサプロパティ記述子か、継承されたデータプロパティ記述子のいずれかになります。
6. もしIsAccessorDescriptor(desc)がtrueならば...
  a  undefinedではない筈のdesc.[[Set]]をsettterとします。
  b. this値としてbase、引数リストにはWだけを含むようにして、setterの[[Call]]内部メソッドを呼び出します。
7. そうでなければ、一時オブジェクトにおける固有プロパティを作成するための要求です。
  a もしThrowがtrueならば、TypeErrorをスローします。
8. 終わります。

注意：ステップ１で作られたオブジェクトは上記のメソッドの外部からはアクセスすることはできません。実装によっては実際の一時オブジェクトの生成はしないようにしているかもしれません。この内部メソッドを使った実際のプロパティへのアクセスが目に見える影響を与える状況というのは、アクセサ関数を呼び出すときだけ、もしくは、エラーチェックを前提としたThrowの違反があったときだけです。Throwがtrueならば、一時オブジェクトにおける新しいプロパティの作成によるプロパティの代入はエラーをスローします。


8.8 リスト型


リスト型は、new式、関数呼び出し、値の単純なリストが必要なその他のアルゴリズムでにおいて引数リスト(11.2.4)を評価方法を説明するときに使われます。リスト型の値は、単純に順序付けた値の並びです。これらの並びはどんな長さにもなります。


8.9 補完型


補完型は制御の非局所的な転送を行うようなステートメント(break, continue, return, throw)の振る舞いを説明するのに使われます。補完型の値は(型、値、対象)という形式の三項組となります。型はnormal, break, continue, return, throwのいずれかであり、値はECMAScript言語の値もしくは空であり、対象はECMAScriptの識別子もしくは空です。

"不測の補完"という用語は、normal以外の型による補完を指し示します。


8.10 プロパティ記述子型とプロパティ識別子型


プロパティ記述子型は、名前付きプロパティの属性の操作と具体化を説明するのに使われます。プロパティ記述子型の値は、8.6.1で示された属性の名前のフィールド名と、属性の値に相当するフィールド値から構成されるレコードです。また、いずれかのフィールドが抜けていることがあります。

更に、プロパティ記述子型の値は特定のフィールドの有無や使い方によって、データプロパティ記述子とアクセサプロパティ記述子に分類されます。データプロパティ記述子は、[[Value]]もしくは[[Writable]]という名前のフィールドを含むものです。アクセサプロパティ記述子は[[Get]]もしくは[[Set]]という名前のフィールドを持つものです。どのプロパティ記述子も[[Enumerable]]や[[Configurable]]という名前を付けられたフィールドを持ち得ます。プロパティ記述子型の値は、データプロパティ記述子とアクセサプロパティ記述子の両方ではありません。しかしながら、どちらもでもないでしょう。ジェネリックなプロパティ記述子型の値は、データプロパティ記述子でもアクセサプロパティ記述子でもありません。完全実装されたプロパテ記述子はアクセサプロパティ記述子もしくはデータプロパティ記述子であり、8.6.1の表5もしくは表6のどちらかで定義されたプロパティ属性に相当するすべてのフィールドを持っています。

この仕様の表記の都合上、プロパティ記述子の値を定義するのにオブジェクトのリテラル表現が用いられています。例えば、プロパティ記述子 {[[Value]]: 42, [[Writable]]: false, [[Configurable]]: true } はデータプロパティ記述子を定義しています。フィールド名の順番は重要ではありません。明示的にリストされていないフィールドはすべて抜けていると見なされます。

仕様上のテキストとアルゴリズムにおいて、ドット記法はプロパティ記述子の特定のフィールドを参照するのに用いられます。例えば、Dがプロパティ記述子ならば、D.[[Value]]は"Dの[[Value]]と名前付けられたフィールド"の簡易表記です。

プロパティ識別子型はプロパティ記述子にプロパティ名を関連付けるのに用いられます。プロパティ識別子型の値は(名前、記述子)という二項組になります。名前は文字列、記述子はプロパティ記述子型の値です。

この仕様において、以下の抽象操作はプロパティ記述子型の値を操作するために使われます。


8.10.1 IsAccessorDescriptor ( Desc )


抽象操作IsAccessorDescriptorがプロパティ記述子Descを伴って呼び出された場合には、以下のステップで行われます。

1. もしDescがundefinedならば、falseを返します。
2. もしDesc.[[Get]]もDesc.[[Set]]も存在しなかったら、falseを返します。
3. trueを返します。


8.10.2 IsDataDescriptor ( Desc )


抽象操作IsDataDescriptorがプロパティ記述子Descを伴って呼び出された場合には、以下のステップで行われます。

1. もしDescがundefinedならば、falseを返します。
2. もしDesc.[[Value]]もDesc.[[Writable]]も存在しなかったら、falseを返します。
3. trueを返します。


8.10.3 IsGenericDescriptor ( Desc )


抽象操作IsGenericDescriptorがプロパティ記述子Descを伴って呼び出された場合には、以下のステップで行われます。

1. もしDescがundefinedならば、falseを返します。
2. もしIsAccessorDescriptor(Desc)もIsDataDescriptor(Desc)もfalseならば、trueを返します。
3. falseを返します。


8.10.4 FromPropertyDescriptor ( Desc )


抽象操作FromPropertyDescriptorがプロパティ記述子Descを伴って呼び出された場合には、以下のステップで行われます。

以下のアルゴリズムは、[[GetOwnProperty]](8.12.1)から返された値のように、Descが完全実装されたプロパティ記述子であることを仮定しています。

1. もしDescがundefinedならば、undefinedを返します。
2. Objectがその名前を持つ標準の組み込みのコンストラクタであり、new Object()という式に作られたかのようにして、新しいオブジェクトを作った結果をobjとします。
3. もしIsDataDescriptor(Desc)がtrueならば...
  a. objの[[DefineOwnProperty]]内部メソッドを、
    プロパティ名を"value"、
    プロパティ記述子を
    {
      [[Value]]: Desc.[[Value]], 
      [[Writable]]: true,
      [[Enumerable]]: true,
      [[Configurable]]: true
    }、
    作成失敗時フラグをfalseで呼び出します。
  b. objの[[DefineOwnProperty]]内部メソッドを、
    プロパティ名を"writable"、
    プロパティ記述子を
    {
      [[Value]]: Desc.[[Writable]],
      [[Writable]]: true,
      [[Enumerable]]: true,
      [[Configurable]]: true
    }、
    作成失敗時フラグをfalseで呼び出します。
4.そうでなければ、IsAccessorDescriptor(Desc)はtrueであるので...
  a. objの[[DefineOwnProperty]]内部メソッドを、
    プロパティ名を"get"、
    プロパティ記述子を
    {
      [[Value]]: Desc.[[Writable]],
      [[Writable]]: true,
      [[Enumerable]]: true,
      [[Configurable]]: true
    }、
    作成失敗時フラグをfalseで呼び出します。
  b. objの[[DefineOwnProperty]]内部メソッドを、
    プロパティ名を"set"、
    プロパティ記述子を
    {
      [[Value]]: Desc.[[Set]],
      [[Writable]]: true,
      [[Enumerable]]: true,
      [[Configurable]]: true
    }、
    作成失敗時フラグをfalseで呼び出します。
5. objの[[DefineOwnProperty]]内部メソッドを、
    プロパティ名を"enumerable"、
    プロパティ記述子を
    {
      [[Value]]: Desc.[[Enumerable]],
      [[Writable]]: true,
      [[Enumerable]]: true,
      [[Configurable]]: true
    }、
    作成失敗時フラグをfalseで呼び出します。
6. objの[[DefineOwnProperty]]内部メソッドを、
   プロパティ名を"configurable"、
    プロパティ記述子を
    {
      [[Value]]: Desc.[[Enumerable]],
      [[Writable]]: true,
      [[Enumerable]]: true,
      [[Configurable]]: true
    }、
    作成失敗時フラグをfalseで呼び出します。
7. objを返します。


8.10.5 ToPropertyDescriptor ( Obj )


抽象操作ToPropertyDescriptorがオブジェクトDescで呼び出された場合には、以下のステップで行われます。

1. もしType(Obj)がObjectでなければ、TypeErrorをスローします。
2. フィールドを持たない新しいプロパティ記述子を作った結果をdescとします。
3. もしObjの[[HasProperty]]内部メソッドを引数"enumerable"で呼び出した結果がtrueの場合には...
  a. Objの[[Get]]内部メソッドを引数"enumerable"で呼び出した結果をenumとします。
  b. descの[[Enumerable]]フィールドをToBoolean(enum)とします。
4. もしObjの[[HasProperty]]内部メソッドを引数"configurable"で呼び出した結果がtrueの場合には...
  a. Objの[[Get]]内部メソッドを引数"configurable"で呼び出した結果をconfとします。
  b. descの[[Configurable]]フィールドをToBoolean(conf)とします。
5. もしObjの[[HasProperty]]内部メソッドを引数"value"で呼び出した結果がtrueの場合には...
  a. Objの[[Get]]内部メソッドを引数"value"で呼び出した結果をvalueとします。
  b. descの[[Value]]フィールドをvalueとします。
6. もしObjの[[HasProperty]]内部メソッドを引数"writable"で呼び出した結果がtrueの場合には...
  a. Objの[[Get]]内部メソッドを引数"writable"で呼び出した結果をwritableとします。
  b. descの[[Writable]]フィールドをToBoolean(writable)とします。
7. もしObjの[[HasProperty]]内部メソッドを引数"get"で呼び出した結果がtrueの場合には...
  a. Objの[[Get]]内部メソッドを引数"get"で呼び出した結果をgetterとします。
  b. もしIsCallable(getter)がfalseならば、getterはundefinedとし、TypeErrorをスローします。
  c. descの[[Get]]フィールドをgetterとします。
8. もしObjの[[HasProperty]]内部メソッドを引数"set"で呼び出した結果がtrueの場合には...
  a. Objの[[Get]]内部メソッドを引数"set"で呼び出した結果をsetterとします。
  b. もしIsCallable(setter)がfalseならば、setterはundefinedとし、TypeErrorをスローします。
  c. descの[[Set]]フィールドをsetterとします。
9. もしdesc.[[Get]]もしくはdesc.[[Set]]が存在した場合には...
  a. もしdesc.[[Value]]もしくはdesc.[[Writable]]が存在したら、TypeErrorをスローします。
10. descを返します。


8.11 レキシカル環境と環境レコード型


レキシカル環境と環境レコード型は入れ子になった関数とブロックにおける名前解決の振る舞いを説明するのに用いられます。これらの方は10節で定義されています。


8.12 オブジェクトの内部メソッドのアルゴリズム


以降のアルゴリズムの説明において、OはネイティブなECMAScriptのオブジェクト、Pは文字列、Descはプロパティ記述レコード、ThrowはBoolean型の値とします。


8.12.1 [[GetOwnProperty]] ( P )


Oの[[GetOwnProperty]]内部メソッドがプロパティ名Pで呼び出された場合には、以下のステップで行われます。

1. もしOが固有プロパティPを持っていないならば、undefinedが返されます。
2. フィールドを持たない新しいプロパティ記述子を作りDとします。
3. OのPという名前の固有プロパティをDとします。
4. もしXがデータプロパティならば...
  a. D.[[Value]]をXの[[Value]]属性の値に設定します。
  b. D.[[Writable]]をXの[[Writable]属性の値に設定します。
5. そうでなければ、Xはアクセサプロパティなので...
  a. D.[[Get]]をXの[[Get]]属性の値に設定します。
  b. D.[[Set]]をXの[[Set]]属性の値に設定します。
6. D.[[Enumerable]]をXの[[Enumerable]]属性の値に設定します。
7. D.[[Configurable]]をXの[[Configurable]]属性の値に設定します。
8. Dを返します。

ただし、もしOがStringオブジェクトならば、15.5.5.2で定義されるより複雑な[[GetOwnProperty]]内部メソッドになります。


8.12.2 [[GetProperty]] ( P )


Oの[[GetProperty]]内部メソッドがプロパティ名Pで呼び出された場合には、以下のステップで行われます。

1. Oの[[GetOwnProperty]]内部メソッドをプロパティ名Pで呼び出した結果をpropとします。
2. もしpropがundefined以外ならば、propを返します。
3. Oの[[Prototype]]内部プロパティの値をprotoとします。
4. もしprotoがnullならば、undefinedを返します。
5. protpの[[GetProperty]]内部メソッドを引数Pで呼び出した結果を返します。


8.12.3 [[Get]] ( P )


Oの[[Get]]内部メソッドがプロパティ名Pで呼び出された場合には、以下のステップで行われます。

8. Oの[[GetProperty]]内部メソッドをプロパティ名Pで呼び出した結果をdescとします。
9 もしdescがundefinedならば、undefinedを返します。
10. もしIsDataDescriptor(desc)がtrueならば、desc.[[Value]]を返します。
11. そうでなければ、IsAccessorDescriptor(desc)がtrueの筈なので、getterをdesc.[[Get]]とします。
12. もしgetterがundefinedならば、undefinedを返します。
13. this値としてOを使い、引数無しで、getterの[[Call]]内部メソッドを呼び出した結果を返します。


8.12.4 [[CanPut]] ( P )


Oの[[CanPut]]内部メソッドがプロパティ名Pで呼び出された場合には、以下のステップで行われます。

1. Oの[[GetOwnProperty]]内部メソッドを引数Pで呼び出した結果をdescとします。
2. もしdescがundefined以外ならば...
  a. もしIsAccessorDescriptor(desc)がtrueならば...
    i. もしdesc.[[Set]]がundefinedならば、falseを返します。
    ii. そうでなければ、trueを返します。
  b. そうでなければ、descはDataDescriptorに違いないので、desc.[[Writable]]の値を返します。
3. Oの[[Prototype]]内部プロパティの値をprotoとします。
4. もしprotoがnullならば、Oの[[Extensible]]内部プロパティの値を返します。
5. protoの[[Extensible]]内部メソッドをプロパティ名Pで呼び出した結果をinheritedとします。
6. もしinheritanceがundefinedならば、Oの[[Extensible]]内部プロパティの値を返します。
7. もしIsAccessorDescriptor(inherited)がtrueならば...
  a. もしinherited.[[Set]]がundefinedならば、falseを返します。
  b. そうでなければ、trueを返します。
8. そうでなければ、inheritedはDataDescriptorに違いないので...
  a. Oの[[Extensible]]内部プロパティがfalseならば、falseを返します。
  b. そうでなければ、inherited.[[Writable]]の値を返します。

ホストオブジェクトは追加の制約を[[Put]]操作に対して定義しているかもしれません。もし可能であれば、ホストオブジェクトは、ここの定義の[[CanPut]]がfalseを返すような状況では、[[Put]]操作を許してはいけません。


8.12.5 [[Put]] ( P, V, Throw )


Oの[[Put]]内部メソッドがプロパティ名P、値V、BooleanフラグThrowで呼び出された場合には、以下のステップで行われます。

1. もしOの[[CanPut]]内部メソッドを引数Pで呼び出した結果がfalseの場合には...
  a. Throwがtrueならば、TypeErrorをスローします。
  b. そうでなければ、戻ります。
2. Oの[[GetOwnProperty]]内部メソッドを引数Pで呼び出した結果をownDescとします。
3. もしIsDataDescriptor(ownDesc)がtrueならば...
  a. プロパティ記述子
    {
      [[Value]]: V
    }
    をvalueDescとします。
  b. Oの[[DefineOwnProperty]]内部メソッドを引数P, valueDesc, Throwで呼び出します。
4. Oの[[GetProperty]]内部メソッドを引数Pで呼び出した結果をdescとします。descは自分自身のアクセサプロパティ、継承したアクセサプロパティ、継承したデータプロパティ記述子のいずれかになります。
5. もしIsAccessorDescriptor(desc)がtrueならば...
  a. undefinedではないに違いないdesc.[[Set]]をsetterとします。
  b. this値としてOを使い、引数をVひとつだけで、setterの[[Call]]内部メソッドを呼び出します。
6. そうでなければ、オブジェクトOに名前付きデータプロパティPを以下のとおり作ります。
  a. プロパティ記述子
    {
      [[Value]]: V,
      [[Writable]]: true,
      [[Enumerable]]: true,
      [[Configurable]]: true
    }
    をnewDescとします。
  b. Oの[[DefineOwnProperty]]内部メソッドを引数P, newDesc, Throwで呼び出します。
7. 戻ります。


8.12.6 [[HasProperty]] ( P )


Oの[[HasProperty]]内部メソッドがプロパティ名Pで呼び出された場合には、以下のステップで行われます。

1. Oの[[GetProperty]]内部メソッドをプロパティ名Pで呼び出した結果をdescとします。
2. もしdescがundefinedならば、falseを返します。
3. そうでなければ、trueを返します。


8.12.7 [[Delete]] ( P, Throw )


Oの[[Delete]]内部メソッドがプロパティ名P、BooleanフラグThrowで呼び出された場合には、以下のステップで行われます。

1. Oの[[GetOwnProperty]]内部メソッドをプロパティ名Pで呼び出した結果をdescとします。
2. もしdescがundefinedならば、trueを返します。
3. もしdesc.[[Configurable]]がtrueならば...
  a. Oから名前がPである固有プロパティを削除します。
  b. trueを返します。
4. そうでない場合にThrowがtrueならば、TypeErrorをスローします。
5. falseを返します。


8.12.8 [[DefaultValue]] ( hint )


Oの[[DefaultValue]]内部メソッドが文字列のヒントで呼び出された場合には、以下のステップで行われます。

1. オブジェクトOの[[Call]]内部メソッドを引数"toString"で呼び出した結果をtoStringとします。
2. もしIsCallable(toString)がtrueならば...
  a. toStringの[[Call]]内部メソッドを、this値としてOを使い、空の引数リストで呼び出した結果をstrとします。
  b. もしstrがプリミティブな値であれば、strを返します。
3. オブジェクトOの[[Get]]内部メソッドを引数"valueOf"で呼び出した結果をvalueOfとします。
4. もしIsCallable(valueOf)がtrueならｂ...
  a. valueOfの[[Call]]内部メソッドを、this値としてOを使い、空の引数リストで呼び出した結果をvalとします。
  b. もしvalがプリミティブな値であれば、valを返します。
5. TypeErrorをスローします。

Oの[[DefaultValue]]内部メソッドが数値のヒントで呼び出された場合には、以下のステップで行われます。

1. オブジェクトOの[[Get]]内部メソッドを引数"valueOf"で呼び出した結果をvalueOfとします。
2. もしIsCallable(valueOf)がtrueならば...
  a. valueOfの[[Get]]内部メソッドを、this値としてOを使い、空の引数リストで呼び出した結果をvalとします。
  b. もしvalがプリミティブな値であれば、valを返します。
3. オブジェクトOの[[Get]]内部メソッドを引数"toString"で呼び出した結果をtoStringとします。
4. もしIsCallable(toString)がtrueであれば...
  a. toStringの[[Call]]内部メソッドを、this値としてOを使い、空の引数リストで呼び出した結果をstrとします。
  b. もしstrがプリミティブな値であれば、strを返します。
5. TypeErrorをスローします。

Oの[[DefaultValue]]内部メソッドがヒント無しに呼び出された場合には、Oが日付オブジェクト(15.9.6)で無い限りは、ヒントが数値であるかのように振る舞います。日付オブジェクトの場合には、ヒントは文字列であるかのように振る舞います。

上記のネイティブオブジェクトの[[DefaultValue]]の仕様は、プリミティブな値だけを返します。もしホストオブジェクトが固有の[[DefaultValue]]内部メソッドを実装する場合には、[[DefaultValue]]内部メソッドがプリミティブな値だけを返すように保証しなければなりません。


8.12.9 [[DefineOwnProperty]] ( P, Desc, Throw )


以下のアルゴリズムでは"Reject"という用語は"Throwフラグがtrueならば、TypeError例外をスローするが、そうでなければfalseを返す"ということを意味します。アルゴリズムはプロパティ記述子Descの様々なフィールドが特定の値であることをテストするステップが含まれています。この作法においてテストされるフィールドはDescに実際に存在する必要はありません。もしフィールドが存在しなければ、その値はfalseであると見なされます。

Oの[[DefineOwnProperty]]内部メソッドが、プロパティ名P、プロパティ記述子Desc、Throwフラグで呼び出された場合には、以下のステップで行われます。

1. Oの[[GetOwnProperty]]内部メソッドをプロパティ名Pで呼び出した結果をcurrentとします。
2. Oの[[Extensible]]内部プロパティの値をextensibleとします。
3. もしcurrentがundefinedでextensibleがfalseであれば、Rejectします。
4. もしcurrentがundefinedでextensibleがtrueであれば...
  a. もしIsGenericDescriptor(Desc)もしくはIsDataDescriptor(Desc)がtrueであれば...
    i. [[Value]], [[Writable]], [[Enumerable]], [[Configurable]]属性の値がDescであるオブジェクトOに対して、名前がPである固有データプロパティを作ります。
  b. そうでなければ、Descはアクセサプロパティ記述子であるので...
    i. [[Get]], [[Set]], [[Enumerable]], [[Configurable]]属性の値がDescであるオブジェクトOに対して、名前がPである固有アクセサプロパティを作ります。
  c. trueを返します。
5. もしDescにひとつもフィールドがなければ、trueを返します。
6. もしDescのすべてのフィールドがcurrentに存在し、Descのすべてのフィールドの値がSameValueアルゴリズム(9.12)を使った比較方法でcurrentの対応するフィールドと一致すれば、trueを返します。
7. もしcurrentの[[Configurable]]フィールドがfalseであれば...
  a. もしDescの[[Configurable]]フィールドがtrueであれば、Rejectします。
  b. もしDescの[[Enumerable]]フィールドが存在し、currentの[[Enumerable]]フィールドとDescの[[Enumerable]]フィールドが互いに真理値的に反対であれば、Rejectします。
8. もしIsGenericDescriptor(Desc)がtrueであれば、これ以上の妥当性検証は要求されません。
9. そうでない場合に、IsDataDescriptor(current)とIsDataDescriptor(Desc)が異なる結果であれば...
  a. もしcurrentの[[Configurable]]フィールドがfalseであれば、Rejectします。
  b. もしIsDataDescriptor(current)がtrueであれば...
    i. オブジェクトOのPという名前のプロパティをデータプロパティからアクセサプロパティへと変換します。

変換したプロパティの[[Configurable]]と[[Enumerable]属性の存在する値を保持し、プロパティの残りの属性をそれらの初期値に設定します。

  c. そうでなければ...
    i. オブジェクトOのPという名前のプロパティをアクセサプロパティからデータプロパティへと変換します。

変換したプロパティの[[Configurable]]と[[Enumerable]]属性の存在する値を保持し、プロパティの残りの属性をそれらの初期値に設定します。

10. そうでなければ、もしIsDataDescriptor(current)とIsDataDescriptor(Desc)が両方ともtrueであれば...
  a. もしcurrentの[[Configurable]]フィールドがfalseならば..
    i. もしcurrentの[[Writable]]フィールドがfalseであり、Descの[[Writable]]フィールドがtrueであれば、Rejectします。
    ii. もしcurrentの[[Writable]]フィールドががfalseならば...
      1. もしDescの[[Value]]フィールドが存在し、SameValue(Desc.[[Value]], current.[[Value]])がfalseならば、Rejectします。
  b. そうでなければ、currentの[[Configurable]]フィールドはtrueであり、どのような変更も受け付けられます。
11. そうでなければ、IsAccessorDescriptor(current)とIsAccessorDescriptor(Desc)が両方ともtrueならば...
  a. もしcurrentの[[Configurable]]フィールドがfalseならば..
    i. もしDescの[[Set]]フィールドが存在し、SameValue(Desc.[[Set]], current.[[Set]])がfalseならば、Rejectします。
    ii. もしDescの[[Get]]フィールドが存在し、SameValue(Desc.[[Get]], current.[[Get]])がfalseならば、Rejectします。
12. Descのすべてのフィールドに対して、オブジェクトOのPという名前のプロパティの対応する属性をフィールドの値に設定します。

しかしながら、もしOがArrayオブジェクトであれば、15.4.5.1で定義されるより複雑な[[DefineOwnProperty]]内部メソッドを持ちます。

注意：10.bの手続きでは、もしcurrentの[[Configurable]]フィールドがtrueの場合に、Descのすべてのフィールドをcurrentの対応するフィールドとは別々にします。これは、[[Writable]]属性がfalseであるプロパティの[[Value]]を変更することを可能にします。これが許されているのは、[[Configurable]]属性がtrueであることは、[[Writable]]が最初にtrueに設定され、新しい[[Value]]が設定され、それから[[Writable]]がfalseに設定されるという呼び出しと同等の流れを許すためです。

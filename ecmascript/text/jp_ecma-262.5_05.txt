5 表記方法



5.1 構文文法と字句文法



5.1.1 文脈自由文法


文脈自由文法はいくつもの生成規則から構成されます。どの生成規則も左辺の非終端記号と呼ばれる抽象的な記号と、右辺の0個以上の非終端記号と終端記号を持ちます。どの文法でも終端記号はアルファベットで記述されています。

目標記号と呼ばれるひとつの特別な非終端記号から構成される文から始めた場合、与えられた文脈自由文法は言語を示すことになります。つまり、生成規則の左辺にある非終端記号に対して、生成規則の右辺の並びの非終端記号へと繰り返し置き換えていった結果から得られる終端記号の取り得る並びの(多分、無限の)集合を示すことになります。


5.1.2 字句と正規表現の文法


ECMAScriptの字句文法は7節で定義を与えます。この文法は6節で定義するSourceCharacterの規則に適合する固有の終端記号の文字(Unicodeコード単位)を持っています。この文法は目標記号であるInputElementDivとInputElementRegExpのいずれかから始まる生成規則を定義しています。そこでは、そういった文字の並びがどのようにして入力要素の並びへと翻訳されていくかを述べています。

空白文字やコメント以外の入力要素は、ECMAScriptの構文文法にとっては終端記号を構成し、ECMAScriptトークンと呼ばれます。これらのトークンは、ECMAScriptの予約語、識別子、リテラル、区切り文字です。更に、トークンとは見なされない改行文字は、入力要素のストリームの一部を構成し、セミコロンの自動挿入(7.9)を制御します。普通の空白文字と行コメントは読み捨てられ、構文文法の入力要素のストリームには現れません。MultiLineComment(実際に複数行にまたがるかどうかに関係なく/* ... */形式のコメント)は、改行を含まなければ単純に読み捨てられます。ひとつ以上の改行文字を含んでいる場合には、それはひとつの改行文字に置き換えられ、構文文法上の入力要素のストリームの一部になります。ECMAScriptの正規表現の文法は15.10節で定義されます。この文法も独自の終端記号としてSourceCharacterによって定義される固有の文字を持ちます。それは、目標記号であるPatternから始まる生成規則の集合を定義します。Patternは文字の並びがどのように正規表現のパターンに翻訳されるかを述べています。

字句および正規表現の文法の生成規則は、区切り文字として二つのコロン"::"で区別されます。字句および正規表現の文法はいくつかの生成規則を共有しています。


5.1.3 数値文字列の文法


文字列を数値に変換するのには、また別の文法が用いられます。この文法は数値リテラルを扱うところと、その終端記号がSourceCharacterであるところが、字句文法の一部に似ています。

数値文字列の文法の生成規則は、三つのコロン":::"で区別されます。


5.1.4 構文文法


ECMAScriptの構文文法は11,12,13,14節で与えられます。この文法は固有の終端記号(5.1.2)として字句文法によって定義されるECMAScriptトークンを持っています。それは、目標記号であるProgramから始まる生成規則の集合を定義しており、構文的に正しいECMAScriptのプログラムを、どうやってトークンの並びが形成するかを述べています。

文字のストリームがEMCAScriptのプログラムとして解析される場合、まずはじめに、字句文法が繰り返し適用されることで、文字のストリームが入力要素のストリームに変換されます。この入力要素のストリームは一回だけ構文文法で解析されます。もし入力要素のストリームのトークンがこれ以上ないときに、目標の非終端記号である単一のProgramだけに解析できない場合には、プログラムに構文上のエラーがあります。

構文文法の生成規則は、区切り文字としてただひとつの":"で区別されます。

11,12,13,14節で提示される構文文法は、実際には、正しいECMAScriptプログラムとして受理されるトークンの並びの完全な説明にはなっていません。いくつかの追加のトークンの並びが受理されてしまいます。つまり、特定の場所(例えば改行文字の前)にセミコロンが追加された場合でも文法によって受け入れられてしまいます。更に、文法によって改行文字が特定のやっかいな場所に現れる場合は、文法によって受け入れられるトークンの並びでも受理できるとは見なされません。


5.1.5 JSON文法


JSON文法はECMAScriptのオブジェクトを表現している文字列を、実際のオブジェクトに翻訳するために用いられます。JSON文法は15.12.1で定義を与えます。

JSON文法はJSON字句文法とJSON構文文法からなります。JSON字句文法は文字の並びをトークンの並びに翻訳します。ECMAScript字句文法に似ています。JSON構文文法は、JSON字句文法のトークンの並びから、構文的に正しいJSONオブジェクトの表現を形成するかを述べています。

JSON字句文法の区切り文字は、二つのコロン"::"で区別されます。JSON字句文法はECMAScript字句文法からいくつかの生成規則を使用しています。JSON構文文法は、ECMAScript構文文法の一部に似ています。JSON構文文法は区切り文字としてひとつのコロン":"を使用することで区別します。


5.1.6 文法の表記法


字句文法および文字列文法の終端記号や構文文法のいくつかの終端記号は、テキストが直接そういった終端記号を参照する場合、文法の生成規則とこの使用全体を通して固定フォントで表記されています。これらはプログラムに正確に書かれているとおり表示えています。この方法で指定されたすべての終端記号の文字は、ASCII以外のよく似た文字としではなく、ASCIIの範囲の適切なUnicode文字として理解されるべきです。

非終端記号はイタリック体で表記されています。非終端記号の定義は、ひとつかそれ以上のコロン(コロンの数はその文法がどこに属するかを示します)によって非終端記号の名称が定義されるたびに導入されます。非終端記号の右辺のひとつ以上の代わりがある場合には、後続行に続きます。例えば、構文の定義が以下の場合は、...

  WhileStatement :
    while(Expression) Statement

...非終端記号のWhileStatementは、トークンwhile、続いて左括弧のトークン、続いてExpression、続いて右括弧、続いてStatementであることを述べています。現れているExpressionとStatementは、それら自身が非終端記号です。他の例として、構文の定義が以下の場合は、...

  ArgumentList :
    AssignmentExpression
    ArgumentList , AssignmentExpression

...ArgumentListは、ひとつのAssignmentExpressionか、ArgumentList、続いてカンマ、続いてAssignmentExpressionであることを表すことを述べています。このArgumentListの定義は再帰的です、つまり、これは自分自身によって定義されています。この結果として、ArgumentListはカンマによって区切られたいかなる正の個数の引数を含みます。そこではどの引数の式もAssignmentExpressionとなります。このような非終端記号の再帰的な定義は共通なものです。

終端記号や非終端記号の後に現れる添字の"opt"は、オプションの記号であることを意味しています。オプションの記号を含む選択肢というのは具体的には、ひとつはオプションの要素を省略したもの、もうひとつはその要素を含んだもの、の2種類の右辺を示しています。この記述は...

  VariableDeclaration :
    Identifier Initialiseropt

...以下の記述の省略形です。

  VariableDeclaration :
    Identifier
    Identifier Initialiser

そして、この記述は...

  IterationStatement :
    for ( ExpressionNoIn[opt] ; Expression[opt] ; Expression[opt] ) Statement

...以下の記述の省略形であり、更に...

  IterationStatement :
    for ( ; Expression[opt] ; Expression[opt] ) Statement
    for ( ExpressionNoIn ; Expression[opt] ; Expression[opt] ) Statement

...以下の記述の省略形であり、更に...

  IterationStatement :
    for ( ; ; Expression[opt] ) Statement
    for ( ; Expression ; Expression[opt] ) Statement
    for ( ExpressionNoIn ; ; Expression[opt] ) Statement
    for ( ExpressionNoIn ; Expression ; Expression[opt] ) Statement

...以下の記述の省略形です。

  IterationStatement :
    for ( ; ; ) Statement
    for ( ; ; Expression ) Statement
    for ( ; Expression ; ) Statement
    for ( ; Expression ; Expression ) Statement
    for ( ExpressionNoIn ; ; ) Statement
    for ( ExpressionNoIn ; ; Expression ) Statement
    for ( ExpressionNoIn ; Expression ; ) Statement
    for ( ExpressionNoIn ; Expression ; Expression ) Statement

よって、非終端記号のIterationStatementは、実際に異なる8種類の右辺を持ちます。

もし生成規則の右辺に"[empty]"という語句が現れたら、生成規則の右辺には終端記号も非終端記号も含まれていないことを示しています。

もし生成規則の右辺に"[lookahead not_a_member_of set]"という語句が現れたら、生成規則は、直後の入力トークンが与えられたsetのメンバならば、すぐには使われないかもしれません。集合は波括弧で括られた終端記号のリストとして書かれます。利便性のために、非終端記号でも書くことができますが、その場合には、非終端記号を展開してできるすべての終端記号を表します。例えば、定義が以下のとおりならば...

  DecimalDigit :: one of
    0 1 2 3 4 5 6 7 8 9
  DecimalDigits ::
    DecimalDigit
    DecimalDigits DecimalDigit

..次の定義は...

  LookaheadExample ::
    n [lookahead not_a_member_of {1, 3, 5, 7, 9}] DecimalDigits
    DecimalDigit [lookahead not_a_member_of DecimalDigit ]

...文字nに続く偶数で始まるひとつ以上の数字か、あとに数字の続かないひとつの数字のいずれかにマッチします。

もし、構文文法の生成規則の右辺に"[no LineTerminator here]"という語句が現れた場合には、制限された生成規則であることを示します。もし、入力ストリームの指示された場所にLineTerminatorが現れた場合でも、使用されることはありません。例えば...

  ReturnStatement :
    return [no LineTerminator here] Expression[opt] ;

...生成規則がこうなっていたら、プログラム上でreturnトークンとExpressionの間にLineTerminatorが現れたら、この生成規則が使用されないことを示しています。

LineTerminatorの存在が、制限された生成規則によって禁止されなければ、プログラムの構文の受理可能性への影響無しに入力要素のストリームにおけるいかなる二つのトークンの間にも、いくつもの数のLineTerminatorが現れることができることになります。

"one of"という語句が文法を定義するコロンのあとに続いた場合には、それは次行以降の終端記号は選択的な定義であることを示します。例えば、ECMAScriptの字句文法には以下の生成規則が含まれます。

  NonZeroDigit :: one of
    1 2 3 4 5 6 7 8 9

これは以下の記述の省略形です。

  NonZeroDigit ::
    1
    2
    3
    4
    5
    6
    7
    8
    9

字句文法や数値文字列文法の生成規則において選択的な記述が複数文字からなるトークンが現れた場合には、そういったトークンを文字の並びは意味します。

生成規則の右辺は、"but not"という語句を使うことで、特定の展開を許可しないことを明示することができます。そして、そういった展開を除外することを意味します。例えば、以下の生成規則は...

  Identifier ::
    IdentifierName but not ReservedWord

...非終端記号Identifierは、同じ文字の並びがReservedWordに置き換えできないことをのぞいてIdentifierNameに置き換えできるいかなる文字の並びにも置き換えられます。

最終的には、あらゆる選択肢をリスト化できないような場合には、サンセリフ体を用いて説明的な語句で非終端記号は記述されるようになります。

  SourceCharacter ::
    any Unicode code unit


5.2 アルゴリズム


この仕様ではしばしばアルゴリズムのステップを示すのに番号付きリストを使用しています。これらのアルゴリズムはECMAScript言語を構築するために要求されるセマンティクスを正確に示すために用いられています。アルゴリズムは実装のテクニックを示すために用いられているのではありません。実際に、特定の機能を実装するための、より効率的なアルゴリズムがあるかもしれません。

この仕様のさまざまな部分でこれらのアルゴリズムを使い易くするために、いくつかの抽象操作と呼ばれるアルゴリズムは、他のアルゴリズムから名前で参照されるために、名前を付けられパラメタ化された関数形式で記述されています。

あるアルゴリズムが結果として値を作りだす場合には、命令"return x"は、アルゴリズムの結果がxの値であり、そしてアルゴリズムが終了することを示しています。Result(n)という記法は、"ステップnの結果"という表現の簡易表記です。

表現を明らかにするために、アルゴリズムのステップはシーケンシャルなサブステップに分割されます。サブステップはインデントされ、それ自身が更にサブステップ化することができます。番号付けによるアウトラインの表記法では、最初のレベルのサブステップを小文字でラベル付けし、2番目のレベルのサブステップをローマ数字でラベル付けします。もし、3つより多いレベルが必要になった場合には、4番目のレベルに数字のラベル付けをして、これらのルールを繰り返します。例えば以下のとおりです。

  1. トップレベルステップ
    a. サブステップ
    b. サブステップ
      i. サブサブステップ
      ii. サブサブステップ
        1. サブサブサブステップ
          a サブサブサブサブステップ

ステップやサブステップは、それ自身のサブステップの条件となる"if"述語として書かれる場合があります。この場合には、サブステップは述語がtrueになった場合にだけ適用されます。もしステップやサブステップが"else"という単語で始まった場合には、先行する同じレベルの"if"述語の否定を意味する述語になります。

ステップはそれ自身のサブステップの繰り返しての適用を示す場合があります。

加算、減算、否定、乗算、除算、この節でのあとで定義される数学的な関数といった、数学的な操作、いかなるときも数学的な実数に基づく正確な数学的結果を計算するものと理解されなければいけません。それには、無限大や、正のゼロと区別するための負のゼロは含まれせん。この標準仕様のアルゴリズムのモデルとなる浮動小数点演算には、必要であれば、無限大や符号付きゼロを扱い丸め処理を実行するための明確なステップが含まれます。もし数学的な操作や関数が浮動小数点数値に適用された場合には、浮動小数点数値によって表現された厳密に数学的な値よって処理が行われたと理解すべきです。浮動小数点数値は有限であり、もし浮動小数点数値が+0/-0ならば、対応する数学的な値は単純に0です。

数学的関数abs(x)は、xの値の絶対値を返します。もしxが(ゼロより小さい)負ならばxのマイナスを、そうでなければx自身を返します。

数学的関数sign(x)は、もしxが正ならば1を返し、もしxが負ならば1の否定を返します。sign関数は、この標準仕様ではxがゼロの場合には使用しません。

"x modulo y"という表記(yは有限かつゼロ以外です)は、yと同じ符号で、abs(k) < abs(y) かつ、ある整数qに対して x - k = q * y を満たす値kを計算します。

数学的関数floor(x)は、xよりも大きくない整数のうちで、最も大きい整数(最大では正の無限大)です。

注意：floor(x) = x - (x module 1)

もしアルゴリズムが"例外を発生"と定義されていたら、アルゴリズムの実行は終了し、結果が返らない場合があります。アルゴリズムのステップが、"もし例外が発生したら..."という記述によって明示的に例外を処理する箇所に至るまで、アルゴリズムの呼び出しは中断されます。一旦、アルゴリズムステップで例外が発生した場合は、もうそれ以上例外は発生しないと考えられます。

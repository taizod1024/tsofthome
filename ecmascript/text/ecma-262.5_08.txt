* 8 Types 

* 8 型


Algorithms within this specification manipulate values each of which has an
associated type. The possible value types are exactly those defined in this
clause. Types are further subclassified into ECMAScript language types and
specification types.

この仕様のアルゴリズムでは型に関連付られた値を操作します。取り得る値の型は、この
節で厳密に定義されています。型はさらにECMAScript言語の型と仕様の型へとサブクラス
化されています。


An ECMAScript language type corresponds to values that are directly manipulated
by an ECMAScript programmer using the ECMAScript language. The ECMAScript
language types are Undefined, Null, Boolean, String, Number, and Object.

ECMAScript言語の型は、ECMAScript言語を使うECMAScriptのプログラマによって直接的に
操作される値に相当します。ECMAScript言語の型はUndefined, Null, Boolean, String,
Number, Objectです。


A specification type corresponds to meta-values that are used within algorithms
to describe the semantics of ECMAScript language constructs and ECMAScript
language types. The specification types are Reference, List, Completion,
Property Descriptor, Property Identifier, Lexical Environment, and Environment
Record. Specification type values are specification artefacts that do not
necessarily correspond to any specific entity within an ECMAScript
implementation. Specification type values may be used to describe intermediate
results of ECMAScript expression evaluation but such values cannot be stored as
properties of objects or values of ECMAScript language variables.

仕様の型は、ECMAScript言語の構造とECMAScript言語の型のセマンティクスで述べられる
アルゴリズムで使われるメタな値に相当します。この仕様の型は、参照、リスト、補完、
プロパティ記述子、プロパティ識別子、レキシカル環境、環境レコードです。仕様の型の
値は仕様が産み出したものであり、必ずしもECMAScriptの実装における任意の特定のエン
ティティに対応しているとは限りません。仕様の型の値は、ECMAScriptの式の評価の中間
結果を記述するために使用されますが、ECMAScript言語の変数のオブジェクトや値のプロ
パティとして保存することはできません。


Within this specification, the notation “Type(x)” is used as shorthand for “the
type of x” where “type” refers to the ECMAScript language and specification
types defined in this clause.

この仕様において"Type(x)"という表記は、この節で定義されるECMAScript言語の型と仕
様の型を参照するときの"xの型"という表記の短縮形です。


* 8.1 The Undefined Type 

* 8.1 Undefined型


The Undefined type has exactly one value, called undefined. Any variable that
has not been assigned a value has the value undefined.

Undefined型は厳密にたったひとつの値を持ちます。undefinedと呼ばれる値です。値が代
入されていない変数の値はundefinedです。


* 8.2 The Null Type 

* 8.2 Null型


The Null type has exactly one value, called null.

Null型は厳密にひとつの値を持ちます。nullと呼ばれる値です。


* 8.3 The Boolean Type

* 8.3 Boolean型


The Boolean type represents a logical entity having two values, called true and
false. 

Boolean型は二つの値を持つ論理的なエンティティです。trueとfalseと呼ばれる二つの値
です。


* 8.4 The String Type

* 8.4 String型


The String type is the set of all finite ordered sequences of zero or more
16-bit unsigned integer values (“elements”). The String type is generally used
to represent textual data in a running ECMAScript program, in which case each
element in the String is treated as a code unit value (see Clause 6). Each
element is regarded as occupying a position within the sequence. These positions
are indexed with nonnegative integers. The first element (if any) is at position
0, the next element (if any) at position 1, and so on. The length of a String is
the number of elements (i.e., 16-bit values) within it. The empty String has
length zero and therefore contains no elements.

String型は16ビットの符号無し整数値("要素")のゼロ個以上の順序が決定された並びの集
合です。String型は一般的に実行中のECMAScriptプログラムでテキストデータを表現する
ために使われます。その場合には、文字列の中のどの要素もコード単位の値(6.)として扱
われます。どの要素も並びの中である位置を占有している見なされます。これらの位置は
非負の整数でインデックスされています。(もし最初の要素があれば)最初の要素は位置0
です。(次の要素があれば)次の要素は位置1です。以下同じです。文字列の長さは要素の
個数です(例えば、16ビットの値です)。空の文字列は長さ0であり、そのためひとつも要
素を含みません。


When a String contains actual textual data, each element is considered to be a
single UTF-16 code unit. Whether or not this is the actual storage format of a
String, the characters within a String are numbered by their initial code unit
element position as though they were represented using UTF-16. All operations on
Strings (except as otherwise stated) treat them as sequences of undifferentiated
16-bit unsigned integers; they do not ensure the resulting String is in
normalised form, nor do they ensure language-sensitive results. 

文字列が実テキストデータが含むときは、どの要素も単一のUTF-16コード単位であると見
なされます。文字列の実ストレージの形式にどうであるかに関わらず、文字列の中の文字
は、UTF-16を使って表現されたかのように、コード単位の要素の初期の位置によって番号
付けられます。(後で述べる場合を除きますが)文字列のすべての操作は、文字列を分離さ
れていない16ビット符号無し整数の並びとして操作します。このことは、結果の文字列が
正規化されていることを保証しませんし、言語に依存した結果を保証しません。


NOTE The rationale behind this design was to keep the implementation of Strings
as simple and high-performing as possible. The intent is that textual data
coming into the execution environment from outside (e.g., user input, text read
from a file or received over the network, etc.) be converted to Unicode
Normalised Form C before the running program sees it. Usually this would occur
at the same time incoming text is converted from its original character encoding
to Unicode (and would impose no additional overhead). Since it is recommended
that ECMAScript source code be in Normalised Form C, string literals are
guaranteed to be normalised (if source text is guaranteed to be normalised), as
long as they do not contain any Unicode escape sequences. 

注意：このデザインの背景は、文字列処理の実装を可能な限りシンプルでパフォーマンス
を高く保つためです。外部(例えば、ユーザの入力、ファイルからの読み込み、ネット
ワーク越しの受信、...)から実行環境に入ってくるテキストデータは、実行中のプログラ
ムが参照する前にUnicode Normalised Form Cの形式に変換されるべきということを意図
しています。これはテキストを受信すると同時に(追加のオーバーヘッドを課すことなし
に)元々の文字エンコーディングからUnicodeへの変換されるのが普通です。ECMAScriptの
ソースコードはNormalized Form Cであることを勧めているため、Unicodeエスケープシー
ケンスがそれらに含まれていない場合には、(もしソーステキストが正規化されているこ
とが保証されているならば)文字列リテラルもまた正規化されていることが保証されま
す。【訳注】Unicode Normalized Form C：文字が合成済みとなっている形式。例えば a
+ umlaut → ä


* 8.5 The Number Type

* 8.5 Number型


The Number type has exactly 18437736874454810627 (that is, 2^64-2^53+3) values,
representing the double-precision 64-bit format IEEE 754 values as specified in
the IEEE Standard for Binary Floating-Point Arithmetic, except that the
9007199254740990 (that is, 2^53-2) distinct “Not-a-Number” values of the IEEE
Standard are represented in ECMAScript as a single special NaN value. (Note that
the NaN value is produced by the program expression NaN.) In some
implementations, external code might be able to detect a difference between
various Not-a-Number values, but such behaviour is implementation-dependent; to
ECMAScript code, all NaN values are indistinguishable from each other.

Number型は厳密に18437736874454810627(=2^64-2^53+3)個の値を取ります。二進浮動小数
点演算用としてIEEE標準において規定されている倍精度64ビットIEEE754形式の値で表現
できる値です。IEEE標準の"Not-a-Number"を表す個々の9007199254740990(=2^53-2)個の
値は、ECMAScriptの中においてNaN値という特別なひとつの値として表現されておりこれ
を除きます(NaN値はプログラムの式NaNによって生成されることに注意しましょう)。実装
によっては、外部コードが様々なNot-a-Number値を区別して検知するかもしれませんが、
そういった振る舞いは実装依存であり、ECMAScriptコードにとってはすべてのNaN値は
個々に区別できません。【訳注】IEE754-2008 64ビットバイナリ形式
------- ----------- ------  ------  ------  --------------------------------
種類                符号    指数部  仮数部  値の個数                 
                    1bit    11bit   52bit                 
------- ----------  ------  ------  ------  --------------------------------
NaN     －          任意    2047    0以外   2^1x1       x(2^52-1)=2^53-2   
無限大  －          任意    2047    0       2^1x1       x1       =2        
有限数  ゼロ        任意    0       0       2^1x1       x1       =2     
        正規化数    任意    1-2046  任意    2^1x(2^11-2)x2^52    =2^64-2^54非正
        規化数  任意    0       0以外   2^1x(2^52-1)         =2^53-2   
------- ----------  ------  ------  ------  --------------------------------
IEE754-2008 64ビットバイナリでは合計=2^64個ECMAScriptのNumber型はNaNが2^53-2 → 1
に減っているのでその分個数が異なる。


There are two other special values, called positive Infinity and negative
Infinity. For brevity, these values are also referred to for expository purposes
by the symbols +∞ and -∞, respectively. (Note that these two infinite Number
values are produced by the program expressions +Infinity (or simply Infinity)
and - Infinity.)

二つの特別な値があります。無限大と負の無限大と呼ばれる値です。簡単に言えば、これ
らの値はそれぞれ+∞と-∞というシンボルを説明する目的で参照されます。(これらの二つ
の無限の数値はプログラムの式+Infinity(もしくは単にInfinity)と-Infinityによって作
られていることに注意しましょう。)


The other 18437736874454810624 (that is, 2^64-2^53) values are called the finite
numbers. Half of these are positive numbers and half are negative numbers; for
every finite positive Number value there is a corresponding negative value
having the same magnitude.

その他の18437736874454810624(=2^64-2^53)個の値は有限数と呼ばれます。これらの半分
は正の数値で、半分は負の数値です。すべての有限の正の数値と同じ大きさの対応する負
の数値があります。


Note that there is both a positive zero and a negative zero. For brevity, these
values are also referred to for expository purposes by the symbols +0 and -0,
respectively. (Note that these two different zero Number values are produced by
the program expressions +0 (or simply 0) and -0.)

正のゼロと負のゼロがあることに気をつけましょう。簡単に言えば、これらの値はそれぞ
れ+0と-0という二つのシンボルを説明する目的で参照されます。(二つの異なるゼロとい
う数値はプログラムの式+0(もしくは単に0)と-0によって作られていることに注意しま
しょう。)


The 18437736874454810622 (that is, 2^64-2^53-2) finite nonzero values are of two
kinds:

18437736874454810622(=2^64-2^53-2)個のゼロではない有限数には二つの種類がありま
す。


18428729675200069632 (that is, 2^64-2^54) of them are normalised, having the
form 

それらの18428729675200069632(=2^64-2^54)個は正規化されており、以下の形式を取りま
す。


s * m * 2^e 


where s is +1 or -1, m is a positive integer less than 2^53 but not less than
2^52, and e is an integer ranging from -1074 to 971, inclusive. 

ここでsは+1もしくは-1、mは2^53より小さく2^52より小さくはない値、eは-1074から971
までの値です。


The remaining 9007199254740990 (that is, 2^53-2) values are denormalised, having
the form 

残りの9007199254740990(=2^53-2)個は正規化されておらず、以下の形式を取ります。


s * m * 2^e


where s is +1 or -1, m is a positive integer less than 2^52, and e is -1074. 

ここでsは+1もしくは-1、mは2^52より小さい値、eは-1074です。


Note that all the positive and negative integers whose magnitude is no greater
than 2^53 are representable in the Number type (indeed, the integer 0 has two
representations, +0 and -0). 

絶対値が2^53より大きくはないすべての正の整数と負の整数はNumber型で表現されます。
(実際に整数0は二つの表現、+0と-0で表現されます。)


A finite number has an odd significand if it is nonzero and the integer m used
to express it (in one of the two forms shown above) is odd. Otherwise, it has an
even significand. 

有限数は、それがゼロではなく(上記の二つの形式のいずれかを)表現するのに使用してい
る整数mが奇数であれば奇数サインを持っており、そうでなければ偶数サインを持ってい
ます。


In this specification, the phrase “the Number value for x” where x represents an
exact nonzero real mathematical quantity (which might even be an irrational
number such as π) means a Number value chosen in the following manner. Consider
the set of all finite values of the Number type, with -0 removed and with two
additional values added to it that are not representable in the Number type,
namely 2^1024 (which is +1 * 2^53 * 2^971) and -2^1024 (which is -1 * 2^53 *
2^971). Choose the member of this set that is closest in value to x. If two
values of the set are equally close, then the one with an even significand is
chosen; for this purpose, the two extra values 2^1024 and -2^1024 are considered
to have even significands. Finally, if 2^1024 was chosen, replace it with +∞; if
-2^1024 was chosen, replace it with -∞; if +0 was chosen, replace it with -0 if
and only if x is less than zero; any other chosen value is used unchanged. The
result is the Number value for x. (This procedure corresponds exactly to the
behaviour of the IEEE 754 “round to nearest” mode.)

この仕様では xがゼロではない実在の数学的な量(πのように無理数かもしれません)を表
現する場合に、"xの数値"という語句は以下のやり方に従って選ばれた数値を意味しま
す。- Number型のすべての有限数の集合を考えます。
- 集合から-0を除きます
- 集合にNumber型で表現できないことを意味する二つの値2^1024(= +1 * 2^53 * 2^971)
  と-2^1024(= -1 * 2^53 * 2^971)を追加します。
- 集合からxに最も近い要素を選びます。もし二つの値がxと全く同じだけ近かったら、偶
  数サインを持っている側が選ばれます。この目的のために二つの追加の値2^1024と
  -2^1024は偶数サインを持っていると見なします。
- 最終的に...
  - +2^1024が選ばれたならば、それを+∞に置き換えます。
  - -2^1024が選ばれたならば、それを-∞に置き換えます。
  - もし+0が選ばれたならば、ｘが0より小さいときだけ-0に置き換えます。
  - その他の値は変更しないまま使われます。この結果がxの数値になります。(この手続
    きはIEEE754の最近接丸め(偶数)モードの振る舞いに厳密に相当します。)


Some ECMAScript operators deal only with integers in the range -2^31 through
2^31-1, inclusive, or in the range 0 through 2^32-1, inclusive. These operators
accept any value of the Number type but first convert each such value to one of
2^32 integer values. See the descriptions of the ToInt32 and ToUint32 operators
in 9.5 and 9.6, respectively.

いくつかのECMAScriptにおける操作では、-2^31から2^31-1までの整数の範囲、もしく
は、0から2^32-1までの整数の範囲だけを扱います。これらの操作はNumber型のいかなる
値も受け付けますが、最初にそれぞれの値を2^32個の整数値のいずれかに変換してから行
います。それぞれ9.5および9.6のToInt32およびToUint32演算の記述を見てください。


* 8.6 The Object Type

* 8.6 オブジェクト型


An Object is a collection of properties. Each property is either a named data
property, a named accessor property, or an internal property: 

オブジェクトはプロパティのコレクションです。プロパティは、名前付きのデータプロパ
ティか、名前付きのアクセサプロパティか、内部プロパティのいずれかです。


- A named data property associates a name with an ECMAScript language value and
  a set of Boolean attributes. 
- A named accessor property associates a name with one or two accessor
  functions, and a set of Boolean attributes. The accessor functions are used to
  store or retrieve an ECMAScript language value that is associated with the
  property. 
- An internal property has no name and is not directly accessible via ECMAScript
  language operators. Internal properties exist purely for specification
  purposes. 

- 名前付きのデータプロパティは、名前とECMAScript言語の値およびBoolean型の属性の
  集合を関連付けています。
- 名前付きのアクセサプロパティは、名前とひとつもしくは二つのアクセサ関数および
  Boolean型の属性の集合を関連付けています。アクセサ関数はプロパティに関連付けら
  れたECMAScript言語の値の格納もしくは取得するために使われます。
- 内部プロパティは名前を持ちません、ECMAScript言語の操作からは直接はアクセスする
  ことはできません。内部プロパティは純粋に仕様上の目的のために存在します。


There are two kinds of access for named (non-internal) properties: get and put,
corresponding to retrieval and assignment, respectively. 

名前付きの(非内部な)プロパティへのアクセス方法には二種類あります。getとputです。
これらはそれぞれ取得と代入に相当します。


* 8.6.1 Property Attributes 

* 8.6.1 プロパティの属性


Attributes are used in this specification to define and explain the state of
named properties. A named data property associates a name with the attributes
listed in Table 5 

この仕様において属性は名前付きプロパティの状態を定義し説明するために使用されてい
ます。名前付きデータプロパティは名前と表5で示されている属性を関連付けます。


Table 5 - Attributes of a Named Data Property 
--------------------------------------------------------------------------------
Attribute Name Value Domain Description 
--------------------------------------------------------------------------------
[[Value]] Any ECMAScript language type The value retrieved by reading the
property. 
--------------------------------------------------------------------------------
[[Writable]] Boolean If false, attempts by ECMAScript code to change the
property's [[Value]] attribute using [[Put]] will not succeed. 
--------------------------------------------------------------------------------
[[Enumerable]] Boolean If true, the property will be enumerated by a for-in
enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable. 
--------------------------------------------------------------------------------
[[Configurable]] Boolean If false, attempts to delete the property, change the
property to be an accessor property, or change its attributes (other than
[[Value]]) will fail. 
--------------------------------------------------------------------------------

表5 - 名前付きデータプロパティの属性
--------------------------------------------------------------------------------
属性名値のドメイン内容
--------------------------------------------------------------------------------
[[Value]]型すべて読み込みプロパティによって取得された値です。
--------------------------------------------------------------------------------
[[Writable]] Booleanもしfalseならば[[Put]]によるプロパティの変更コードは失敗しま
す。
--------------------------------------------------------------------------------
[[Enumerable]] Booleanもしtrueならば、for-in列挙(12.6.4)ができ、そうでなれければ
列挙できないと言います。
--------------------------------------------------------------------------------
[[Configurable]] Booleanもしfalseならば、プロパティの削除、プロパティのアクセサ
プロパティへの変更、([[Value]]ではなく)属性の変更は失敗します。
--------------------------------------------------------------------------------


A named accessor property associates a name with the attributes listed in Table
6. 

名前付きアクセサプロパティは表6で示されている属性と関連付けます。


Table 6 - Attributes of a Named Accessor Property 
--------------------------------------------------------------------------------
Attribute Name Value Domain Description 
--------------------------------------------------------------------------------
[[Get]] Object or Undefined If the value is an Object it must be a function
Object. The function's [[Call]] internal method (8.6.2) is called with an empty
arguments list to return the property value each time a get access of the
property is performed. 
--------------------------------------------------------------------------------
[[Set]] Object or Undefined If the value is an Object it must be a function
Object. The function's [[Call]] internal method (8.6.2) is called with an
arguments list containing the assigned value as its sole argument each time a
set access of the property is performed. The effect of a property's [[Set]]
internal method may, but is not required to, have an effect on the value
returned by subsequent calls to the property's [[Get]] internal method.
--------------------------------------------------------------------------------
[[Enumerable]] Boolean If true, the property is to be enumerated by a for-in
enumeration (see 12.6.4). Otherwise, the property is said to be non-enumerable. 
--------------------------------------------------------------------------------
[[Configurable]] Boolean If false, attempts to delete the property, change the
property to be a data property, or change its attributes will fail. 
--------------------------------------------------------------------------------

表6 - 名前付きアクセサデータプロパティの属性
--------------------------------------------------------------------------------
属性名値のドメイン内容
--------------------------------------------------------------------------------
[[Get]] Object or Undefinedもし値がオブジェクトならば関数オブジェクトです。プロ
パティのgetアクセスが行われた場合には、関数の[[Call]]内部メソッド(8.6.2)が空の引
数リストで呼び出され、プロパティの値を返します。
--------------------------------------------------------------------------------
[[Set]] Object or Undefinedもし値がオブジェクトならば関数オブジェクトです。プロ
パティのSetアクセスが行われた場合には、関数の[[Call]]内部メソッド(8.6.2)が代入す
る値のひとつの引数リストで呼び出されます。プロパティの[[Set]]内部メソッドの影響
は、必須ではありませんが、それに連なるプロパティの[[Get]]内部メソッドによって返
される値に影響を与えます。
--------------------------------------------------------------------------------
[[Enumerable]] Booleanもしtrueならばfor-in列挙(12.6.4)ができ、そうでなれければ列
挙できないと言います。
--------------------------------------------------------------------------------
[[Configurable]] Booleanもしfalseならばプロパティの削除および変更、属性の変更は
失敗します。
--------------------------------------------------------------------------------


If the value of an attribute is not explicitly specified by this specification
for a named property, the default value defined in Table 7 is used. 

もし名前付きプロパティに関する仕様において属性の値が明示的に示されていない場合
は、表7で定義されている初期値が使われます。


Table 7 - Default Attribute Values 
------------------- ------------------------------------------------------------
Attribute Name      Default Value 
------------------- -----------------------------------------------------------
[[Value]]           undefined [[Get]]             undefined [[Set]]
undefined [[Writable]]        false [[Enumerable]]      false [[Configurable]]
false 
------------------- -----------------------------------------------------------

表7 - 属性の初期値
------------------- -----------------------------------------------------------
属性名              初期値
------------------- -----------------------------------------------------------
[[Value]]           undefined [[Get]]             undefined [[Set]]
undefined [[Writable]]        false [[Enumerable]]      false [[Configurable]]
false 
------------------- -----------------------------------------------------------


* 8.6.2 Object Internal Properties and Methods 

* 8.6.2 オブジェクトの内部プロパティとメソッド


This specification uses various internal properties to define the semantics of
object values. These internal properties are not part of the ECMAScript
language. They are defined by this specification purely for expository purposes.
An implementation of ECMAScript must behave as if it produced and operated upon
internal properties in the manner described here. The names of internal
properties are enclosed in double square brackets [[ ]]. When an algorithm uses
an internal property of an object and the object does not implement the
indicated internal property, a TypeError exception is thrown. 

この仕様ではオブジェクトの値の意味を定義するために様々な内部プロパティを使用しま
す。これらの内部プロパティはECMAScript言語の一部ではありません。それらは説明する
目的のためにこの仕様によって定義されています。ECMAScriptの実装はここで述べられて
いる作法に従って内部プロパティを作りだし操作しているかのごとく振る舞わなければい
けません。内部プロパティの名前は二重大括弧[[ ]]で括られています。アルゴリズムが
オブジェクトの内部プロパティを使用して、オブジェクトがその内部プロパティを実装し
ていない場合には、TypeError例外がスローされます。


The Table 8 summarises the internal properties used by this specification that
are applicable to all ECMAScript objects. The Table 9 summarises the internal
properties used by this specification that are only applicable to some
ECMAScript objects. The descriptions in these tables indicates their behaviour
for native ECMAScript objects, unless stated otherwise in this document for
particular kinds of native ECMAScript objects. Host objects may support these
internal properties with any implementation-dependent behaviour as long as it is
consistent with the specific host object restrictions stated in this document. 

表8は、この仕様によって使われているすべてのECMAScriptのオブジェクトへ適用可能な
内部プロパティのサマリです。テーブル９は、この仕様によって使われているいくつかの
ECMAScriptオブジェクトへのみ適用可能な内部プロパティのサマリです。これらのテーブ
ルの記述は、改めてこの文書において特定の種類のネイティブなECMAScriptなオブジェク
トについて述べていない限りは、そのオブジェクトの振る舞いを示しています。この文書
で述べられている特定のホストオブジェクトの制限において一貫性を保っている限りは、
いくらかは実装依存の振る舞いをしながらも、ホストオブジェクトはこれらの内部プロパ
ティをサポートします。


The “Value Type Domain” columns of the following tables define the types of
values associated with internal properties. The type names refer to the types
defined in Clause 8 augmented by the following additional names. “any” means the
value may be any ECMAScript language type. “primitive” means Undefined, Null,
Boolean, String, or Number. “SpecOp” means the internal property is an internal
method, an implementation provided procedure defined by an abstract operation
specification. “SpecOp” is followed by a list of descriptive parameter names. If
a parameter name is the same as a type name then the name describes the type of
the parameter. If a “SpecOp” returns a value, its parameter list is followed by
the symbol “→” and the type of the returned value. 

以降の表の"値の型のドメイン"列は内部プロパティに関連した値の型を定義しています。
型の名前は、以下の追加の名前によって8節の拡張で定義した型を参照します。
- "any"は、ECMAScript言語の型のどれかであることを意味します。
- "primitive"は、Undefined, Null, Boolean, String, Numberのどれかであることを意
  味します。
- "SpecOp"は、内部プロパティが内部メソッドの抽象操作の仕様で定義された手続きを提
  供していることを意味します。"SpecOp"には説明的なパラメタの名前のリストが続きま
  す。パラメタ名が型名と同じならば、名前はパラメタの型を述べています。もし
  "SpecOp"が値を返すのであれば、そのパラメタリストには"→"と返される値の型が続き
  ます。


Table 8 - Internal Properties Common to All Objects 
--------------------------------------------------------------------------------
Internal Property Value Type Domain Description 
--------------------------------------------------------------------------------
[[Prototype]] Object or Null The prototype of this object. 
--------------------------------------------------------------------------------
[[Class]] String A String value indicating a specification defined
classification of objects. 
--------------------------------------------------------------------------------
[[Extensible]] Boolean If true, own properties may be added to the object. 
--------------------------------------------------------------------------------
[[Get]] SpecOp(propertyName) → any Returns the value of the named property. 
--------------------------------------------------------------------------------
[[GetOwnProperty]] SpecOp (propertyName) → Undefined or Property Descriptor
Returns the Property Descriptor of the named own property of this object, or
undefined if absent. 
--------------------------------------------------------------------------------
[[GetProperty]] SpecOp(propertyName) → Undefined or Property Descriptor Returns
the fully populated Property Descriptor of the named property of this object, or
undefined if absent. 
--------------------------------------------------------------------------------
[[Put]] SpecOp(propertyName, any, Boolean) Sets the specified named property to
the value of the second parameter. The flag controls failure handling. 
--------------------------------------------------------------------------------
[[CanPut]] SpecOp(propertyName) → Boolean Returns a Boolean value indicating
whether a [[Put]] operation with PropertyName can be performed. 
--------------------------------------------------------------------------------
[[HasProperty]] SpecOp(propertyName) → Boolean Returns a Boolean value
indicating whether the object already has a property with the given name. 
--------------------------------------------------------------------------------
[[Delete]] SpecOp(propertyName, Boolean) → Boolean Removes the specified named
own property from the object. The flag controls failure handling. 
--------------------------------------------------------------------------------
[[DefaultValue]] SpecOp(Hint) → primitive Hint is a String. Returns a default
value for the object. 
--------------------------------------------------------------------------------
[[DefineOwnProperty]] SpecOp (propertyName, PropertyDescriptor, Boolean) →
Boolean Creates or alters the named own property to have the state described by
a Property Descriptor. The flag controls failure handling. 
--------------------------------------------------------------------------------

表8 - すべてのオブジェクトに共通の内部プロパティ
--------------------------------------------------------------------------------
内部プロパティ値の型のドメイン内容
--------------------------------------------------------------------------------
[[Prototype]] Object or Nullオブジェクトのプロトタイプです。
--------------------------------------------------------------------------------
[[Class]] Stringオブジェクトのクラス定義を示す文字列です。
--------------------------------------------------------------------------------
[[Extensible]] Booleanもしtrueならば、固有プロパティがオブジェクトに追加されてい
るかもしれません。
--------------------------------------------------------------------------------
[[Get]] SpecOp(propertyName) → any名前付きプロパティの値を返します。
--------------------------------------------------------------------------------
[[GetOwnProperty]] SpecOp (propertyName) → Undefined or Property Descriptorこの
オブジェクトの名前付き固有プロパティのプロパティ記述子を返します。オブジェクト固
有のものがなければundefinedを返します。
--------------------------------------------------------------------------------
[[GetProperty]] SpecOp(propertyName) → Undefined or Property Descriptorこのオブ
ジェクトの完全実装された名前付きプロパティのプロパティ記述子を返します。プロパ
ティがなければundefinedを返します。
--------------------------------------------------------------------------------
[[Put]] SpecOp(propertyName, any, Boolean)指定された名前付きプロパティを第二引数
の値に設定します。フラグで設定失敗時の処理を制御します。
--------------------------------------------------------------------------------
[[CanPut]] SpecOp(propertyName) → Boolean PropertyNameで[[Put]]の操作が実施でき
るかどうかを示すBoolean値を返します。
--------------------------------------------------------------------------------
[[HasProperty]] SpecOp(propertyName) → Boolean与えられた名前のプロパティをオブ
ジェクトが既に持っているかどうかを示すBoolean値を返します。
--------------------------------------------------------------------------------
[[Delete]] SpecOp(propertyName, Boolean) → Booleanオブジェクトから与えられた名前
の固有プロパティを削除します。フラグで削除失敗時の処理を制御します。
--------------------------------------------------------------------------------
[[DefaultValue]] SpecOp(Hint) → primitiveヒントは文字列です。オブジェクトの初期
値を返します。
--------------------------------------------------------------------------------
[[DefineOwnProperty]] SpecOp (propertyName, PropertyDescriptor, Boolean) →
Booleanプロパティ記述子によって述べられた状態を名前付きの固有プロパティが持つよ
うに作成もしくは変更します。フラグで作成変更失敗時の処理を制御します。
--------------------------------------------------------------------------------


Every object (including host objects) must implement all of the internal
properties listed in Table 8. However, the [[DefaultValue]] internal method may,
for some objects, simply throw a TypeError exception. 

(ホストオブジェクトを含む)すべてのオブジェクトは表8で示された内部プロパティのす
べてを実装しなければいけません。ただし、いくつかのオブジェクトにとっては、
[[DefaultValue]]内部メソッドは単にTypeErrorをスローするだけでしょう。


All objects have an internal property called [[Prototype]]. The value of this
property is either null or an object and is used for implementing inheritance.
Whether or not a native object can have a host object as its [[Prototype]]
depends on the implementation. Every [[Prototype]] chain must have finite length
(that is, starting from any object, recursively accessing the [[Prototype]]
internal property must eventually lead to a null value). Named data properties
of the [[Prototype]] object are inherited (are visible as properties of the
child object) for the purposes of get access, but not for put access. Named
accessor properties are inherited for both get access and put access. 

すべてのオブジェクトは[[Prototype]]と呼ばれる内部プロパティを持っています。この
プロパティの値はnullもしくはあるオブジェクトであり、継承を実装するために使用され
ます。ネイティブオブジェクトがホストオブジェクトを[[Prototype]]として持てるかど
うかは実装に掛かっています。すべての[[Prototype]]チェーンは有限の長さです(つま
り、あるオブジェクトから始まる[[Prototype]]内部プロパティの再帰的な参照は、最終
的にはnull値へと通じなければいけません)。[[Prototype]]オブジェクトの名前付けされ
たデータプロパティは、参照のために継承される(子供のオブジェクトのプロパティとし
て見える)のであり、更新のためではありません。名前付きアクセサプロパティは参照と
更新の両方のために継承されます。


Every ECMAScript object has a Boolean-valued [[Extensible]] internal property
that controls whether or not named properties may be added to the object. If the
value of the [[Extensible]] internal property is false then additional named
properties may not be added to the object. In addition, if [[Extensible]] is
false the value of the [[Class]] and [[Prototype]] internal properties of the
object may not be modified. Once the value of an [[Extensible]] internal
property has been set to false it may not be subsequently changed to true. 

すべてのECMAScriptオブジェクトも、オブジェクトに名前付きプロパティを追加できるか
どうかを制御するBoolean値の[[Extensible]]内部プロパティを持っています。もし
[[Extensible]]内部プロパティの値がfalseの場合、オブジェクトには追加の名前付きプ
ロパティを追加することはできません。更に、もし[[Extensible]]がfalseならば、オブ
ジェクトの[[Class]]および[[Prototype]]内部プロパティは変更できません。一旦、
[[Extensible]]内部プロパティの値をfalseに設定したら、後でtrueに変更することはで
きません。


NOTE This specification defines no ECMAScript language operators or built-in
functions that permit a program to modify an object's [[Class]] or [[Prototype]]
internal properties or to change the value of [[Extensible]] from false to true.


注意：この仕様は、オブジェクトの[[Class]]および[[Prototype]]内部プロパティを変更
したり、[[Extensible]]の値をfalseからtrueへ変更するようにプログラムすることがで
きるECMAScriptの演算子や組み込み関数が存在しないことを定義しています。


Implementation specific extensions that modify [[Class]], [[Prototype]] or
[[Extensible]] must not violate the invariants defined in the preceding
paragraph. 

[[Class]]、[[Prototype]]、[[Extensible]]を変更するような実装に依存した拡張は、前
の段落で定義された不変性に違反してはいけません。


The value of the [[Class]] internal property is defined by this specification
for every kind of built-in object. The value of the [[Class]] internal property
of a host object may be any String value except one of "Arguments", "Array",
"Boolean", "Date", "Error", "Function", "JSON", "Math", "Number", "Object",
"RegExp", and "String". The value of a [[Class]] internal property is used
internally to distinguish different kinds of objects. Note that this
specification does not provide any means for a program to access that value
except through Object.prototype.toString (see 15.2.4.2). 

すべての組み込みオブジェクトの[[Class]]内部プロパティの値は、この仕様で定義され
ています。ホストオブジェクトの[[Class]]内部プロパティの値は、以下のもの以外の何
らかの文字列です。
- "Arguments"
- "Array"
- "Boolean"
- "Date"
- "Error"
- "Function"
- "JSON"
- "Math"
- "Number"
- "Object"
- "RegExp"
- "String" [[Class]]内部プロパティの値は、内部的にオブジェクトの種類を区別するた
  めに使用されます。この仕様は、Obuject.prototype.toString(15.2.4.2)を除いて、こ
  の値にアクセスするプログラムにとっては何の意味も持たない点に注意してください。


Unless otherwise specified, the common internal methods of native ECMAScript
objects behave as described in 8.12. Array objects have a slightly different
implementation of the [[DefineOwnProperty]] internal method (see 15.4.5.1) and
String objects have a slightly different implementation of the
[[GetOwnProperty]] internal method (see 15.5.5.2). Arguments objects (10.6) have
different implementations of [[Get]], [[GetOwnProperty]], [[DefineOwnProperty]],
and [[Delete]]. Function objects (15.3) have a different implementation of
[[Get]]. 

他に示されない限り、ネイティブなECMAScriptのオブジェクトの共通の内部メソッドは、
8.12で述べられているように振る舞います。Arrayオブジェクトは[[DefineOwnProperty]]
内部メソッド(15.4.5.1)とは少し異なる実装ですし、Stringオブジェクトは
[[GetOwnProperty]]内部メソッド(15.5.5.2)とは少し異なります。Argumentsオブジェク
ト(10.6)は[[Get]]、[[GetOwnProperty]]、[[DefineOwnProperty]]、[[Delete]]とは異な
ります。Functionオブジェクト(15.3)も[[Get]]とは異なります。


Host objects may implement these internal methods in any manner unless specified
otherwise; for example, one possibility is that [[Get]] and [[Put]] for a
particular host object indeed fetch and store property values but
[[HasProperty]] always generates false. However, if any specified manipulation
of a host object's internal properties is not supported by an implementation,
that manipulation must throw a TypeError exception when attempted. 

他に示されていなければ、ホストオブジェクトはこれらの内部メソッドをどんな方法でも
実装するでしょう。例えば、ひとつの可能性として、あるホストオブジェクトについて
[[Get]]と[[Put]]は実際にプロパティをfetchしstoreしますが、[[HasProperty]]につい
てはいつもfalseを返すかもしれません。しかし、もしホストオブジェクトの内部プロパ
ティで示された操作が実装でサポートされていなければ、その操作が試みられた時は
TypeErrorをスローしなければなりません。


The [[GetOwnProperty]] internal method of a host object must conform to the
following invariants for each property of the host object: 

ホストオブジェクトの[[GetOwnProperty]]内部メソッドは、ホストオブジェクトのどのプ
ロパティについても以下の不変性を満たさなければなりません。


- If a property is described as a data property and it may return different
  values over time, then either or both of the [[Writable]] and [[Configurable]
  attributes must be true even if no mechanism to change the value is exposed
  via the other internal methods. 
- If a property is described as a data property and its [[Writable]] and
  [[Configurable]] are both false, then the SameValue (according to 9.12) must
  be returned for the [[Value]] attribute of the property on all calls to
  [[GetOwnProperty]]. 
- If the attributes other than [[Writable]] may change over time or if the
  property might disappear, then the [[Configurable]] attribute must be true. 
- If the [[Writable]] attribute may change from false to true, then the
  [[Configurable]] attribute must be true. 
- If the value of the host object's [[Extensible]] internal property is has been
  observed by ECMAScript code to be false, then if a call to [[GetOwnProperty]]
  describes a property as non-existent all subsequent calls must also describe
  that property as non-existent. 

- もしプロパティがデータプロパティであり、時に応じて異なる値を返すのであれば、値
  を変更する仕組みが他の内部メソッドを通して用意されていない限り[[Writable]]と
  [[Configurable]]属性のどちらか、または、両方はtrueでなければなりません。
- もしプロパティかデータプロパティであり、[[Writable]]と[[Configurable]]が両方と
  もfalseならば、[[GetOwnProperty]]のすべての呼び出しにおいてプロパティの
  [[Value]]属性としてSameValue(9.12)が返されなければなりません。
- もし[[Writable]]以外の属性が時とともに変化したり、プロパティが無くなったりする
  のであれば、[[Configurable]]属性はtrueでなければなりません。
- もし[[Writable]]属性がfalseからtrueに変化するのであれば、[[Configurable]]は
  trueでなければなりません。
- もしホストオブジェクトの[[Extensible]]内部プロパティの値がECMAScriptのコードに
  よってfalseになることがあり、[[GetOwnProperty]]の呼び出し結果でプロパティが存
  在しないとされたならば、以降の呼び出しでもプロパティが存在しないとされなければ
  なりません。


The [[DefineOwnProperty]] internal method of a host object must not permit the
addition of a new property to a host object if the [[Extensible]] internal
property of that host object has been observed by ECMAScript code to be false. 

ホストオブジェクトの[[DefineOwnProperty]]内部メソッドは、ホストオブジェクトの
[[Extensible]]内部プロパティがECMAScriptのコードによってfalseになることがあれ
ば、ホストオブジェクトに新しいプロパティの追加を許してはいけません。


If the [[Extensible]] internal property of that host object has been observed by
ECMAScript code to be false then it must not subsequently become true. 

もしホストオブジェクトのコードに[[Extensible]]内部プロパティがECMAScriptのコード
によってfalseになることがあれば、それ以降trueになることはできません。


Table 9 - Internal Properties Only Defined for Some Objects 
--------------------------------------------------------------------------------
Internal Property Value Type Domain Description 
--------------------------------------------------------------------------------
[[PrimitiveValue]] primitive Internal state information associated with this
object. Of the standard built-in ECMAScript objects, only Boolean, Date, Number,
and String objects implement [[PrimitiveValue]]. 
--------------------------------------------------------------------------------
[[Construct]] SpecOp(a List of any) → Object Creates an object. Invoked via the
new operator. The arguments to the SpecOp are the arguments passed to the new
operator. Objects that implement this internal method are called constructors. 
--------------------------------------------------------------------------------
[[Call]] SpecOp(any, a List of any) → any or Reference Executes code associated
with the object. Invoked via a function call expression. The arguments to the
SpecOp are a this object and a list containing the arguments passed to the
function call expression. Objects that implement this internal method are
callable. Only callable objects that are host objects may return Reference
values. 
--------------------------------------------------------------------------------
[[HasInstance]] SpecOp(any) → Boolean Returns a Boolean value indicating whether
the argument is likely an Object that was constructed by this object. Of the
standard built-in ECMAScript objects, only Function objects implement
[[HasInstance]]. 
--------------------------------------------------------------------------------
[[Scope]] Lexical Environment A lexical environment that defines the environment
in which a Function object is executed. Of the standard built-in ECMAScript
objects, only Function objects implement 
--------------------------------------------------------------------------------
[[Scope]].[[FormalParameters]] List of Strings A possibly empty List containing
the identifier Strings of a Function's FormalParameterList. Of the standard
built-in ECMAScript objects, only Function objects implement 
--------------------------------------------------------------------------------
[[FormalParameterList]]. [[Code]] ECMAScript code The ECMAScript code of a
function. Of the standard built-in ECMAScript objects, only Function objects
implement 
--------------------------------------------------------------------------------
[[Code]].[[TargetFunction]] Object The target function of a function object
created using the standard built-in Function.prototype.bind method. Only
ECMAScript objects created using Function.prototype.bind have a
[[TargetFunction]] internal property. 
--------------------------------------------------------------------------------
[[BoundThis]] any The pre-bound this value of a function Object created using
the standard built-in Function.prototype.bind method. Only ECMAScript objects
created using Function.prototype.bind have a [[BoundThis]] internal property. 
--------------------------------------------------------------------------------
[[BoundArguments]] List of any The pre-bound argument values of a function
Object created using the standard built-in Function.prototype.bind method. Only
ECMAScript objects created using Function.prototype.bind have a
[[BoundArguments]] internal property. 
--------------------------------------------------------------------------------
[[Match]] SpecOp(String, index) → MatchResult Tests for a regular expression
match and returns a MatchResult value (see 15.10.2.1). Of the standard built-in
ECMAScript objects, only RegExp objects implement 
--------------------------------------------------------------------------------
[[Match]].[[ParameterMap]] Object Provides a mapping between the properties of
an arguments object (see 10.6) and the formal parameters of the associated
function. Only ECMAScript objects that are arguments objects have a
[[ParameterMap]] internal property. 
--------------------------------------------------------------------------------

表9 - 特定のオブジェクトでだけ定義されている内部プロパティ
--------------------------------------------------------------------------------
内部プロパティ値の型のドメイン内容
--------------------------------------------------------------------------------
[[PrimitiveValue]] primitiveオブジェクトに関連した内部状態の情報です。標準の組み
込みECMAScriptのオブジェクトのBoolean, Date, Number, Stringオブジェクトが
[[PrimitiveValue]]を実装しています。
--------------------------------------------------------------------------------
[[Construct]] SpecOp(a List of any) → Objectオブジェクトを作成します。new演算子
を通して呼び出されます。SpecOp引数にはnew演算子へ渡される引数です。この内部メ
ソッドを実装するオブジェクトはコンストラクタと呼ばれます。
--------------------------------------------------------------------------------
[[Call]] SpecOp(any, a List of any) → any or Referenceオブジェクトに関連した実行
コードです。call式を通して呼び出されます。SpecOp引数はこのオブジェクトと関数呼び
出しの式へ渡される引数が含まれたリストです。この内部メソッドを実装したオブジェク
トは呼び出し可能と呼ばれます。ホストオブジェクトである呼び出し可能なオブジェクト
は参照値を返します。
--------------------------------------------------------------------------------
[[HasInstance]] SpecOp(any) → Boolean引数がこのオブジェクトによって作成されたオ
ブジェクトであるかどうかを示すBoolean値を返します。標準の組み込みECMAScriptオブ
ジェクトのFunctionオブジェクトだけが[[HasInstance]]を実装しています。
--------------------------------------------------------------------------------
[[Scope]] Lexical Environment Functionオブジェクトが実行される環境を定義するレキ
シカル環境です。標準の組み込みECMAScriptオブジェクトのFunctionオブジェクトだけが
[[Scope]]を実装しています。
--------------------------------------------------------------------------------
[[FormalParameters]] List of Strings関数のFormalParameterListの識別子の文字列を
含む空であることも可能なリストです。標準の組み込みECMAScriptオブジェクトの
Functionオブジェクトだけが[[FormalParameterList]]を実装しています。
--------------------------------------------------------------------------------
[[Code]] ECMAScript code関数のECMAScriptコードです。標準の組み込みECMAScriptオブ
ジェクトのFunctionオブジェクトだけが[[Code]]を実装しています。
--------------------------------------------------------------------------------
[[TargetFunction]] Object標準の組み込みのFunction.prototype.bindメソッドを使って
作られた関数オブジェクトの対象の関数です。Function.prototype.bindを使って作られ
たECMAScriptオブジェクトだけが[[TargetFunction]]内部プロパティを持っています。
--------------------------------------------------------------------------------
[[BoundThis]] any標準の組み込みのFunction.prototype.bindメソッドを使って作られた
関数オブジェクトの前に設定されていた値です。
--------------------------------------------------------------------------------
[[BoundArguments]] List of any標準の組み込みのFunction.prototype.bindメソッドを
使って作られた関数オブジェクトの前に設定されていた引数の値です。
Function.prototype.bindを使って作られたECMAScriptオブジェクトだけが
[[BoundArguments]]内部プロパティを持っています。
--------------------------------------------------------------------------------
[[Match]] SpecOp(String, index) → MatchResult正規表現のマッチをテストし、
MatchResultの値(15.10.2.1)を返します。標準の組み込みのECMAScriptオブジェクトの
RegExpオブジェクトだけが[[Match]]を実装しています。
--------------------------------------------------------------------------------
[[ParameterMap]] Object引数オブジェクト(10.6)のプロパティと関連付けられた関数の
仮引数とのマッピングです。引数オブジェクトであるECMAScriptオブジェクトだけが
[[ParameterMap]]内部プロパティを持ちます。
--------------------------------------------------------------------------------


* 8.7 The Reference Specification Type 

* 8.7 参照型


The Reference type is used to explain the behaviour of such operators as delete,
typeof, and the assignment operators. For example, the left-hand operand of an
assignment is expected to produce a reference. The behaviour of assignment
could, instead, be explained entirely in terms of a case analysis on the
syntactic form of the left-hand operand of an assignment operator, but for one
difficulty: function calls are permitted to return references. This possibility
is admitted purely for the sake of host objects. No built-in ECMAScript function
defined by this specification returns a reference and there is no provision for
a user-defined function to return a reference. (Another reason not to use a
syntactic case analysis is that it would be lengthy and awkward, affecting many
parts of the specification.)

参照型は、delete、typeof、代入演算子といった演算子の振る舞いを説明するために使わ
れます。例えば、代入演算子の左辺のオペランドでは参照を生成することが期待されてい
ます。代入の振る舞いは代入演算子の左辺のオペランドの構文形式をケース分析すること
によって完全に説明することもできますが、ひとつ難しいことがあります。参照を返す関
数呼び出しが許されていることです。この可能性は純粋にホスオブジェクトのために認め
られています。この仕様では参照を返すような組み込みECMAScript関数は定義されていま
せんし、ユーザ定義関数が必ず参照を返すという決まりはありません(これ以外に構文の
ケース分析を使わない理由は、仕様の多くの箇所に長ったらしく無様な影響を与えるため
です)。


A Reference is a resolved name binding. A Reference consists of three
components, the base value, the referenced name and the Boolean valued strict
reference flag. The base value is either undefined, an Object, a Boolean, a
String, a Number, or an environment record (10.2.1). A base value of undefined
indicates that the reference could not be resolved to a binding. The referenced
name is a String. The following abstract operations are used in this
specification to access the components of references: 

参照は名前のバインディングで解決されます。参照は3つのコンポーネント、既定値、被
参照名、boolean値であるstrict参照フラグから構成されます。既定値は、undefined、オ
ブジェクト、Boolean、文字列、数値もしくは環境レコードのいずれかです。既定値が
undefinedであることは参照がバインディングで解決されないことを示しています。参照
名は文字列です。以下の抽象操作はこの仕様において参照のコンポーネントにアクセスす
るために使われます。


- GetBase(V). Returns the base value component of the reference V. 
- GetReferencedName(V). Returns the referenced name component of the reference
  V. 
- IsStrictReference(V). Returns the strict reference component of the reference
  V. 
- HasPrimitiveBase(V). Returns true if the base value is a Boolean, String, or
  Number. 
- IsPropertyReference(V). Returns true if either the base value is an object or
  HasPrimitiveBase(V) is true; otherwise returns false. 
- IsUnresolvableReference(V). Returns true if the base value is undefined and
  false otherwise. 

- GetBase(V) 参照Vの規定値コンポーネントを返します。
- GetReferencedName(V) 参照Vの参照名コンポーネントを返します。
- IsStrictReference(V) 参照Vのstrict参照コンポーネントを返します。
- HasPrimitiveBase(V) 規定値がBoolean, String, Numberならばtrueを返します。
- IsPropertyReference(V) 規定値がオブジェクトもしくはHasPrimitiveBase(V)がtrueな
  らtrueを返します。それ以外はfalseを返します。
- IsUnresolvableReference(V) 規定値がundefinedならばtrueを返します。それ以外は
  falseを返します。【訳注】抽象操作とコンポーネント
  --------------------------- -------------------------
抽象操作                    コンポーネント
--------------------------- -------------------------
GetBase(V)                  the base value GetReferencedName(V)        the
referenced name IsStrictReference(V)        the strict reference flag
--------------------------- -------------------------
【訳注】抽象操作と規定値
--------------------------- ---------------------------------------
抽象操作                    規定値
                            ----------- ------- ------- -----------
                            undefined   object  boolean environment
                                                string
                                                number
--------------------------- ----------- ------- ------- ------------
IsUnresolvableReference(V)  true        false  false    false
IsPropertyReference(V)      false       true   true     false
HasPrimitiveBase(V)         false       false  true     false
--------------------------- ----------- ------- ------- ------------


The following abstract operations are used in this specification to operate on
references: 

この仕様において、以下の抽象操作は参照を操作するために使われます。


* 8.7.1 GetValue ( V )


1. If Type(V) is not Reference, return V. 
2. Let base be the result of calling GetBase(V). 
3. If IsUnresolvableReference(V), throw a ReferenceError exception. 
4. If IsPropertyReference(V), then a. If HasPrimitiveBase(V) is false, then let
   get be the [[Get]] internal method of base, otherwise let get be the special
   [[Get]] internal method defined below. b. Return the result of calling the
   get internal method using base as its this value, and passing
   GetReferencedName(V) for the argument. 
5. Else, base must be an environment record. a. Return the result of calling the
   GetBindingValue (see 10.2.1) concrete method of base passing
   GetReferencedName(V) and IsStrictReference(V) as arguments. 

1. Type(V)が参照でなければ、Vそのものを返します。
2. GetBase(V)の呼び出し結果をbaseとします。
3. もしIsUnresolvableReference(V)ならば、ReferenceErrorをスローします。
4. もしIsPropertyReference(V)ならば... a. もしHasPrimitiveBase(V)がfalseならば、
   getをbaseの[[Get]]内部メソッドにします。そうでなければ、getは以下で定義する特
   別な[[Get]]内部メソッドにします。b. this値としてbaseを使いget内部メソッドを呼
   び出した結果を返します。引数としてGetReferencedName(V)を渡します。
5. そうでなければ、baseは環境レコードである筈です。a. 引数として
   GetReferencedName(V)とIsStrictReference(V)を与えたbaseの
   GetBindingValue(10.2.1)の具象メソッドの呼び出しの結果を返します。


The following [[Get]] internal method is used by GetValue when V is a property
reference with a primitive base value. It is called using base as its this value
and with property P as its argument. The following steps are taken: 

以下の[[Get]]内部メソッドは、Vがプリミティブ値であるプロパティへの参照である場合
にGetValueによって使われます。this値としてbaseを使い、プロパティPを引数として呼
び出されます。以下のステップで行われます。


1. Let O be ToObject(base). 
2. Let desc be the result of calling the [[GetProperty]] internal method of O
   with property name P. 
3. If desc is undefined, return undefined. 
4. If IsDataDescriptor(desc) is true, return desc.[[Value]]. 
5. Otherwise, IsAccessorDescriptor(desc) must be true so, let getter be
   desc.[[Get]]. 
6. If getter is undefined, return undefined. 
7. Return the result calling the [[Call]] internal method of getter providing
   base as the this value and providing no arguments. 

1. ToObject(base)の呼び出し結果をOとします。
2. 名前がPであるプロパティを引数としてOの[[GetProperty]]内部メソッドの呼び出し結
   果をdescとします。
3. もしdescがundefinedならば、undefinedを返します。
4. もしIsDataDescriptor(desc)がtrueならば、desc.[[Value]]を返します。
5. そうでなければ、IsAccessorDescriptor(desc)はtrudeでなければなりません。
   desc.[[Get]]をgetterにします。
6. もしgetterがundefinedならば、undefinedを返します。
7. this値としてbaseを使い、引数無しでgetterの[[Call]]内部メソッドを呼び出した結
   果を返します。


NOTE The object that may be created in step 1 is not accessible outside of the
above method. An implementation might choose to avoid the actual creation of the
object. The only situation where such an actual property access that uses this
internal method can have visible effect is when it invokes an accessor function.


注意：ステップ１で作られたオブジェクトは上記のメソッドの外部からはアクセスするこ
とはできません。実装によっては実際のオブジェクトの生成はしないようにしているかも
しれません。この内部メソッドを使った実際のプロパティへのアクセスが目に見える影響
を与える状況というのは、アクセサ関数を呼び出すときだけです。


* 8.7.2 PutValue ( V, W )


1. If Type(V) is not Reference, throw a ReferenceError exception. 
2. Let base be the result of calling GetBase(V). 
3. If IsUnresolvableReference(V), then a. If IsStrictReference(V) is true, then
   i. Throw ReferenceError exception. b. Call the [[Put]] internal method of the
   global object, passing GetReferencedName(V) for the property name, W for the
   value, and false for the Throw flag. 
4. Else if IsPropertyReference(V), then a. If HasPrimitiveBase(V) is false, then
   let put be the [[Put]] internal method of base, otherwise let put be the
   special [[Put]] internal method defined below. b. Call the put internal
   method using base as its this value, and passing GetReferencedName(V) for the
   property name, W for the value, and IsStrictReference(V) for the Throw flag. 
5. Else base must be a reference whose base is an environment record. So, a.
   Call the SetMutableBinding (10.2.1) concrete method of base, passing
   GetReferencedName(V), W, and IsStrictReference(V) as arguments. 
6. Return.

1. Type(V)が参照でなければ、ReferenceErrorをスローします。
2. GetBase(V)の呼び出し結果をbaseとします。
3. もしIsUnresolvableReference(V)ならば... a. もしIsStrictReference(V)がtrueなら
   ば... i. ReferenceErrorをスローします。b. そうでなければ、this値としてbase、
   プロパティ名としてGetReferencedName(V)、値としてW、Throwフラグとしてfalseを
   使って、Globalオブジェクトの[[Put]]内部メソッドを呼び出します。
4. そうでなくIsPropertyReference(V)ならば... a. もしHasPrimitiveBase(V)がfalseな
   らば、putをbaseの[[Put]]内部メソッドにします。そうでなければ、putは以下で定義
   する特別な[[Put]]内部メソッドにします。b. this値としてbase、プロパティ名とし
   てGetReferencedName(V)、値としてW、Throwフラグとしてfalseを使って、put内部メ
   ソッドを呼び出します。
5. そうでなければ、baseが環境レコードである参照である筈です。ならば... a.
   GetReferencedName(V), W, IsStrictReference(V)を引数として、baseの
   SetMutableBinding(10.2.1)具象メソッドを呼び出します。


The following [[Put]] internal method is used by PutValue when V is a property
reference with a primitive base value. It is called using base as its this value
and with property P, value W, and Boolean flag Throw as arguments. The following
steps are taken: 

以下の[[Put]]内部メソッドはVがプリミティブ型の既定値であるプロパティ参照である場
合にPutValueによって使われます。this値としてbase、引数としてプロパティP、値W、
BooleanフラグのThrowを使って呼び出されます。以下のステップで行われます。


1. Let O be ToObject(base). 
2. If the result of calling the [[CanPut]] internal method of O with argument P
   is false, then a. If Throw is true, then throw a TypeError exception. b. Else
   return. 
3. Let ownDesc be the result of calling the [[GetOwnProperty]] internal method
   of O with argument P. 
4. If IsDataDescriptor(ownDesc) is true, then a. If Throw is true, then throw a
   TypeError exception. b. Else Return. 
5. Let desc be the result of calling the [[GetProperty]] internal method of O
   with argument P. This may be either an own or inherited accessor property
   descriptor or an inherited data property descriptor. 
6. If IsAccessorDescriptor(desc) is true, then a. Let setter be desc.[[Set]]
   which cannot be undefined. b. Call the [[Call]] internal method of setter
   providing base as the this value and an argument list containing only W. 
7. Else, this is a request to create an own property on the transient object O
   a. If Throw is true, then throw a TypeError exception. 
8. Return. 

1. ToObject(base)の呼び出し結果をOとします。
2. もしOの[[CanPut]]内部メソッドを引数Pで呼び出した結果がfalseならば... a. もし
   Throwがtrueならば、TypeErrorをスローします。b. そうでなければ、そのまま終わり
   ます。
3. Oの[[GetOwnProperty]]内部メソッドを引数Pで呼び出した結果をownDescとします。
4. もしIsDataDescriptor(ownDesc)がtrueならば... a. もしThrowがtrueならば、
   TypeErrorをスローします。b. そうでなければ、そのまま終わります。
5. Oの[[GetProperty]]内部メソッドを引数Pで呼び出した結果をdescとします。これはそ
   れ固有プロパティか、継承されたアクセサプロパティ記述子か、継承されたデータプ
   ロパティ記述子のいずれかになります。
6. もしIsAccessorDescriptor(desc)がtrueならば... a  undefinedではない筈の
   desc.[[Set]]をsettterとします。b. this値としてbase、引数リストにはWだけを含む
   ようにして、setterの[[Call]]内部メソッドを呼び出します。
7. そうでなければ、一時オブジェクトにおける固有プロパティを作成するための要求で
   す。a もしThrowがtrueならば、TypeErrorをスローします。
8. 終わります。


NOTE The object that may be created in step 1 is not accessible outside of the
above method. An implementation might choose to avoid the actual creation of
that transient object. The only situations where such an actual property
assignment that uses this internal method can have visible effect are when it
either invokes an accessor function or is in violation of a Throw predicated
error check. When Throw is true any property assignment that would create a new
property on the transient object throws an error. 

注意：ステップ１で作られたオブジェクトは上記のメソッドの外部からはアクセスするこ
とはできません。実装によっては実際の一時オブジェクトの生成はしないようにしている
かもしれません。この内部メソッドを使った実際のプロパティへのアクセスが目に見える
影響を与える状況というのは、アクセサ関数を呼び出すときだけ、もしくは、エラー
チェックを前提としたThrowの違反があったときだけです。Throwがtrueならば、一時オブ
ジェクトにおける新しいプロパティの作成によるプロパティの代入はエラーをスローしま
す。


* 8.8 The List Specification Type 

* 8.8 リスト型


The List type is used to explain the evaluation of argument lists (see 11.2.4)
in new expressions, in function calls, and in other algorithms where a simple
list of values is needed. Values of the List type are simply ordered sequences
of values. These sequences may be of any length. 

リスト型は、new式、関数呼び出し、値の単純なリストが必要なその他のアルゴリズムで
において引数リスト(11.2.4)を評価方法を説明するときに使われます。リスト型の値は、
単純に順序付けた値の並びです。これらの並びはどんな長さにもなります。


* 8.9 The Completion Specification Type 

* 8.9 補完型


The Completion type is used to explain the behaviour of statements (break,
continue, return and throw) that perform nonlocal transfers of control. Values
of the Completion type are triples of the form (type, value, target), where type
is one of normal, break, continue, return, or throw, value is any ECMAScript
language value or empty, and target is any ECMAScript identifier or empty. 

補完型は制御の非局所的な転送を行うようなステートメント(break, continue, return,
throw)の振る舞いを説明するのに使われます。補完型の値は(型、値、対象)という形式の
三項組となります。型はnormal, break, continue, return, throwのいずれかであり、値
はECMAScript言語の値もしくは空であり、対象はECMAScriptの識別子もしくは空です。


The term “abrupt completion” refers to any completion with a type other than
normal. 

"不測の補完"という用語は、normal以外の型による補完を指し示します。


* 8.10 The Property Descriptor and Property Identifier Specification Types 

* 8.10 プロパティ記述子型とプロパティ識別子型


The Property Descriptor type is used to explain the manipulation and reification
of named property attributes. Values of the Property Descriptor type are records
composed of named fields where each field's name is an attribute name and its
value is a corresponding attribute value as specified in 8.6.1. In addition, any
field may be present or absent. 

プロパティ記述子型は、名前付きプロパティの属性の操作と具体化を説明するのに使われ
ます。プロパティ記述子型の値は、8.6.1で示された属性の名前のフィールド名と、属性
の値に相当するフィールド値から構成されるレコードです。また、いずれかのフィールド
が抜けていることがあります。


Property Descriptor values may be further classified as data property
descriptors and accessor property descriptors based upon the existence or use of
certain fields. A data property descriptor is one that includes any fields named
either [[Value]] or [[Writable]]. An accessor property descriptor is one that
includes any fields named either [[Get]] or [[Set]]. Any property descriptor may
have fields named [[Enumerable]] and [[Configurable]]. A Property Descriptor
value may not be both a data property descriptor and an accessor property
descriptor; however, it may be neither. A generic property descriptor is a
Property Descriptor value that is neither a data property descriptor nor an
accessor property descriptor. A fully populated property descriptor is one that
is either an accessor property descriptor or a data property descriptor and that
has all of the fields that correspond to the property attributes defined in
either 8.6.1 Table 5 or Table 6. 

更に、プロパティ記述子型の値は特定のフィールドの有無や使い方によって、データプロ
パティ記述子とアクセサプロパティ記述子に分類されます。データプロパティ記述子は、
[[Value]]もしくは[[Writable]]という名前のフィールドを含むものです。アクセサプロ
パティ記述子は[[Get]]もしくは[[Set]]という名前のフィールドを持つものです。どのプ
ロパティ記述子も[[Enumerable]]や[[Configurable]]という名前を付けられたフィールド
を持ち得ます。プロパティ記述子型の値は、データプロパティ記述子とアクセサプロパ
ティ記述子の両方ではありません。しかしながら、どちらもでもないでしょう。ジェネ
リックなプロパティ記述子型の値は、データプロパティ記述子でもアクセサプロパティ記
述子でもありません。完全実装されたプロパテ記述子はアクセサプロパティ記述子もしく
はデータプロパティ記述子であり、8.6.1の表5もしくは表6のどちらかで定義されたプロ
パティ属性に相当するすべてのフィールドを持っています。


For notational convenience within this specification, an object literal-like
syntax can be used to define a property descriptor value. For example, Property
Descriptor {[[Value]]: 42, [[Writable]]: false, [[Configurable]]: true} defines
a data property descriptor. Field name order is not significant. Any fields that
are not explicitly listed are considered to be absent. 

この仕様の表記の都合上、プロパティ記述子の値を定義するのにオブジェクトのリテラル
表現が用いられています。例えば、プロパティ記述子 {[[Value]]: 42, [[Writable]]:
false, [[Configurable]]: true } はデータプロパティ記述子を定義しています。フィー
ルド名の順番は重要ではありません。明示的にリストされていないフィールドはすべて抜
けていると見なされます。


In specification text and algorithms, dot notation may be used to refer to a
specific field of a Property Descriptor. For example, if D is a property
descriptor then D.[[Value]] is shorthand for “the field of D named [[Value]]”. 

仕様上のテキストとアルゴリズムにおいて、ドット記法はプロパティ記述子の特定の
フィールドを参照するのに用いられます。例えば、Dがプロパティ記述子ならば、
D.[[Value]]は"Dの[[Value]]と名前付けられたフィールド"の簡易表記です。


The Property Identifier type is used to associate a property name with a
Property Descriptor. Values of the Property Identifier type are pairs of the
form (name, descriptor), where name is a String and descriptor is a Property
Descriptor value. 

プロパティ識別子型はプロパティ記述子にプロパティ名を関連付けるのに用いられます。
プロパティ識別子型の値は(名前、記述子)という二項組になります。名前は文字列、記述
子はプロパティ記述子型の値です。


The following abstract operations are used in this specification to operate upon
Property Descriptor values: 

この仕様において、以下の抽象操作はプロパティ記述子型の値を操作するために使われま
す。


* 8.10.1 IsAccessorDescriptor ( Desc )


When the abstract operation IsAccessorDescriptor is called with property
descriptor Desc, the following steps are taken: 

抽象操作IsAccessorDescriptorがプロパティ記述子Descを伴って呼び出された場合には、
以下のステップで行われます。


1. If Desc is undefined, then return false. 
2. If both Desc.[[Get]] and Desc.[[Set]] are absent, then return false. 
3. Return true. 

1. もしDescがundefinedならば、falseを返します。
2. もしDesc.[[Get]]もDesc.[[Set]]も存在しなかったら、falseを返します。
3. trueを返します。


* 8.10.2 IsDataDescriptor ( Desc )


When the abstract operation IsDataDescriptor is called with property descriptor
Desc, the following steps are taken: 

抽象操作IsDataDescriptorがプロパティ記述子Descを伴って呼び出された場合には、以下
のステップで行われます。


1. If Desc is undefined, then return false. 
2. If both Desc.[[Value]] and Desc.[[Writable]] are absent, then return false. 
3. Return true. 

1. もしDescがundefinedならば、falseを返します。
2. もしDesc.[[Value]]もDesc.[[Writable]]も存在しなかったら、falseを返します。
3. trueを返します。


* 8.10.3 IsGenericDescriptor ( Desc )


When the abstract operation IsGenericDescriptor is called with property
descriptor Desc, the following steps are taken: 

抽象操作IsGenericDescriptorがプロパティ記述子Descを伴って呼び出された場合には、
以下のステップで行われます。


1. If Desc is undefined, then return false. 
2. If IsAccessorDescriptor(Desc) and IsDataDescriptor(Desc) are both false, then
   return true. 
3. Return false. 

1. もしDescがundefinedならば、falseを返します。
2. もしIsAccessorDescriptor(Desc)もIsDataDescriptor(Desc)もfalseならば、trueを返
   します。
3. falseを返します。


* 8.10.4 FromPropertyDescriptor ( Desc )


When the abstract operation FromPropertyDescriptor is called with property
descriptor Desc, the following steps are taken: 

抽象操作FromPropertyDescriptorがプロパティ記述子Descを伴って呼び出された場合に
は、以下のステップで行われます。


The following algorithm assumes that Desc is a fully populated Property
Descriptor, such as that returned from [[GetOwnProperty]] (see 8.12.1). 

以下のアルゴリズムは、[[GetOwnProperty]](8.12.1)から返された値のように、Descが完
全実装されたプロパティ記述子であることを仮定しています。


1. If Desc is undefined, then return undefined. 
2. Let obj be the result of creating a new object as if by the expression new
   Object() where Object is the standard built-in constructor with that name. 
3. If IsDataDescriptor(Desc) is true, then a. Call the [[DefineOwnProperty]]
   internal method of obj with arguments "value", Property Descriptor
   {[[Value]]: Desc.[[Value]], [[Writable]]: true, [[Enumerable]]: true,
   [[Configurable]]: true}, and false. b. Call the [[DefineOwnProperty]]
   internal method of obj with arguments "writable", Property Descriptor
   {[[Value]]: Desc.[[Writable]], [[Writable]]: true, [[Enumerable]]: true,
   [[Configurable]]: true}, and false. 
4. Else, IsAccessorDescriptor(Desc) must be true, so a. Call the
   [[DefineOwnProperty]] internal method of obj with arguments "get", Property
   Descriptor {[[Value]]: Desc.[[Get]], [[Writable]]: true, [[Enumerable]]:
   true, [[Configurable]]: true}, and false. b. Call the [[DefineOwnProperty]]
   internal method of obj with arguments "set", Property Descriptor {[[Value]]:
   Desc.[[Set]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]:
   true}, and false. 
5. Call the [[DefineOwnProperty]] internal method of obj with arguments
   "enumerable", Property Descriptor {[[Value]]: Desc.[[Enumerable]],
   [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
   
6. Call the [[DefineOwnProperty]] internal method of obj with arguments
   "configurable", Property Descriptor {[[Value]]: Desc.[[Configurable]],
   [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
   
7. Return obj. 

1. もしDescがundefinedならば、undefinedを返します。
2. Objectがその名前を持つ標準の組み込みのコンストラクタであり、new Object()とい
   う式に作られたかのようにして、新しいオブジェクトを作った結果をobjとします。
3. もしIsDataDescriptor(Desc)がtrueならば... a. objの[[DefineOwnProperty]]内部メ
   ソッドを、プロパティ名を"value"、プロパティ記述子を
    {
      [[Value]]: Desc.[[Value]], [[Writable]]: true, [[Enumerable]]: true,
      [[Configurable]]: true}、作成失敗時フラグをfalseで呼び出します。b. objの
      [[DefineOwnProperty]]内部メソッドを、プロパティ名を"writable"、プロパティ
      記述子を
    {
      [[Value]]: Desc.[[Writable]], [[Writable]]: true, [[Enumerable]]: true,
      [[Configurable]]: true}、作成失敗時フラグをfalseで呼び出します。4.そうでな
      ければ、IsAccessorDescriptor(Desc)はtrueであるので... a. objの
      [[DefineOwnProperty]]内部メソッドを、プロパティ名を"get"、プロパティ記述子
      を
    {
      [[Value]]: Desc.[[Writable]], [[Writable]]: true, [[Enumerable]]: true,
      [[Configurable]]: true}、作成失敗時フラグをfalseで呼び出します。b. objの
      [[DefineOwnProperty]]内部メソッドを、プロパティ名を"set"、プロパティ記述子
      を
    {
      [[Value]]: Desc.[[Set]], [[Writable]]: true, [[Enumerable]]: true,
      [[Configurable]]: true}、作成失敗時フラグをfalseで呼び出します。
5. objの[[DefineOwnProperty]]内部メソッドを、プロパティ名を"enumerable"、プロパ
    ティ記述子を
    {
      [[Value]]: Desc.[[Enumerable]], [[Writable]]: true, [[Enumerable]]: true,
      [[Configurable]]: true}、作成失敗時フラグをfalseで呼び出します。
6. objの[[DefineOwnProperty]]内部メソッドを、プロパティ名を"configurable"、プロ
   パティ記述子を
    {
      [[Value]]: Desc.[[Enumerable]], [[Writable]]: true, [[Enumerable]]: true,
      [[Configurable]]: true}、作成失敗時フラグをfalseで呼び出します。
7. objを返します。


* 8.10.5 ToPropertyDescriptor ( Obj )


When the abstract operation ToPropertyDescriptor is called with object Desc, the
following steps are taken: 

抽象操作ToPropertyDescriptorがオブジェクトDescで呼び出された場合には、以下のス
テップで行われます。


1. If Type(Obj) is not Object throw a TypeError exception. 
2. Let desc be the result of creating a new Property Descriptor that initially
   has no fields. 
3. If the result of calling the [[HasProperty]] internal method of Obj with
   argument "enumerable" is true, then a. Let enum be the result of calling the
   [[Get]] internal method of Obj with "enumerable". b. Set the [[Enumerable]]
   field of desc to ToBoolean(enum). 
4. If the result of calling the [[HasProperty]] internal method of Obj with
   argument "configurable" is true, then a. Let conf be the result of calling
   the [[Get]] internal method of Obj with argument "configurable". b. Set the
   [[Configurable]] field of desc to ToBoolean(conf). 
5. If the result of calling the [[HasProperty]] internal method of Obj with
   argument "value" is true, then a. Let value be the result of calling the
   [[Get]] internal method of Obj with argument “value”. b. Set the [[Value]]
   field of desc to value. 
6. If the result of calling the [[HasProperty]] internal method of Obj with
   argument "writable" is true, then a. Let writable be the result of calling
   the [[Get]] internal method of Obj with argument "writable". b. Set the
   [[Writable]] field of desc to ToBoolean(writable). 
7. If the result of calling the [[HasProperty]] internal method of Obj with
   argument "get" is true, then a. Let getter be the result of calling the
   [[Get]] internal method of Obj with argument "get". b. If IsCallable(getter)
   is false and getter is not undefined, then throw a TypeError exception. c.
   Set the [[Get]] field of desc to getter. 
8. If the result of calling the [[HasProperty]] internal method of Obj with
   argument "set" is true, then a. Let setter be the result of calling the
   [[Get]] internal method of Obj with argument "set". b. If IsCallable(setter)
   is false and setter is not undefined, then throw a TypeError exception. c.
   Set the [[Set]] field of desc to setter. 
9. If either desc.[[Get]] or desc.[[Set]] are present, then a. If either
   desc.[[Value]] or desc.[[Writable]] are present, then throw a TypeError
   exception. 
10. Return desc. 

1. もしType(Obj)がObjectでなければ、TypeErrorをスローします。
2. フィールドを持たない新しいプロパティ記述子を作った結果をdescとします。
3. もしObjの[[HasProperty]]内部メソッドを引数"enumerable"で呼び出した結果がtrue
   の場合には... a. Objの[[Get]]内部メソッドを引数"enumerable"で呼び出した結果を
   enumとします。b. descの[[Enumerable]]フィールドをToBoolean(enum)とします。
4. もしObjの[[HasProperty]]内部メソッドを引数"configurable"で呼び出した結果が
   trueの場合には... a. Objの[[Get]]内部メソッドを引数"configurable"で呼び出した
   結果をconfとします。b. descの[[Configurable]]フィールドをToBoolean(conf)とし
   ます。
5. もしObjの[[HasProperty]]内部メソッドを引数"value"で呼び出した結果がtrueの場合
   には... a. Objの[[Get]]内部メソッドを引数"value"で呼び出した結果をvalueとしま
   す。b. descの[[Value]]フィールドをvalueとします。
6. もしObjの[[HasProperty]]内部メソッドを引数"writable"で呼び出した結果がtrueの
   場合には... a. Objの[[Get]]内部メソッドを引数"writable"で呼び出した結果を
   writableとします。b. descの[[Writable]]フィールドをToBoolean(writable)としま
   す。
7. もしObjの[[HasProperty]]内部メソッドを引数"get"で呼び出した結果がtrueの場合に
   は... a. Objの[[Get]]内部メソッドを引数"get"で呼び出した結果をgetterとしま
   す。b. もしIsCallable(getter)がfalseならば、getterはundefinedとし、TypeError
   をスローします。c. descの[[Get]]フィールドをgetterとします。
8. もしObjの[[HasProperty]]内部メソッドを引数"set"で呼び出した結果がtrueの場合に
   は... a. Objの[[Get]]内部メソッドを引数"set"で呼び出した結果をsetterとしま
   す。b. もしIsCallable(setter)がfalseならば、setterはundefinedとし、TypeError
   をスローします。c. descの[[Set]]フィールドをsetterとします。
9. もしdesc.[[Get]]もしくはdesc.[[Set]]が存在した場合には... a. もし
   desc.[[Value]]もしくはdesc.[[Writable]]が存在したら、TypeErrorをスローしま
   す。
10. descを返します。


* 8.11 The Lexical Environment and Environment Record Specification Types 

* 8.11 レキシカル環境と環境レコード型


The Lexical Environment and Environment Record types are used to explain the
behaviour of name resolution in nested functions and blocks. These types and the
operations upon them are defined in Clause 10. 

レキシカル環境と環境レコード型は入れ子になった関数とブロックにおける名前解決の振
る舞いを説明するのに用いられます。これらの方は10節で定義されています。


* 8.12 Algorithms for Object Internal Methods 

* 8.12 オブジェクトの内部メソッドのアルゴリズム


In the following algorithm descriptions, assume O is a native ECMAScript object,
P is a String, Desc is a Property Description record, and Throw is a Boolean
flag. 

以降のアルゴリズムの説明において、OはネイティブなECMAScriptのオブジェクト、Pは文
字列、Descはプロパティ記述レコード、ThrowはBoolean型の値とします。


* 8.12.1 [[GetOwnProperty]] ( P )


When the [[GetOwnProperty]] internal method of O is called with property name P,
the following steps are taken: 

Oの[[GetOwnProperty]]内部メソッドがプロパティ名Pで呼び出された場合には、以下のス
テップで行われます。


1. If O doesn't have an own property with name P, return undefined. 
2. Let D be a newly created Property Descriptor with no fields. 
3. Let X be O's own property named P. 
4. If X is a data property, then a. Set D.[[Value]] to the value of X's
   [[Value]] attribute. b. Set D.[[Writable]] to the value of X's [[Writable]]
   attribute 
5. Else X is an accessor property, so a. Set D.[[Get]] to the value of X's
   [[Get]] attribute. b. Set D.[[Set]] to the value of X's [[Set]] attribute. 
6. Set D.[[Enumerable]] to the value of X's [[Enumerable]] attribute. 
7. Set D.[[Configurable]] to the value of X's [[Configurable]] attribute. 
8. Return D. 

1. もしOが固有プロパティPを持っていないならば、undefinedが返されます。
2. フィールドを持たない新しいプロパティ記述子を作りDとします。
3. OのPという名前の固有プロパティをDとします。
4. もしXがデータプロパティならば... a. D.[[Value]]をXの[[Value]]属性の値に設定し
   ます。b. D.[[Writable]]をXの[[Writable]属性の値に設定します。
5. そうでなければ、Xはアクセサプロパティなので... a. D.[[Get]]をXの[[Get]]属性の
   値に設定します。b. D.[[Set]]をXの[[Set]]属性の値に設定します。
6. D.[[Enumerable]]をXの[[Enumerable]]属性の値に設定します。
7. D.[[Configurable]]をXの[[Configurable]]属性の値に設定します。
8. Dを返します。


However, if O is a String object it has a more elaborate [[GetOwnProperty]]
internal method defined in 15.5.5.2. 

ただし、もしOがStringオブジェクトならば、15.5.5.2で定義されるより複雑な
[[GetOwnProperty]]内部メソッドになります。


* 8.12.2 [[GetProperty]] ( P )


When the [[GetProperty]] internal method of O is called with property name P,
the following steps are taken: 

Oの[[GetProperty]]内部メソッドがプロパティ名Pで呼び出された場合には、以下のス
テップで行われます。


1. Let prop be the result of calling the [[GetOwnProperty]] internal method of O
   with property name P. 
2. If prop is not undefined, return prop. 
3. Let proto be the value of the [[Prototype]] internal property of O. 
4. If proto is null, return undefined. 
5. Return the result of calling the [[GetProperty]] internal method of proto
   with argument P. 

1. Oの[[GetOwnProperty]]内部メソッドをプロパティ名Pで呼び出した結果をpropとしま
   す。
2. もしpropがundefined以外ならば、propを返します。
3. Oの[[Prototype]]内部プロパティの値をprotoとします。
4. もしprotoがnullならば、undefinedを返します。
5. protpの[[GetProperty]]内部メソッドを引数Pで呼び出した結果を返します。


* 8.12.3 [[Get]] ( P )


When the [[Get]] internal method of O is called with property name P, the
following steps are taken: 

Oの[[Get]]内部メソッドがプロパティ名Pで呼び出された場合には、以下のステップで行
われます。


8. Let desc be the result of calling the [[GetProperty]] internal method of O
   with property name P. 
9. If desc is undefined, return undefined. 
10. If IsDataDescriptor(desc) is true, return desc.[[Value]]. 
11. Otherwise, IsAccessorDescriptor(desc) must be true so, let getter be
    desc.[[Get]]. 
12. If getter is undefined, return undefined. 
13. Return the result calling the [[Call]] internal method of getter providing O
    as the this value and providing no arguments. 

8. Oの[[GetProperty]]内部メソッドをプロパティ名Pで呼び出した結果をdescとします。
   9 もしdescがundefinedならば、undefinedを返します。
10. もしIsDataDescriptor(desc)がtrueならば、desc.[[Value]]を返します。
11. そうでなければ、IsAccessorDescriptor(desc)がtrueの筈なので、getterを
    desc.[[Get]]とします。
12. もしgetterがundefinedならば、undefinedを返します。
13. this値としてOを使い、引数無しで、getterの[[Call]]内部メソッドを呼び出した結
    果を返します。


* 8.12.4 [[CanPut]] ( P )


When the [[CanPut]] internal method of O is called with property name P, the
following steps are taken: 

Oの[[CanPut]]内部メソッドがプロパティ名Pで呼び出された場合には、以下のステップで
行われます。


1. Let desc be the result of calling the [[GetOwnProperty]] internal method of O
   with argument P. 
2. If desc is not undefined, then a. If IsAccessorDescriptor(desc) is true, then
   i. If desc.[[Set]] is undefined, then return false. ii. Else return true. b.
   Else, desc must be a DataDescriptor so return the value of desc.[[Writable]].
   
3. Let proto be the [[Prototype]] internal property of O. 
4. If proto is null, then return the value of the [[Extensible]] internal
   property of O. 
5. Let inherited be the result of calling the [[GetProperty]] internal method of
   proto with property name P. 
6. If inherited is undefined, return the value of the [[Extensible]] internal
   property of O. 
7. If IsAccessorDescriptor(inherited) is true, then a. If inherited.[[Set]] is
   undefined, then return false. b. Else return true. 
8. Else, inherited must be a DataDescriptor a. If the [[Extensible]] internal
   property of O is false, return false. b. Else return the value of
   inherited.[[Writable]]. 

1. Oの[[GetOwnProperty]]内部メソッドを引数Pで呼び出した結果をdescとします。
2. もしdescがundefined以外ならば... a. もしIsAccessorDescriptor(desc)がtrueなら
   ば... i. もしdesc.[[Set]]がundefinedならば、falseを返します。ii. そうでなけれ
   ば、trueを返します。b. そうでなければ、descはDataDescriptorに違いないので、
   desc.[[Writable]]の値を返します。
3. Oの[[Prototype]]内部プロパティの値をprotoとします。
4. もしprotoがnullならば、Oの[[Extensible]]内部プロパティの値を返します。
5. protoの[[Extensible]]内部メソッドをプロパティ名Pで呼び出した結果をinheritedと
   します。
6. もしinheritanceがundefinedならば、Oの[[Extensible]]内部プロパティの値を返しま
   す。
7. もしIsAccessorDescriptor(inherited)がtrueならば... a. もしinherited.[[Set]]が
   undefinedならば、falseを返します。b. そうでなければ、trueを返します。
8. そうでなければ、inheritedはDataDescriptorに違いないので... a. Oの
   [[Extensible]]内部プロパティがfalseならば、falseを返します。b. そうでなけれ
   ば、inherited.[[Writable]]の値を返します。


Host objects may define additional constraints upon [[Put]] operations. If
possible, host objects should not allow [[Put]] operations in situations where
this definition of [[CanPut]] returns false. 

ホストオブジェクトは追加の制約を[[Put]]操作に対して定義しているかもしれません。
もし可能であれば、ホストオブジェクトは、ここの定義の[[CanPut]]がfalseを返すよう
な状況では、[[Put]]操作を許してはいけません。


* 8.12.5 [[Put]] ( P, V, Throw )


When the [[Put]] internal method of O is called with property P, value V, and
Boolean flag Throw, the following steps are taken: 

Oの[[Put]]内部メソッドがプロパティ名P、値V、BooleanフラグThrowで呼び出された場合
には、以下のステップで行われます。


1. If the result of calling the [[CanPut]] internal method of O with argument P
   is false, then a. If Throw is true, then throw a TypeError exception. b. Else
   return. 
2. Let ownDesc be the result of calling the [[GetOwnProperty]] internal method
   of O with argument P. 
3. If IsDataDescriptor(ownDesc) is true, then a. Let valueDesc be the Property
   Descriptor {[[Value]]: V}. b. Call the [[DefineOwnProperty]] internal method
   of O passing P, valueDesc, and Throw as arguments. c. Return. 
4. Let desc be the result of calling the [[GetProperty]] internal method of O
   with argument P. This may be either an own or inherited accessor property
   descriptor or an inherited data property descriptor. 
5. If IsAccessorDescriptor(desc) is true, then a. Let setter be desc.[[Set]]
   which cannot be undefined. b. Call the [[Call]] internal method of setter
   providing O as the this value and providing V as the sole argument. 
6. Else, create a named data property named P on object O as follows a. Let
   newDesc be the Property Descriptor {[[Value]]: V, [[Writable]]: true,
   [[Enumerable]]: true, [[Configurable]]: true}. b. Call the
   [[DefineOwnProperty]] internal method of O passing P, newDesc, and Throw as
   arguments. 
7. Return. 

1. もしOの[[CanPut]]内部メソッドを引数Pで呼び出した結果がfalseの場合には... a.
   Throwがtrueならば、TypeErrorをスローします。b. そうでなければ、戻ります。
2. Oの[[GetOwnProperty]]内部メソッドを引数Pで呼び出した結果をownDescとします。
3. もしIsDataDescriptor(ownDesc)がtrueならば... a. プロパティ記述子
    {
      [[Value]]: V
    }
    をvalueDescとします。b. Oの[[DefineOwnProperty]]内部メソッドを引数P,
   valueDesc, Throwで呼び出します。
4. Oの[[GetProperty]]内部メソッドを引数Pで呼び出した結果をdescとします。descは自
   分自身のアクセサプロパティ、継承したアクセサプロパティ、継承したデータプロパ
   ティ記述子のいずれかになります。
5. もしIsAccessorDescriptor(desc)がtrueならば... a. undefinedではないに違いない
   desc.[[Set]]をsetterとします。b. this値としてOを使い、引数をVひとつだけで、
   setterの[[Call]]内部メソッドを呼び出します。
6. そうでなければ、オブジェクトOに名前付きデータプロパティPを以下のとおり作りま
   す。a. プロパティ記述子
    {
      [[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]:
      true
    }
    をnewDescとします。b. Oの[[DefineOwnProperty]]内部メソッドを引数P, newDesc,
   Throwで呼び出します。
7. 戻ります。


* 8.12.6 [[HasProperty]] ( P )


When the [[HasProperty]] internal method of O is called with property name P,
the following steps are taken: 

Oの[[HasProperty]]内部メソッドがプロパティ名Pで呼び出された場合には、以下のス
テップで行われます。


1. Let desc be the result of calling the [[GetProperty]] internal method of O
   with property name P. 
2. If desc is undefined, then return false. 
3. Else return true. 

1. Oの[[GetProperty]]内部メソッドをプロパティ名Pで呼び出した結果をdescとします。
2. もしdescがundefinedならば、falseを返します。
3. そうでなければ、trueを返します。


* 8.12.7 [[Delete]] ( P, Throw )


When the [[Delete]] internal method of O is called with property name P and the
Boolean flag Throw, the following steps are taken: 

Oの[[Delete]]内部メソッドがプロパティ名P、BooleanフラグThrowで呼び出された場合に
は、以下のステップで行われます。


1. Let desc be the result of calling the [[GetOwnProperty]] internal method of O
   with property name P. 
2. If desc is undefined, then return true. 
3. If desc.[[Configurable]] is true, then a. Remove the own property with name P
   from O. b. Return true. 
4. Else if Throw, then throw a TypeError exception. 
5. Return false. 

1. Oの[[GetOwnProperty]]内部メソッドをプロパティ名Pで呼び出した結果をdescとしま
   す。
2. もしdescがundefinedならば、trueを返します。
3. もしdesc.[[Configurable]]がtrueならば... a. Oから名前がPである固有プロパティ
   を削除します。b. trueを返します。
4. そうでない場合にThrowがtrueならば、TypeErrorをスローします。
5. falseを返します。


* 8.12.8 [[DefaultValue]] ( hint )


When the [[DefaultValue]] internal method of O is called with hint String, the
following steps are taken: 

Oの[[DefaultValue]]内部メソッドが文字列のヒントで呼び出された場合には、以下のス
テップで行われます。


1. Let toString be the result of calling the [[Get]] internal method of object O
   with argument "toString". 
2. If IsCallable(toString) is true then, a. Let str be the result of calling the
   [[Call]] internal method of toString, with O as the this value and an empty
   argument list. b. If str is a primitive value, return str. 
3. Let valueOf be the result of calling the [[Get]] internal method of object O
   with argument "valueOf". 
4. If IsCallable(valueOf) is true then, a. Let val be the result of calling the
   [[Call]] internal method of valueOf, with O as the this value and an empty
   argument list. b. If val is a primitive value, return val. 
5. Throw a TypeError exception. 

1. オブジェクトOの[[Call]]内部メソッドを引数"toString"で呼び出した結果をtoString
   とします。
2. もしIsCallable(toString)がtrueならば... a. toStringの[[Call]]内部メソッドを、
   this値としてOを使い、空の引数リストで呼び出した結果をstrとします。b. もしstr
   がプリミティブな値であれば、strを返します。
3. オブジェクトOの[[Get]]内部メソッドを引数"valueOf"で呼び出した結果をvalueOfと
   します。
4. もしIsCallable(valueOf)がtrueならｂ... a. valueOfの[[Call]]内部メソッドを、
   this値としてOを使い、空の引数リストで呼び出した結果をvalとします。b. もしval
   がプリミティブな値であれば、valを返します。
5. TypeErrorをスローします。


When the [[DefaultValue]] internal method of O is called with hint Number, the
following steps are taken: 

Oの[[DefaultValue]]内部メソッドが数値のヒントで呼び出された場合には、以下のス
テップで行われます。


1. Let valueOf be the result of calling the [[Get]] internal method of object O
   with argument "valueOf". 
2. If IsCallable(valueOf) is true then, a. Let val be the result of calling the
   [[Call]] internal method of valueOf, with O as the this value and an empty
   argument list. b. If val is a primitive value, return val. 
3. Let toString be the result of calling the [[Get]] internal method of object O
   with argument "toString". 
4. If IsCallable(toString) is true then, a. Let str be the result of calling the
   [[Call]] internal method of toString, with O as the this value and an empty
   argument list. b. If str is a primitive value, return str. 
5. Throw a TypeError exception. 

1. オブジェクトOの[[Get]]内部メソッドを引数"valueOf"で呼び出した結果をvalueOfと
   します。
2. もしIsCallable(valueOf)がtrueならば... a. valueOfの[[Get]]内部メソッドを、
   this値としてOを使い、空の引数リストで呼び出した結果をvalとします。b. もしval
   がプリミティブな値であれば、valを返します。
3. オブジェクトOの[[Get]]内部メソッドを引数"toString"で呼び出した結果をtoString
   とします。
4. もしIsCallable(toString)がtrueであれば... a. toStringの[[Call]]内部メソッド
   を、this値としてOを使い、空の引数リストで呼び出した結果をstrとします。b. もし
   strがプリミティブな値であれば、strを返します。
5. TypeErrorをスローします。


When the [[DefaultValue]] internal method of O is called with no hint, then it
behaves as if the hint were Number, unless O is a Date object (see 15.9.6), in
which case it behaves as if the hint were String. 

Oの[[DefaultValue]]内部メソッドがヒント無しに呼び出された場合には、Oが日付オブ
ジェクト(15.9.6)で無い限りは、ヒントが数値であるかのように振る舞います。日付オブ
ジェクトの場合には、ヒントは文字列であるかのように振る舞います。


The above specification of [[DefaultValue]] for native objects can return only
primitive values. If a host object implements its own [[DefaultValue]] internal
method, it must ensure that its [[DefaultValue]] internal method can return only
primitive values. 

上記のネイティブオブジェクトの[[DefaultValue]]の仕様は、プリミティブな値だけを返
します。もしホストオブジェクトが固有の[[DefaultValue]]内部メソッドを実装する場合
には、[[DefaultValue]]内部メソッドがプリミティブな値だけを返すように保証しなけれ
ばなりません。


* 8.12.9 [[DefineOwnProperty]] ( P, Desc, Throw )


In the following algorithm, the term “Reject” means “If Throw is true, then
throw a TypeError exception, otherwise return false”. The algorithm contains
steps that test various fields of the Property Descriptor Desc for specific
values. The fields that are tested in this manner need not actually exist in
Desc. If a field is absent then its value is considered to be false. 

以下のアルゴリズムでは"Reject"という用語は"Throwフラグがtrueならば、TypeError例
外をスローするが、そうでなければfalseを返す"ということを意味します。アルゴリズム
はプロパティ記述子Descの様々なフィールドが特定の値であることをテストするステップ
が含まれています。この作法においてテストされるフィールドはDescに実際に存在する必
要はありません。もしフィールドが存在しなければ、その値はfalseであると見なされま
す。


When the [[DefineOwnProperty]] internal method of O is called with property name
P, property descriptor Desc, and Boolean flag Throw, the following steps are
taken: 

Oの[[DefineOwnProperty]]内部メソッドが、プロパティ名P、プロパティ記述子Desc、
Throwフラグで呼び出された場合には、以下のステップで行われます。


1. Let current be the result of calling the [[GetOwnProperty]] internal method
   of O with property name P. 
2. Let extensible be the value of the [[Extensible]] internal property of O. 
3. If current is undefined and extensible is false, then Reject. 
4. If current is undefined and extensible is true, then a. If
   IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then i. Create
   an own data property named P of object O whose [[Value]], [[Writable]],
   [[Enumerable]] and [[Configurable]] attribute values are described by Desc.
   If the value of an attribute field of Desc is absent, the attribute of the
   newly created property is set to its default value. b. Else, Desc must be an
   accessor Property Descriptor so, i. Create an own accessor property named P
   of object O whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]]
   attribute values are described by Desc. If the value of an attribute field of
   Desc is absent, the attribute of the newly created property is set to its
   default value. c. Return true. 
5. Return true, if every field in Desc is absent. 
6. Return true, if every field in Desc also occurs in current and the value of
   every field in Desc is the same value as the corresponding field in current
   when compared using the SameValue algorithm (9.12). 
7. If the [[Configurable]] field of current is false then a. Reject, if the
   [[Configurable]] field of Desc is true. b. Reject, if the [[Enumerable]]
   field of Desc is present and the [[Enumerable]] fields of current and Desc
   are the Boolean negation of each other. 
8. If IsGenericDescriptor(Desc) is true, then no further validation is required.
   
9. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different
   results, then a. Reject, if the [[Configurable]] field of current is false.
   b. If IsDataDescriptor(current) is true, then i. Convert the property named P
   of object O from a data property to an accessor property. 

1. Oの[[GetOwnProperty]]内部メソッドをプロパティ名Pで呼び出した結果をcurrentとし
   ます。
2. Oの[[Extensible]]内部プロパティの値をextensibleとします。
3. もしcurrentがundefinedでextensibleがfalseであれば、Rejectします。
4. もしcurrentがundefinedでextensibleがtrueであれば... a. もし
   IsGenericDescriptor(Desc)もしくはIsDataDescriptor(Desc)がtrueであれば... i.
   [[Value]], [[Writable]], [[Enumerable]], [[Configurable]]属性の値がDescである
   オブジェクトOに対して、名前がPである固有データプロパティを作ります。b. そうで
   なければ、Descはアクセサプロパティ記述子であるので... i. [[Get]], [[Set]],
   [[Enumerable]], [[Configurable]]属性の値がDescであるオブジェクトOに対して、名
   前がPである固有アクセサプロパティを作ります。c. trueを返します。
5. もしDescにひとつもフィールドがなければ、trueを返します。
6. もしDescのすべてのフィールドがcurrentに存在し、Descのすべてのフィールドの値が
   SameValueアルゴリズム(9.12)を使った比較方法でcurrentの対応するフィールドと一
   致すれば、trueを返します。
7. もしcurrentの[[Configurable]]フィールドがfalseであれば... a. もしDescの
   [[Configurable]]フィールドがtrueであれば、Rejectします。b. もしDescの
   [[Enumerable]]フィールドが存在し、currentの[[Enumerable]]フィールドとDescの
   [[Enumerable]]フィールドが互いに真理値的に反対であれば、Rejectします。
8. もしIsGenericDescriptor(Desc)がtrueであれば、これ以上の妥当性検証は要求されま
   せん。
9. そうでない場合に、IsDataDescriptor(current)とIsDataDescriptor(Desc)が異なる結
   果であれば... a. もしcurrentの[[Configurable]]フィールドがfalseであれば、
   Rejectします。b. もしIsDataDescriptor(current)がtrueであれば... i. オブジェク
   トOのPという名前のプロパティをデータプロパティからアクセサプロパティへと変換
   します。


Preserve the existing values of the converted property's [[Configurable]] and
[[Enumerable]] attributes and set the rest of the property's attributes to their
default values. 

変換したプロパティの[[Configurable]]と[[Enumerable]属性の存在する値を保持し、プ
ロパティの残りの属性をそれらの初期値に設定します。


  c. Else, i. Convert the property named P of object O from an accessor property
    to a data property. 

  c. そうでなければ... i. オブジェクトOのPという名前のプロパティをアクセサプロパ
    ティからデータプロパティへと変換します。


Preserve the existing values of the converted property's [[Configurable]] and
[[Enumerable]] attributes and set the rest of the property's attributes to their
default values. 

変換したプロパティの[[Configurable]]と[[Enumerable]]属性の存在する値を保持し、プ
ロパティの残りの属性をそれらの初期値に設定します。


10. Else, if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true,
    then a. If the [[Configurable]] field of current is false, then i. Reject,
    if the [[Writable]] field of current is false and the [[Writable]] field of
    Desc is true. ii. If the [[Writable]] field of current is false, then 
      1. Reject, if the [[Value]] field of Desc is present and
         SameValue(Desc.[[Value]], current.[[Value]]) is false. b. else, the
         [[Configurable]] field of current is true, so any change is acceptable.
         
11. Else, IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both
    true so, a. If the [[Configurable]] field of current is false, then i.
    Reject, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]],
    current.[[Set]]) is false. ii. Reject, if the [[Get]] field of Desc is
    present and SameValue(Desc.[[Get]], current.[[Get]]) is false. 
12. For each attribute field of Desc that is present, set the correspondingly
    named attribute of the property named P of object O to the value of the
    field. 
13. Return true. 

10. そうでなければ、もしIsDataDescriptor(current)とIsDataDescriptor(Desc)が両方
    ともtrueであれば... a. もしcurrentの[[Configurable]]フィールドがfalseならば
    .. i. もしcurrentの[[Writable]]フィールドがfalseであり、Descの[[Writable]]
    フィールドがtrueであれば、Rejectします。ii. もしcurrentの[[Writable]]フィー
    ルドががfalseならば...
      1. もしDescの[[Value]]フィールドが存在し、SameValue(Desc.[[Value]],
         current.[[Value]])がfalseならば、Rejectします。b. そうでなければ、
         currentの[[Configurable]]フィールドはtrueであり、どのような変更も受け付
         けられます。
11. そうでなければ、IsAccessorDescriptor(current)とIsAccessorDescriptor(Desc)が
    両方ともtrueならば... a. もしcurrentの[[Configurable]]フィールドがfalseなら
    ば.. i. もしDescの[[Set]]フィールドが存在し、SameValue(Desc.[[Set]],
    current.[[Set]])がfalseならば、Rejectします。ii. もしDescの[[Get]]フィールド
    が存在し、SameValue(Desc.[[Get]], current.[[Get]])がfalseならば、Rejectしま
    す。
12. Descのすべてのフィールドに対して、オブジェクトOのPという名前のプロパティの対
    応する属性をフィールドの値に設定します。


However, if O is an Array object, it has a more elaborate [[DefineOwnProperty]]
internal method defined in 15.4.5.1. 

しかしながら、もしOがArrayオブジェクトであれば、15.4.5.1で定義されるより複雑な
[[DefineOwnProperty]]内部メソッドを持ちます。


NOTE Step 10.b allows any field of Desc to be different from the corresponding
field of current if current's [[Configurable]] field is true. This even permits
changing the [[Value]] of a property whose [[Writable]] attribute is false. This
is allowed because a true [[Configurable]] attribute would permit an equivalent
sequence of calls where [[Writable]] is first set to true, a new [[Value]] is
set, and then [[Writable]] is set to false. 

注意：10.bの手続きでは、もしcurrentの[[Configurable]]フィールドがtrueの場合に、
Descのすべてのフィールドをcurrentの対応するフィールドとは別々にします。これは、
[[Writable]]属性がfalseであるプロパティの[[Value]]を変更することを可能にします。
これが許されているのは、[[Configurable]]属性がtrueであることは、[[Writable]]が最
初にtrueに設定され、新しい[[Value]]が設定され、それから[[Writable]]がfalseに設定
されるという呼び出しと同等の流れを許すためです。

15 標準組み込みECMAScriptオブジェクト


There are certain built-in objects available whenever an ECMAScript program begins execution. One, the 
global object, is part of the lexical environment of the executing program. Others are accessible as initial 
properties of the global object. 

Unless specified otherwise, the [[Class]] internal property of a built-in object is "Function" if that built-in 
object has a [[Call]] internal property, or "Object" if that built-in object does not have a [[Call]] internal 
property. Unless specified otherwise, the [[Extensible]] internal property of a built-in object initially has the 
value true. 

Many built-in objects are functions: they can be invoked with arguments. Some of them furthermore are 
constructors: they are functions intended for use with the new operator. For each built-in function, this 


specification describes the arguments required by that function and properties of the Function object. For each 
built-in constructor, this specification furthermore describes properties of the prototype object of that 
constructor and properties of specific object instances returned by a new expression that invokes that 
constructor. 

Unless otherwise specified in the description of a particular function, if a function or constructor described in 
this clause is given fewer arguments than the function is specified to require, the function or constructor shall 
behave exactly as if it had been given sufficient additional arguments, each such argument being the 
undefined value. 

Unless otherwise specified in the description of a particular function, if a function or constructor described in 
this clause is given more arguments than the function is specified to allow, the extra arguments are evaluated 
by the call and then ignored by the function. However, an implementation may define implementation specific 
behaviour relating to such arguments as long as the behaviour is not the throwing of a TypeError exception 
that is predicated simply on the presence of an extra argument. 

NOTE Implementations that add additional capabilities to the set of built-in functions are encouraged to do so by 
adding new functions rather than adding new parameters to existing functions. 

Every built-in function and every built-in constructor has the Function prototype object, which is the initial value 
of the expression Function.prototype (15.3.4), as the value of its [[Prototype]] internal property. 

Unless otherwise specified every built-in prototype object has the Object prototype object, which is the initial 
value of the expression Object.prototype (15.2.4), as the value of its [[Prototype]] internal property, 
except the Object prototype object itself. 

None of the built-in functions described in this clause that are not constructors shall implement the 
[[Construct]] internal method unless otherwise specified in the description of a particular function. None of the 
built-in functions described in this clause shall have a prototype property unless otherwise specified in the 
description of a particular function. 

This clause generally describes distinct behaviours for when a constructor is “called as a function” and for 
when it is “called as part of a new expression”. The “called as a function” behaviour corresponds to the 
invocation of the constructor’s [[Call]] internal method and the “called as part of a new expression” behaviour 
corresponds to the invocation of the constructor’s [[Construct]] internal method. 

Every built-in Function object described in this clause.whether as a constructor, an ordinary function, or 
both.has a length property whose value is an integer. Unless otherwise specified, this value is equal to the 
largest number of named arguments shown in the subclause headings for the function description, including 
optional parameters. 

NOTE For example, the Function object that is the initial value of the slice property of the String prototype object is 
described under the subclause heading “String.prototype.slice (start, end)” which shows the two named arguments start 
and end; therefore the value of the length property of that Function object is 2. 

In every case, the length property of a built-in Function object described in this clause has the attributes 
{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. Every other property described in this 
clause has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } unless otherwise 
specified. 

15.1 The Global Object 
The unique global object is created before control enters any execution context. 

Unless otherwise specified, the standard built-in properties of the global object have attributes {[[Writable]]: 
true, [[Enumerable]]: false, [[Configurable]]: true}. 

The global object does not have a [[Construct]] internal property; it is not possible to use the global object as a 
constructor with the new operator. 


The global object does not have a [[Call]] internal property; it is not possible to invoke the global object as a 
function. 

The values of the [[Prototype]] and [[Class]] internal properties of the global object are implementation-
dependent. 

In addition to the properties defined in this specification the global object may have additional host defined 
properties. This may include a property whose value is the global object itself; for example, in the HTML 
document object model the window property of the global object is the global object itself. 

15.1.1 Value Properties of the Global Object 
15.1.1.1 NaN 
The value of NaN is NaN (see 8.5). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, 
[[Configurable]]: false }. 

15.1.1.2 Infinity 
The value of Infinity is +∞ (see 8.5). This property has the attributes { [[Writable]]: false, [[Enumerable]]: 
false, [[Configurable]]: false }. 

15.1.1.3 undefined 
The value of undefined is undefined (see 8.1). This property has the attributes { [[Writable]]: false, 
[[Enumerable]]: false, [[Configurable]]: false }. 

15.1.2 Function Properties of the Global Object 
15.1.2.1 eval (x) 
When the eval function is called with one argument x, the following steps are taken: 

1. 
If Type(x) is not String, return x. 
2. 
Let prog be the ECMAScript code that is the result of parsing x as a Program. If the parse fails, throw a 
SyntaxError exception (but see also clause 16). 
3. 
Let evalCtx be the result of establishing a new execution context (10.4.2) for the eval code prog. 
4. 
Let result be the result of evaluating the program prog. 
5. 
Exit the running execution context evalCtx, restoring the previous execution context. 
6. 
If result.type is normal and its completion value is a value V, then return the value V. 
7. 
If result.type is normal and its completion value is empty, then return the value undefined. 
8. 
Otherwise, result.type must be throw. Throw result.value as an exception. 
15.1.2.1.1 Direct Call to Eval 
A direct call to the eval function is one that is expressed as a CallExpression that meets the following two 
conditions: 

The Reference that is the result of evaluating the MemberExpression in the CallExpression has an environment 
record as its base value and its reference name is "eval". 

The result of calling the abstract operation GetValue with that Reference as the argument is the standard built-
in function defined in 15.1.2.1. 


15.1.2.2 parseInt (string , radix) 
The parseInt function produces an integer value dictated by interpretation of the contents of the string 
argument according to the specified radix. Leading white space in string is ignored. If radix is undefined or 0, 
it is assumed to be 10 except when the number begins with the character pairs 0x or 0X, in which case a radix 
of 16 is assumed. If radix is 16, number may also optionally begin with the character pairs 0x or 0X. 

When the parseInt function is called, the following steps are taken: 

1. 
Let inputString be ToString(string). 
2. 
Let S be a newly created substring of inputString consisting of the first character that is not a 
StrWhiteSpaceChar and all characters following that character. (In other words, remove leading white 
space.) 
3. 
Let sign be 1. 
4. 
If S is not empty and the first character of S is a minus sign -, let sign be -1. 
5. 
If S is not empty and the first character of S is a plus sign + or a minus sign -, then remove the first 
character from S. 
6. 
Let R = ToInt32(radix). 
7. 
Let stripPrefix be true. 
8. 
If R ≠ 0, then 
a. 
If R < 2 or R > 36, then return NaN. 
b. 
If R ≠ 16, let stripPrefix be false. 
9. 
Else, R = 0 
a. 
Let R = 10. 
10. 
If stripPrefix is true, then 
a. 
If the length of S is at least 2 and the first two characters of S are either “0x” or “0X”, then remove 
the first two characters from S and let R = 16. 
11. 
If S contains any character that is not a radix-R digit, then let Z be the substring of S consisting of all 
characters before the first such character; otherwise, let Z be S. 
12. 
If Z is empty, return NaN. 
13. 
Let mathInt be the mathematical integer value that is represented by Z in radix-R notation, using the letters 
A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z contains more than 20 
significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the 
implementation; and if R is not 2, 4, 8, 10, 16, or 32, then mathInt may be an implementation-dependent 
approximation to the mathematical integer value that is represented by Z in radix-R notation.) 
14. Let number be the Number value for mathInt. 
15. Return sign * number. 
NOTE parseInt may interpret only a leading portion of string as an integer value; it ignores any characters that 
cannot be interpreted as part of the notation of an integer, and no indication is given that any such characters were 
ignored. 

15.1.2.3 parseFloat (string) 
The parseFloat function produces a Number value dictated by interpretation of the contents of the string 
argument as a decimal literal. 

When the parseFloat function is called, the following steps are taken: 

1. 
Let inputString be ToString(string). 
2. 
Let trimmedString be a substring of inputString consisting of the leftmost character that is not a 
StrWhiteSpaceChar and all characters to the right of that character.(In other words, remove leading white 
space.) 
3. 
If neither trimmedString nor any prefix of trimmedString satisfies the syntax of a StrDecimalLiteral (see 
9.3.1), return NaN. 
4. 
Let numberString be the longest prefix of trimmedString, which might be trimmedString itself, that satisfies 
the syntax of a StrDecimalLiteral. 
5. 
Return the Number value for the MV of numberString. 

NOTE parseFloat may interpret only a leading portion of string as a Number value; it ignores any characters that 
cannot be interpreted as part of the notation of an decimal literal, and no indication is given that any such characters were 
ignored. 

15.1.2.4 isNaN (number) 
Returns true if the argument coerces to NaN, and otherwise returns false. 
1. If ToNumber(number) is NaN, return true. 
2. Otherwise, return false. 
NOTE A reliable way for ECMAScript code to test if a value X is a NaN is an expression of the form X !== X. The 
result will be true if and only if X is a NaN. 

15.1.2.5 isFinite (number) 
Returns false if the argument coerces to NaN, +∞, or -∞, and otherwise returns true. 
1. If ToNumber(number) is NaN, +∞, or -∞, return false. 
2. Otherwise, return true. 
15.1.3 URI Handling Function Properties 
Uniform Resource Identifiers, or URIs, are Strings that identify resources (e.g. web pages or files) and 
transport protocols by which to access them (e.g. HTTP or FTP) on the Internet. The ECMAScript language 
itself does not provide any support for using URIs except for functions that encode and decode URIs as 
described in 15.1.3.1, 15.1.3.2, 15.1.3.3 and 15.1.3.4. 

NOTE Many implementations of ECMAScript provide additional functions and methods that manipulate web pages; 
these functions are beyond the scope of this standard. 

A URI is composed of a sequence of components separated by component separators. The general form is: 

Scheme : First / Second ; Third ? Fourth 

where the italicised names represent components and the “:”, “/”, “;” and “?” are reserved characters used 
as separators. The encodeURI and decodeURI functions are intended to work with complete URIs; they 
assume that any reserved characters in the URI are intended to have special meaning and so are not 
encoded. The encodeURIComponent and decodeURIComponent functions are intended to work with the 
individual component parts of a URI; they assume that any reserved characters represent text and so must be 
encoded so that they are not interpreted as reserved characters when the component is part of a complete 
URI. 

The following lexical grammar specifies the form of encoded URIs. 

uri ::: 
uriCharacters[opt] 

uriCharacters ::: 
uriCharacter uriCharacters[opt] 

uriCharacter ::: 
uriReserved 
uriUnescaped 
uriEscaped 

uriReserved ::: one of 

; / ? : @ & = + $ , 


uriUnescaped ::: 
uriAlpha 
DecimalDigit 
uriMark 

uriEscaped ::: 
% HexDigit HexDigit 

uriAlpha ::: one of 

a b c d e f g h i j k l m n o p q r s t u v w x y zA B C D E F G H I J K L M N O P Q R S T U V W X Y Z 

uriMark ::: one of 

-_ . ! ~ * ' ( ) 
When a character to be included in a URI is not listed above or is not intended to have the special meaning 
sometimes given to the reserved characters, that character must be encoded. The character is transformed 
into its UTF-8 encoding, with surrogate pairs first converted from UTF-16 to the corresponding code point 
value. (Note that for code units in the range [0,127] this results in a single octet with the same value.) The 
resulting sequence of octets is then transformed into a String with each octet represented by an escape 
sequence of the form “%xx”. 

The encoding and escaping process is described by the abstract operation Encode taking two String 
arguments string and unescapedSet. 

1. 
Let strLen be the number of characters in string. 
2. 
Let R be the empty String. 
3. 
Let k be 0. 
4. 
Repeat 
a. 
If k equals strLen, return R. 
b. 
Let C be the character at position k within string. 
c. 
If C is in unescapedSet, then 
i. 
Let S be a String containing only the character C. 
ii. 
Let R be a new String value computed by concatenating the previous value of R and S. 
d. 
Else, C is not in unescapedSet 
i. 
If the code unit value of C is not less than 0xDC00 and not greater than 0xDFFF, throw a 
URIError exception. 
ii. 
If the code unit value of C is less than 0xD800 or greater than 0xDBFF, then 
1. 
Let V be the code unit value of C. 
iii. 
Else, 
1. 
Increase k by 1. 
2. 
If k equals strLen, throw a URIError exception. 
3. 
Let kChar be the code unit value of the character at position k within string. 
4. 
If kChar is less than 0xDC00 or greater than 0xDFFF, throw a URIError 
exception. 
5. 
Let V be (((the code unit value of C) . 0xD800) * 0x400 + (kChar . 0xDC00) + 
0x10000). 
iv. 
Let Octets be the array of octets resulting by applying the UTF-8 transformation to V, and 
let L be the array size. 
v. 
Let j be 0. 
vi. 
Repeat, while j < L 
1. 
Let jOctet be the value at position j within Octets. 
2. 
Let S be a String containing three characters “%XY” where XY are two uppercase 
hexadecimal digits encoding the value of jOctet. 
3. 
Let R be a new String value computed by concatenating the previous value of R and 
S. 
4. 
Increase j by 1. 
e. 
Increase k by 1. 

The unescaping and decoding process is described by the abstract operation Decode taking two String 
arguments string and reservedSet. 

1. 
Let strLen be the number of characters in string. 
2. 
Let R be the empty String. 
3. 
Let k be 0. 
4. 
Repeat 
a. 
If k equals strLen, return R. 
b. 
Let C be the character at position k within string. 
c. 
If C is not ‘%’, then 
i. 
Let S be the String containing only the character C. 
d. 
Else, C is ‘%’ 
i. 
Let start be k. 
ii. If k + 2 is greater than or equal to strLen, throw a URIError exception. 
iii. 
If the characters at position (k+1) and (k + 2) within string do not represent hexadecimal 
digits, throw a URIError exception. 
iv. 
Let B be the 8-bit value represented by the two hexadecimal digits at position (k + 1) and (k 
+ 2). 
v. 
Increment k by 2. 
vi. 
If the most significant bit in B is 0, then 
1. 
Let C be the character with code unit value B. 
2. 
If C is not in reservedSet, then 
a Let S be the String containing only the character C. 
3. 
Else, C is in reservedSet 
a Let S be the substring of string from position start to position k included. 
vii. 
Else, the most significant bit in B is 1 
1. 
Let n be the smallest non-negative number such that (B << n) & 0x80 is equal to 0. 
2. 
If n equals 1 or n is greater than 4, throw a URIError exception. 
3. 
Let Octets be an array of 8-bit integers of size n. 
4. 
Put B into Octets at position 0. 
5. 
If k + (3 * (n . 1)) is greater than or equal to strLen, throw a URIError exception. 
6. 
Let j be 1. 
7. 
Repeat, while j < n 
a Increment k by 1. 
b If the character at position k is not ‘%’, throw a URIError exception. 
c If the characters at position (k +1) and (k + 2) within string do not 
represent hexadecimal digits, throw a URIError exception. 

d 
Let B be the 8-bit value represented by the two hexadecimal digits at 
position (k + 1) and (k + 2). 

e 
If the two most significant bits in B are not 10, throw a URIError 

exception. 
f Increment k by 2. 
g Put B into Octets at position j. 
h Increment j by 1. 

8. 
Let V be the value obtained by applying the UTF-8 transformation to Octets, that is, 
from an array of octets into a 32-bit value. If Octets does not contain a valid UTF-8 
encoding of a Unicode code point throw a URIError exception. 
9. 
If V is less than 0x10000, then 
a Let C be the character with code unit value V. 
b If C is not in reservedSet, then 
i. Let S be the String containing only the character C. 
c Else, C is in reservedSet 
i. 
Let S be the substring of string from position start to position k 
included. 
10. 
Else, V is . 0x10000 
a If V is greater than 0x10FFFF, throw a URIError exception. 
b Let L be (((V . 0x10000) & 0x3FF) + 0xDC00). 
c Let H be ((((V . 0x10000) >> 10) & 0x3FF) + 0xD800). 
d Let S be the String containing the two characters with code unit values H 
and L. 


e. Let R be a new String value computed by concatenating the previous value of R and S. 
f. Increase k by 1. 
NOTE The syntax of Uniform Resource Identifiers is given in RFC 2396. A formal description and implementation of 
UTF-8 is given in RFC 3629. 

In UTF-8, characters are encoded using sequences of 1 to 6 octets. The only octet of a "sequence" of one has the higher-
order bit set to 0, the remaining 7 bits being used to encode the character value. In a sequence of n octets, n>1, the initial 
octet has the n higher-order bits set to 1, followed by a bit set to 0. The remaining bits of that octet contain bits from the 
value of the character to be encoded. The following octets all have the higher-order bit set to 1 and the following bit set to 
0, leaving 6 bits in each to contain bits from the character to be encoded. The possible UTF-8 encodings of ECMAScript 
characters are specified in Table 21. 

Table 21 - UTF-8 Encodings 

Code Unit Value Representation 1st Octet 2nd Octet 3rd Octet 4th Octet 
0x0000 - 0x007F 00000000 0zzzzzzz 0zzzzzzz 
0x0080 - 0x07FF 00000yyy yyzzzzzz 110yyyyy 10zzzzzz 
0x0800 - 0xD7FF xxxxyyyy yyzzzzzz 1110xxxx 10yyyyyy 10zzzzzz 
0xD800 - 0xDBFF 
followed by0xDC00 . 0xDFFF 
110110vv vvwwwwxx 
followed by110111yy yyzzzzzz 
11110uuu 10uuwwww 10xxyyyy 10zzzzzz 
0xD800 - 0xDBFF 
not followed by0xDC00 . 0xDFFF 
causes URIError 
0xDC00 . 0xDFFF causes URIError 
0xE000 - 0xFFFF xxxxyyyy yyzzzzzz 1110xxxx 10yyyyyy 10zzzzzz 

Where 

uuuuu= vvvv +1 

to account for the addition of 0x10000 as in Surrogates, section 3.7, of the Unicode Standard. 

The range of code unit values 0xD800-0xDFFF is used to encode surrogate pairs; the above transformation combines a 
UTF-16 surrogate pair into a UTF-32 representation and encodes the resulting 21-bit value in UTF-8. Decoding 
reconstructs the surrogate pair. 

RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For example, the invalid sequence C0 80 must not 
decode into the character U+0000. Implementations of the Decode algorithm are required to throw a URIError when 
encountering such invalid sequences. 

15.1.3.1 decodeURI (encodedURI) 
The decodeURI function computes a new version of a URI in which each escape sequence and UTF-8 
encoding of the sort that might be introduced by the encodeURI function is replaced with the character that it 
represents. Escape sequences that could not have been introduced by encodeURI are not replaced. 

When the decodeURI function is called with one argument encodedURI, the following steps are taken: 

1. Let uriString be ToString(encodedURI). 
2. Let reservedURISet be a String containing one instance of each character valid in uriReserved plus “#”. 
3. Return the result of calling Decode(uriString, reservedURISet) 
NOTE The character “#” is not decoded from escape sequences even though it is not a reserved URI character. 


15.1.3.2 decodeURIComponent (encodedURIComponent) 
The decodeURIComponent function computes a new version of a URI in which each escape sequence and 
UTF-8 encoding of the sort that might be introduced by the encodeURIComponent function is replaced with 
the character that it represents. 

When the decodeURIComponent function is called with one argument encodedURIComponent, the following 
steps are taken: 

1. 
Let componentString be ToString(encodedURIComponent). 
2. 
Let reservedURIComponentSet be the empty String. 
3. 
Return the result of calling Decode(componentString, reservedURIComponentSet) 
15.1.3.3 encodeURI (uri) 
The encodeURI function computes a new version of a URI in which each instance of certain characters is 
replaced by one, two or three escape sequences representing the UTF-8 encoding of the character. 

When the encodeURI function is called with one argument uri, the following steps are taken: 

1. 
Let uriString be ToString(uri). 
2. 
Let unescapedURISet be a String containing one instance of each character valid in uriReserved and 
uriUnescaped plus “#”. 
3. 
Return the result of calling Encode(uriString, unescapedURISet) 
NOTE The character “#” is not encoded to an escape sequence even though it is not a reserved or unescaped URI 
character. 

15.1.3.4 encodeURIComponent (uriComponent) 
The encodeURIComponent function computes a new version of a URI in which each instance of certain 
characters is replaced by one, two or three escape sequences representing the UTF-8 encoding of the 
character. 

When the encodeURIComponent function is called with one argument uriComponent, the following steps are 
taken: 

1. 
Let componentString be ToString(uriComponent). 
2. 
Let unescapedURIComponentSet be a String containing one instance of each character valid in 
uriUnescaped. 
3. 
Return the result of calling Encode(componentString, unescapedURIComponentSet) 
15.1.4 Constructor Properties of the Global Object 
15.1.4.1 Object ( . . . ) 
See 15.2.1 and 15.2.2. 

15.1.4.2 Function ( . . . ) 
See 15.3.1 and 15.3.2. 

15.1.4.3 Array ( . . . ) 
See 15.4.1 and 15.4.2. 


15.1.4.4 String ( . . . ) 
See 15.5.1 and 15.5.2. 

15.1.4.5 Boolean ( . . . ) 
See 15.6.1 and 15.6.2. 

15.1.4.6 Number ( . . . ) 
See 15.7.1 and 15.7.2. 

15.1.4.7 Date ( . . . ) 
See 15.9.2. 

15.1.4.8 RegExp ( . . . ) 
See 15.10.3 and 15.10.4. 

15.1.4.9 Error ( . . . ) 
See 15.11.1 and 15.11.2. 

15.1.4.10 EvalError ( . . . ) 
See 15.11.6.1. 

15.1.4.11 RangeError ( . . . ) 
See 15.11.6.2. 

15.1.4.12 ReferenceError ( . . . ) 
See 15.11.6.3. 

15.1.4.13 SyntaxError ( . . . ) 
See 15.11.6.4. 

15.1.4.14 TypeError ( . . . ) 
See 15.11.6.5. 

15.1.4.15 URIError ( . . . ) 
See 15.11.6.6. 

15.1.5 Other Properties of the Global Object 
15.1.5.1 Math 
See 15.8. 


15.1.5.2 JSON 
See 15.12. 

15.2 Object Objects 
15.2.1 The Object Constructor Called as a Function 
When Object is called as a function rather than as a constructor, it performs a type conversion. 

15.2.1.1 Object ( [ value ] ) 
When the Object function is called with no arguments or with one argument value, the following steps are 
taken: 

1. 
If value is null, undefined or not supplied, create and return a new Object object exactly as if the standard 
built-in Object constructor had been called with the same arguments (15.2.2.1). 
2. 
Return ToObject(value). 
15.2.2 The Object Constructor 
When Object is called as part of a new expression, it is a constructor that may create an object. 

15.2.2.1 new Object ( [ value ] ) 
When the Object constructor is called with no arguments or with one argument value, the following steps are 
taken: 

1. 
If value is supplied, then 
a. 
If Type(value) is Object, then 
i. 
If the value is a native ECMAScript object, do not create a new object but simply return 
value. 
ii. 
If the value is a host object, then actions are taken and a result is returned in an 
implementation-dependent manner that may depend on the host object. 
b. 
If Type(value) is String, return ToObject(value). 
c. 
If Type(value) is Boolean, return ToObject(value). 
d. 
If Type(value) is Number, return ToObject(value). 
2. 
Asset: The argument value was not supplied or its type was Null or Undefined. 
3. 
Let obj be a newly created native ECMAScript object. 
4. 
Set the [[Prototype]] internal property of obj t to the standard built-in Object prototype object (15.2.4). 
5. 
Set the [[Class]] internal property of obj to "Object". 
6. 
Set the [[Extensible]] internal property of obj to true. 
7. 
Set the all the internal methods of obj as specified in 8.12 
8. 
Return obj. 
15.2.3 Properties of the Object Constructor 
The value of the [[Prototype]] internal property of the Object constructor is the standard built-in Function 
prototype object. 

Besides the internal properties and the length property (whose value is 1), the Object constructor has the 
following properties: 

15.2.3.1 Object.prototype 
The initial value of Object.prototype is the standard built-in Object prototype object (15.2.4). 


This property has the attributes {[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.2.3.2 Object.getPrototypeOf ( O ) 
When the getPrototypeOf function is called with argument O, the following steps are taken: 

1. 
If Type(O) is not Object throw a TypeError exception. 
2. 
Return the value of the [[Prototype]] internal property of O. 
15.2.3.3 Object.getOwnPropertyDescriptor ( O, P ) 
When the getOwnPropertyDescriptor function is called, the following steps are taken: 

1. 
If Type(O) is not Object throw a TypeError exception. 
2. 
Let name be ToString(P). 
3. 
Let desc be the result of calling the [[GetOwnProperty]] internal method of O with argument name. 
4. 
Return the result of calling FromPropertyDescriptor(desc) (8.10.4). 
15.2.3.4 Object.getOwnPropertyNames ( O ) 
When the getOwnPropertyNames function is called, the following steps are taken: 

1. 
If Type(O) is not Object throw a TypeError exception. 
2. 
Let array be the result of creating a new object as if by the expression new Array () where Array is the 
standard built-in constructor with that name. 
3. 
Let n be 0. 
4. 
For each named own property P of O 
a. 
Let name be the String value that is the name of P. 
b. 
Call the [[DefineOwnProperty]] internal method of array with arguments ToString(n), the 
PropertyDescriptor {[[Value]]: name, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: 
true}, and false. 
c. 
Increment n by 1. 
5. 
Return array. 
NOTE If O is a String instance, the set of own properties processed in step 4 includes the implicit properties defined 
in 15.5.5.2 that correspond to character positions within the object’s [[PrimitiveValue]] String. 

15.2.3.5 Object.create ( O [, Properties] ) 
The create function creates a new object with a specified prototype. When the create function is called, the 
following steps are taken: 

1. 
If Type(O) is not Object or Null throw a TypeError exception. 
2. 
Let obj be the result of creating a new object as if by the expression new Object() where Object is the 
standard built-in constructor with that name 
3. 
Set the [[Prototype]] internal property of obj to O. 
4. 
If the argument Properties is present and not undefined, add own properties to obj as if by calling the 
standard built-in function Object.defineProperties with arguments obj and Properties. 
5. 
Return obj. 
15.2.3.6 Object.defineProperty ( O, P, Attributes ) 
The defineProperty function is used to add an own property and/or update the attributes of an existing own 
property of an object. When the defineProperty function is called, the following steps are taken: 

1. 
If Type(O) is not Object throw a TypeError exception. 
2. 
Let name be ToString(P). 
3. 
Let desc be the result of calling ToPropertyDescriptor with Attributes as the argument. 
4. 
Call the [[DefineOwnProperty]] internal method of O with arguments name, desc, and true. 
5. 
Return O. 

15.2.3.7 Object.defineProperties ( O, Properties ) 
The defineProperties function is used to add own properties and/or update the attributes of existing own 
properties of an object. When the defineProperties function is called, the following steps are taken: 

1. If Type(O) is not Object throw a TypeError exception. 
2. Let props be ToObject(Properties). 
3. Let names be an internal list containing the names of each enumerable own property of props. 
4. Let descriptors be an empty internal List. 
5. For each element P of names in list order, 
a. Let descObj be the result of calling the [[Get]] internal method of props with P as the argument. 
b. Let desc be the result of calling ToPropertyDescriptor with descObj as the argument. 
c. Append desc to the end of descriptors. 
6. For each element desc of descriptors in list order, 
a. Call the [[DefineOwnProperty]] internal method of O with arguments P, desc, and true. 
7. Return O. 
If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration 
order must be used to order the list elements in step 3 of this algorithm. 

15.2.3.8 Object.seal ( O ) 
When the seal function is called, the following steps are taken: 

1. If Type(O) is not Object throw a TypeError exception. 
2. For each named own property name P of O, 
a. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P. 
b. If desc.[[Configurable]] is true, set desc.[[Configurable]] to false. 
c. Call the [[DefineOwnProperty]] internal method of O with P, desc, and true as arguments. 
3. Set the [[Extensible]] internal property of O to false. 
4. Return O. 
15.2.3.9 Object.freeze ( O ) 
When the freeze function is called, the following steps are taken: 

1. If Type(O) is not Object throw a TypeError exception. 
2. For each named own property name P of O, 
a. Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P. 
b. If IsDataDescriptor(desc) is true, then 
i. If desc.[[Writable]] is true, set desc.[[Writable]] to false. 
c. If desc.[[Configurable]] is true, set desc.[[Configurable]] to false. 
d. Call the [[DefineOwnProperty]] internal method of O with P, desc, and true as arguments. 
3. Set the [[Extensible]] internal property of O to false. 
4. Return O. 
15.2.3.10 Object.preventExtensions ( O ) 
When the preventExtensions function is called, the following steps are taken: 

1. If Type(O) is not Object throw a TypeError exception. 
2. Set the [[Extensible]] internal property of O to false. 
3. Return O. 
15.2.3.11 Object.isSealed ( O ) 
When the isSealed function is called with argument O, the following steps are taken: 

1. If Type(O) is not Object throw a TypeError exception. 
2. For each named own property name P of O, 

a. 
Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P. 
b. 
If desc.[[Configurable]] is true, then return false. 
3. 
If the [[Extensible]] internal property of O is false, then return true. 
4. 
Otherwise, return false. 
15.2.3.12 Object.isFrozen ( O ) 
When the isFrozen function is called with argument O, the following steps are taken: 

1. 
If Type(O) is not Object throw a TypeError exception. 
2. 
For each named own property name P of O, 
a. 
Let desc be the result of calling the [[GetOwnProperty]] internal method of O with P. 
b. 
If IsDataDescriptor(desc) is true then 
i. If desc.[[Writable]] is true, return false. 
c. 
If desc.[[Configurable]] is true, then return false. 
3. 
If the [[Extensible]] internal property of O is false, then return true. 
4. 
Otherwise, return false. 
15.2.3.13 Object.isExtensible ( O ) 
When the isExtensible function is called with argument O, the following steps are taken: 

1. 
If Type(O) is not Object throw a TypeError exception. 
2. 
Return the Boolean value of the [[Extensible]] internal property of O. 
15.2.3.14 Object.keys ( O ) 
When the keys function is called with argument O, the following steps are taken: 

1. 
If the Type(O) is not Object, throw a TypeError exception. 
2. 
Let n be the number of own enumerable properties of O 
3. 
Let array be the result of creating a new Object as if by the expression new Array(n) where Array is 
the standard built-in constructor with that name. 
4. 
Let index be 0. 
5. 
For each own enumerable property of O whose name String is P 
a. 
Call the [[DefineOwnProperty]] internal method of array with arguments ToString(index), the 
PropertyDescriptor {[[Value]]: P, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 
and false. 
b. 
Increment index by 1. 
6. 
Return array. 
If an implementation defines a specific order of enumeration for the for-in statement, that same enumeration 
order must be used in step 5 of this algorithm. 

15.2.4 Properties of the Object Prototype Object 
The value of the [[Prototype]] internal property of the Object prototype object is null, the value of the [[Class]] 
internal property is "Object", and the initial value of the [[Extensible]] internal property is true. 

15.2.4.1 Object.prototype.constructor 
The initial value of Object.prototype.constructor is the standard built-in Object constructor. 

15.2.4.2 Object.prototype.toString ( ) 
When the toString method is called, the following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let class be the value of the [[Class]] internal property of O. 

3. 
Return the String value that is the result of concatenating the three Strings "[object ", class, and "]". 
15.2.4.3 Object.prototype.toLocaleString ( ) 
When the toLocaleString method is called, the following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let toString be the result of calling the [[Get]] internal method of O passing "toString" as the argument. 
3. 
If IsCallable(toString) is false, throw a TypeError exception. 
4. 
Return the result of calling the [[Call]] internal method of toString passing O as the this value and no 
arguments. 
NOTE 1 This function is provided to give all Objects a generic toLocaleString interface, even though not all may 
use it. Currently, Array, Number, and Date provide their own locale-sensitive toLocaleString methods. 

NOTE 2 The first parameter to this function is likely to be used in a future version of this standard; it is recommended 
that implementations do not use this parameter position for anything else. 

15.2.4.4 Object.prototype.valueOf ( ) 
When the valueOf method is called, the following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
If O is the result of calling the Object constructor with a host object (15.2.2.1), then 
a. 
Return either O or another value such as the host object originally passed to the constructor. The 
specific result that is returned is implementation-defined. 
3. 
Return O. 
15.2.4.5 Object.prototype.hasOwnProperty (V) 
When the hasOwnProperty method is called with argument V, the following steps are taken: 

1. 
Let P be ToString(V). 
2. 
Let O be the result of calling ToObject passing the this value as the argument. 
3. 
Let desc be the result of calling the [[GetOwnProperty]] internal method of O passing P as the argument. 
4. 
If desc is undefined, return false. 
5. 
Return true. 
NOTE 1 Unlike [[HasProperty]] (8.12.6), this method does not consider objects in the prototype chain. 

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1 
in previous editions of this specification will continue to be thrown even if the this value is undefined or null. 

15.2.4.6 Object.prototype.isPrototypeOf (V) 
When the isPrototypeOf method is called with argument V, the following steps are taken: 

1. 
If V is not an object, return false. 
2. 
Let O be the result of calling ToObject passing the this value as the argument. 
3. 
Repeat 
a. 
Let V be the value of the [[Prototype]] internal property of V. 
b. 
if V is null, return false 
c. 
If O and V refer to the same object, return true. 
NOTE The ordering of steps 1 and 2 is chosen to preserve the behaviour specified by previous editions of this 
specification for the case where V is not an object and the this value is undefined or null. 


15.2.4.7 Object.prototype.propertyIsEnumerable (V) 
When the propertyIsEnumerable method is called with argument V, the following steps are taken: 

1. 
Let P be ToString(V). 
2. 
Let O be the result of calling ToObject passing the this value as the argument. 
3. 
Let desc be the result of calling the [[GetOwnProperty]] internal method of O passing P as the argument. 
4. 
If desc is undefined, return false. 
5. 
Return the value of desc.[[Enumerable]]. 
NOTE 1 This method does not consider objects in the prototype chain. 

NOTE 2 The ordering of steps 1 and 2 is chosen to ensure that any exception that would have been thrown by step 1 
in previous editions of this specification will continue to be thrown even if the this value is undefined or null. 

15.2.5 Properties of Object Instances 
Object instances have no special properties beyond those inherited from the Object prototype object. 

15.3 Function Objects 
15.3.1 The Function Constructor Called as a Function 
When Function is called as a function rather than as a constructor, it creates and initialises a new Function 
object. Thus the function call Function(…) is equivalent to the object creation expression new 
Function(…) with the same arguments. 

15.3.1.1 Function (p1, p2, … , pn, body) 
When the Function function is called with some arguments p1, p2, … , pn, body (where n might be 0, that is, 
there are no “p” arguments, and where body might also not be provided), the following steps are taken: 

1. 
Create and return a new Function object as if the standard built-in constructor Function was used in a new 
expression with the same arguments (15.3.2.1). 
15.3.2 The Function Constructor 
When Function is called as part of a new expression, it is a constructor: it initialises the newly created object. 

15.3.2.1 new Function (p1, p2, … , pn, body) 
The last argument specifies the body (executable code) of a function; any preceding arguments specify formal 
parameters. 

When the Function constructor is called with some arguments p1, p2, … , pn, body (where n might be 0, that 
is, there are no “p” arguments, and where body might also not be provided), the following steps are taken: 

1. 
Let argCount be the total number of arguments passed to this function invocation. 
2. 
Let P be the empty String. 
3. 
If argCount = 0, let body be the empty String. 
4. 
Else if argCount = 1, let body be that argument. 
5. 
Else, argCount > 1 
a. 
Let firstArg be the first argument. 
b. 
Let P be ToString(firstArg). 
c. 
Let k be 2. 
d. 
Repeat, while k < argCount 
i. Let nextArg be the k’th argument. 

ii. 
Let P be the result of concatenating the previous value of P, the String "," (a comma), and 
ToString(nextArg). 
iii. Increase k by 1. 
e. 
Let body be the k’th argument. 
6. 
Let body be ToString(body). 
7. 
If P is not parsable as a FormalParameterList[opt] then throw a SyntaxError exception. 
8. 
If body is not parsable as FunctionBody then throw a SyntaxError exception. 
9. 
If body is strict mode code (see 10.1.1) then let strict be true, else let strict be false. 
10. 
If strict is true, throw any exceptions specified in 13.1 that apply. 
11. 
Return a new Function object created as specified in 13.2 passing P as the FormalParameterList and body as 
the FunctionBody. Pass in the Global Environment as the Scope parameter and strict as the Strict flag. 
A prototype property is automatically created for every function, to provide for the possibility that the 
function will be used as a constructor. 

NOTE It is permissible but not necessary to have one argument for each formal parameter to be specified. For 
example, all three of the following expressions produce the same result: 

new Function("a", "b", "c", "return a+b+c") 
new Function("a, b, c", "return a+b+c") 
new Function("a,b", "c", "return a+b+c") 

15.3.3 Properties of the Function Constructor 
The Function constructor is itself a Function object and its [[Class]] is "Function". The value of the 
[[Prototype]] internal property of the Function constructor is the standard built-in Function prototype object 
(15.3.4). 

The value of the [[Extensible]] internal property of the Function constructor is true. 

The Function constructor has the following properties: 

15.3.3.1 Function.prototype 
The initial value of Function.prototype is the standard built-in Function prototype object (15.3.4). 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.3.3.2 Function.length 
This is a data property with a value of 1. This property has the attributes { [[Writable]]: false, [[Enumerable]]: 
false, [[Configurable]]: false }. 

15.3.4 Properties of the Function Prototype Object 
The Function prototype object is itself a Function object (its [[Class]] is "Function") that, when invoked, 
accepts any arguments and returns undefined. 

The value of the [[Prototype]] internal property of the Function prototype object is the standard built-in Object 
prototype object (15.2.4). The initial value of the [[Extensible]] internal property of the Function prototype 
object is true. 

The Function prototype object does not have a valueOf property of its own; however, it inherits the valueOf 
property from the Object prototype Object. 

The length property of the Function prototype object is 0. 


15.3.4.1 Function.prototype.constructor 
The initial value of Function.prototype.constructor is the built-in Function constructor. 

15.3.4.2 Function.prototype.toString ( ) 
An implementation-dependent representation of the function is returned. This representation has the syntax of 
a FunctionDeclaration. Note in particular that the use and placement of white space, line terminators, and 
semicolons within the representation String is implementation-dependent. 

The toString function is not generic; it throws a TypeError exception if its this value is not a Function 
object. Therefore, it cannot be transferred to other kinds of objects for use as a method. 

15.3.4.3 Function.prototype.apply (thisArg, argArray) 
When the apply method is called on an object func with arguments thisArg and argArray, the following steps 
are taken: 

1. 
If IsCallable(func) is false, then throw a TypeError exception. 
2. 
If argArray is null or undefined, then 
a. 
Return the result of calling the [[Call]] internal method of func, providing thisArg as the this value 
and an empty list of arguments. 
3. 
If Type(argArray) is not Object, then throw a TypeError exception. 
4. 
Let len be the result of calling the [[Get]] internal method of argArray with argument "length". 
5. 
If len is null or undefined, then throw a TypeError exception. 
6. 
Let n be ToUint32(len). 
7. 
If n is not equal to ToNumber(len), then throw a TypeError exception. 
8. 
Let argList be an empty List. 
9. 
Let index be 0. 
10. 
Repeat while index < n 
a. 
Let indexName be ToString(index). 
b. 
Let nextArg be the result of calling the [[Get]] internal method of argArray with indexName as the 
argument. 
c. 
Append nextArg as the last element of argList. 
d. 
Set index to index + 1. 
11. 
Return the result of calling the [[Call]] internal method of func, providing thisArg as the this value and 
argList as the list of arguments. 
The length property of the apply method is 2. 

NOTE The thisArg value is passed without modification as the this value. This is a change from Edition 3, where a 
undefined or null thisArg is replaced with the global object and ToObject is applied to all other values and that result is 
passed as the this value. 

15.3.4.4 Function.prototype.call (thisArg [ , arg1 [ , arg2, … ] ] ) 
When the call method is called on an object func with argument thisArg and optional arguments arg1, arg2 
etc, the following steps are taken: 

1. 
If IsCallable(func) is false, then throw a TypeError exception. 
2. 
Let argList be an empty List. 
3. 
If this method was called with more than one argument then in left to right order starting with arg1 append 
each argument as the last element of argList 
4. 
Return the result of calling the [[Call]] internal method of func, providing thisArg as the this value and 
argList as the list of arguments. 
The length property of the call method is 1. 


NOTE The thisArg value is passed without modification as the this value. This is a change from Edition 3, where a 
undefined or null thisArg is replaced with the global object and ToObject is applied to all other values and that result is 
passed as the this value. 

15.3.4.5 Function.prototype.bind (thisArg [, arg1 [, arg2, …]]) 
The bind method takes one or more arguments, thisArg and (optionally) arg1, arg2, etc, and returns a new 
function object by performing the following steps: 

1. 
Let Target be the this value. 
2. 
If IsCallable(Target) is false, throw a TypeError exception. 
3. 
Let A be a new (possibly empty) internal list of all of the argument values provided after thisArg (arg1, arg2 
etc), in order. 
4. 
Let F be a new native ECMAScript object . 
5. 
Set all the internal methods, except for [[Get]], of F as specified in 8.12. 
6. 
Set the [[Get]] internal property of F as specified in 15.3.5.4. 
7. 
Set the [[TargetFunction]] internal property of F to Target. 
8. 
Set the [[BoundThis]] internal property of F to the value of thisArg. 
9. 
Set the [[BoundArgs]] internal property of F to A. 
10. 
Set the [[Class]] internal property of F to "Function". 
11. 
Set the [[Prototype]] internal property of F to the standard built-in Function prototype object as specified in 
15.3.3.1. 
12. 
Set the [[Call]] internal property of F as described in 15.3.4.5.1. 
13. 
Set the [[Construct]] internal property of F as described in 15.3.4.5.2. 
14. 
Set the [[HasInstance]] internal property of F as described in 15.3.4.5.3. 
15. 
If the [[Class]] internal property of Target is "Function", then 
a. 
Let L be the length property of Target minus the length of A. 
b. 
Set the length own property of F to either 0 or L, whichever is larger. 
16. 
Else set the length own property of F to 0. 
17. 
Set the attributes of the length own property of F to the values specified in 15.3.5.1. 
18. 
Set the [[Extensible]] internal property of F to true. 
19. 
Let thrower be the [[ThrowTypeError]] function Object (13.2.3). 
20. 
Call the [[DefineOwnProperty]] internal method of F with arguments "caller", PropertyDescriptor 
{[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, and false. 
21. 
Call the [[DefineOwnProperty]] internal method of F with arguments "arguments", PropertyDescriptor 
{[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, and false. 
22. 
Return F. 
The length property of the bind method is 1. 

NOTE Function objects created using Function.prototype.bind do not have a prototype property or the 
[[Code]], [[FormalParameters]], and [[Scope]] internal properties. 

15.3.4.5.1 [[Call]] 
When the [[Call]] internal method of a function object, F, which was created using the bind function is called 
with a this value and a list of arguments ExtraArgs, the following steps are taken: 

1. 
Let boundArgs be the value of F’s [[BoundArgs]] internal property. 
2. 
Let boundThis be the value of F’s [[BoundThis]] internal property. 
3. 
Let target be the value of F’s [[TargetFunction]] internal property. 
4. 
Let args be a new list containing the same values as the list boundArgs in the same order followed by the 
same values as the list ExtraArgs in the same order. 
5. 
Return the result of calling the [[Call]] internal method of target providing boundThis as the this value and 
providing args as the arguments. 
15.3.4.5.2 [[Construct]] 
When the [[Construct]] internal method of a function object, F that was created using the bind function is called 
with a list of arguments ExtraArgs, the following steps are taken: 


1. 
Let target be the value of F’s [[TargetFunction]] internal property. 
2. 
If target has no [[Construct]] internal method, a TypeError exception is thrown. 
3. 
Let boundArgs be the value of F’s [[BoundArgs]] internal property. 
4. 
Let args be a new list containing the same values as the list boundArgs in the same order followed by the 
same values as the list ExtraArgs in the same order. 
5. 
Return the result of calling the [[Construct]] internal method of target providing args as the arguments. 
15.3.4.5.3 [[HasInstance]] (V) 
When the [[HasInstance]] internal method of a function object F, that was created using the bind function is 
called with argument V, the following steps are taken: 

1. 
Let target be the value of F’s [[TargetFunction]] internal property. 
2. 
If target has no [[HasInstance]] internal method, a TypeError exception is thrown. 
3. 
Return the result of calling the [[HasInstance]] internal method of target providing V as the argument. 
15.3.5 Properties of Function Instances 
In addition to the required internal properties, every function instance has a [[Call]] internal property and in 
most cases use a different version of the [[Get]] internal property. Depending on how they are created (see 

8.6.2 ,13.2, 15, and 15.3.4.5), function instances may have a [[HasInstance]] internal property, a [[Scope]] 
internal property, a [[Construct]] internal property, a [[FormalParameters]] internal property, a [[Code]] internal 
property, a [[TargetFunction]] internal property, a [[BoundThis]] internal property, and a [[BoundArgs]] internal 
property. 
The value of the [[Class]] internal property is "Function". 

Function instances that correspond to strict mode functions (13.2) and function instances created using the 
Function.prototype.bind method (15.3.4.5) have properties named “caller” and “arguments” that throw a 
TypeError exception. An ECMAScript implementation must not associate any implementation specific 
behaviour with accesses of these properties from strict mode function code. 

15.3.5.1 length 
The value of the length property is an integer that indicates the “typical” number of arguments expected by 
the function. However, the language permits the function to be invoked with some other number of arguments. 
The behaviour of a function when invoked on a number of arguments other than the number specified by itslength property depends on the function. This property has the attributes { [[Writable]]: false, [[Enumerable]]: 
false, [[Configurable]]: false }. 

15.3.5.2 prototype 
The value of the prototype property is used to initialise the [[Prototype]] internal property of a newly created 
object before the Function object is invoked as a constructor for that newly created object. This property has 
the attribute { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }. 

NOTE Function objects created using Function.prototype.bind do not have a prototype property. 

15.3.5.3 [[HasInstance]] (V) 
Assume F is a Function object. 

When the [[HasInstance]] internal method of F is called with value V, the following steps are taken: 

1. 
If V is not an object, return false. 
2. 
Let O be the result of calling the [[Get]] internal method of F with property name "prototype". 
3. 
If Type(O) is not Object, throw a TypeError exception. 
4. 
Repeat 
a. 
Let V be the value of the [[Prototype]] internal property of V. 

b. 
If V is null, return false. 
c. 
If O and V refer to the same object, return true. 
NOTE Function objects created using Function.prototype.bind have a different implementation of 
[[HasInstance]] defined in 15.3.4.5.3. 

15.3.5.4 [[Get]] (P) 
Function objects use a variation of the [[Get]] internal method used for other native ECMAScript objects 
(8.12.3). 

Assume F is a Function object. When the [[Get]] internal method of F is called with property name P, the 
following steps are taken: 

1. 
Let v be the result of calling the default [[Get]] internal method (8.12.3) on F passing P as the property name 
argument. 
2. 
If P is "caller" and v is a strict mode Function object, throw a TypeError exception. 
3. 
Return v. 
NOTE Function objects created using Function.prototype.bind use the default [[Get]] internal method. 

15.4 Array Objects 
Array objects give special treatment to a certain class of property names. A property name P (in the form of a 
String value) is an array index if and only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal to 
2^32.1. A property whose property name is an array index is also called an element. Every Array object has a 
length property whose value is always a nonnegative integer less than 2^32. The value of the lengthproperty is numerically greater than the name of every property whose name is an array index; whenever a 
property of an Array object is created or changed, other properties are adjusted as necessary to maintain this 
invariant. Specifically, whenever a property is added whose name is an array index, the length property is 
changed, if necessary, to be one more than the numeric value of that array index; and whenever the lengthproperty is changed, every property whose name is an array index whose value is not smaller than the new 
length is automatically deleted. This constraint applies only to own properties of an Array object and is 
unaffected by length or array index properties that may be inherited from its prototypes. 

An object, O, is said to be sparse if the following algorithm returns true: 

1. 
Let len be the result of calling the [[Get]] internal method of O with argument "length". 
2. 
For each integer i in the range 0.i<ToUint32(len) 
a. 
Let elem be the result of calling the [[GetOwnProperty]] internal method of O with argument 
ToString(i). 
b. 
If elem is undefined, return true. 
3. 
Return false. 
15.4.1 The Array Constructor Called as a Function 
When Array is called as a function rather than as a constructor, it creates and initialises a new Array object. 
Thus the function call Array(…) is equivalent to the object creation expression new Array(…) with the 
same arguments. 

15.4.1.1 Array ( [ item1 [ , item2 [ , … ] ] ] ) 
When the Array function is called the following steps are taken: 

1. 
Create and return a new Array object exactly as if the standard built-in constructor Array was used in a 
new expression with the same arguments (15.4.2). 

15.4.2 The Array Constructor 
When Array is called as part of a new expression, it is a constructor: it initialises the newly created object. 

15.4.2.1 newArray ( [ item0 [ , item1 [ , … ] ] ] ) 
This description applies if and only if the Array constructor is given no arguments or at least two arguments. 

The [[Prototype]] internal property of the newly constructed object is set to the original Array prototype object, 
the one that is the initial value of Array.prototype (15.4.3.1). 

The [[Class]] internal property of the newly constructed object is set to "Array". 

The [[Extensible]] internal property of the newly constructed object is set to true. 

The length property of the newly constructed object is set to the number of arguments. 

The 0 property of the newly constructed object is set to item0 (if supplied); the 1 property of the newly 
constructed object is set to item1 (if supplied); and, in general, for as many arguments as there are, the k 
property of the newly constructed object is set to argument k, where the first argument is considered to be 
argument number 0. These properties all have the attributes {[[Writable]]: true, [[Enumerable]]: true, 
[[Configurable]]: true}. 

15.4.2.2 new Array (len) 
The [[Prototype]] internal property of the newly constructed object is set to the original Array prototype object, 
the one that is the initial value of Array.prototype (15.4.3.1). The [[Class]] internal property of the newly 
constructed object is set to "Array". The [[Extensible]] internal property of the newly constructed object is set 
to true. 

If the argument len is a Number and ToUint32(len) is equal to len, then the length property of the newly 
constructed object is set to ToUint32(len). If the argument len is a Number and ToUint32(len) is not equal to len, 
a RangeError exception is thrown. 

If the argument len is not a Number, then the length property of the newly constructed object is set to 1 and 
the 0 property of the newly constructed object is set to len with attributes {[[Writable]]: true, [[Enumerable]]: 
true, [[Configurable]]: true}.. 

15.4.3 Properties of the Array Constructor 
The value of the [[Prototype]] internal property of the Array constructor is the Function prototype object 
(15.3.4). 

Besides the internal properties and the length property (whose value is 1), the Array constructor has the 
following properties: 

15.4.3.1 Array.prototype 
The initial value of Array.prototype is the Array prototype object (15.4.4). 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.4.3.2 Array.isArray ( arg ) 
The isArray function takes one argument arg, and returns the Boolean value true if the argument is an object 
whose class internal property is "Array"; otherwise it returns false. The following steps are taken: 


1. 
If Type(arg) is not Object, return false. 
2. 
If the value of the [[Class]] internal property of arg is "Array", then return true. 
3. 
Return false. 
15.4.4 Properties of the Array Prototype Object 
The value of the [[Prototype]] internal property of the Array prototype object is the standard built-in Object 
prototype object (15.2.4). 

The Array prototype object is itself an array; its [[Class]] is "Array", and it has a length property (whose 
initial value is +0) and the special [[DefineOwnProperty]] internal method described in 15.4.5.1. 

In following descriptions of functions that are properties of the Array prototype object, the phrase “this object” 
refers to the object that is the this value for the invocation of the function. It is permitted for the this to be an 
object for which the value of the [[Class]] internal property is not "Array". 

NOTE The Array prototype object does not have a valueOf property of its own; however, it inherits the valueOf 
property from the standard built-in Object prototype Object. 

15.4.4.1 Array.prototype.constructor 
The initial value of Array.prototype.constructor is the standard built-in Array constructor. 

15.4.4.2 Array.prototype.toString ( ) 
When the toString method is called, the following steps are taken: 

1. 
Let array be the result of calling ToObject on the this value. 
2. 
Let func be the result of calling the [[Get]] internal method of array with argument "join". 
3. 
If IsCallable(func) is false, then let func be the standard built-in method Object.prototype.toString (15.2.4.2). 
4. 
Return the result of calling the [[Call]] internal method of func providing array as the this value and an 
empty arguments list. 
NOTE The toString function is intentionally generic; it does not require that its this value be an Array object. 
Therefore it can be transferred to other kinds of objects for use as a method. Whether the toString function can be 
applied successfully to a host object is implementation-dependent. 

15.4.4.3 Array.prototype.toLocaleString ( ) 
The elements of the array are converted to Strings using their toLocaleString methods, and these Strings 
are then concatenated, separated by occurrences of a separator String that has been derived in an 
implementation-defined locale-specific way. The result of calling this function is intended to be analogous to 
the result of toString, except that the result of this function is intended to be locale-specific. 

The result is calculated as follows: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let arrayLen be the result of calling the [[Get]] internal method of array with argument "length". 
3. 
Let len be ToUint32(arrayLen). 
4. 
Let separator be the String value for the list-separator String appropriate for the host environment’s current 
locale (this is derived in an implementation-defined way). 
5. 
If len is zero, return the empty String. 
6. 
Let firstElement be the result of calling the [[Get]] internal method of array with argument "0". 
7. 
If firstElement is undefined or null, then 
a. 
Let R be the empty String. 
8. 
Else 
a. 
Let elementObj be ToObject(firstElement). 

b. 
Let func be the result of calling the [[Get]] internal method of elementObj with argument 
"toLocaleString". 
c. 
If IsCallable(func) is false, throw a TypeError exception. 
d. 
Let R be the result of calling the [[Call]] internal method of func providing elementObj as the this 
value and an empty arguments list. 
9. 
Let k be 1. 
10. 
Repeat, while k < len 
a. 
Let S be a String value produced by concatenating R and separator. 
b. 
Let nextElement be the result of calling the [[Get]] internal method of array with argument 
ToString(k). 
c. 
If nextElement is undefined or null, then 
i. Let R be the empty String. 
d. 
Else 
i. Let elementObj be ToObject(nextElement). 
ii. 
Let func be the result of calling the [[Get]] internal method of elementObj with argument 
"toLocaleString". 
iii. 
If IsCallable(func) is false, throw a TypeError exception. 
iv. 
Let R be the result of calling the [[Call]] internal method of func providing elementObj as 
the this value and an empty arguments list. 
e. 
Let R be a String value produced by concatenating S and R. 
f. 
Increase k by 1. 
11. 
Return R. 
NOTE 1 The first parameter to this function is likely to be used in a future version of this standard; it is recommended 
that implementations do not use this parameter position for anything else. 

NOTE 2 The toLocaleString function is intentionally generic; it does not require that its this value be an Array object. 
Therefore it can be transferred to other kinds of objects for use as a method. Whether the toLocaleString function can 
be applied successfully to a host object is implementation-dependent. 

15.4.4.4 Array.prototype.concat ( [ item1 [ , item2 [ , … ] ] ] ) 
When the concat method is called with zero or more arguments item1, item2, etc., it returns an array 
containing the array elements of the object followed by the array elements of each argument in order. 

The following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let A be a new array created as if by the expression new Array() where Array is the standard built-in 
constructor with that name. 
3. 
Let n be 0. 
4. 
Let items be an internal List whose first element is O and whose subsequent elements are, in left to right 
order, the arguments that were passed to this function invocation. 
5. 
Repeat, while items is not empty 
a. 
Remove the first element from items and let E be the value of the element. 
b. 
If the value of the [[Class]] internal property of E is "Array", then 
i. Let k be 0. 
ii. 
Let len be the result of calling the [[Get]] internal method of E with argument "length". 
iii. 
Repeat, while k < len 
1. 
Let P be ToString(k). 
2. 
Let exists be the result of calling the [[HasProperty]] internal method of E with P. 
3. 
If exists is true, then 
a Let subElement be the result of calling the [[Get]] internal method of E 
with argument P. 
b 
Call the [[DefineOwnProperty]] internal method of A with arguments 
ToString(n), Property Descriptor {[[Value]]: subElement, [[Writable]]: 
true, [[Enumerable]]: true, [[Configurable]]: true}, and false. 

4. 
Increase n by 1. 
5. 
Increase k by 1. 

c. 
Else, E is not an Array 
i. 
Call the [[DefineOwnProperty]] internal method of A with arguments ToString(n), Property 
Descriptor {[[Value]]: E, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 
and false. 
ii. Increase n by 1. 
6. 
Return A. 
The length property of the concat method is 1. 

NOTE The concat function is intentionally generic; it does not require that its this value be an Array object. 
Therefore it can be transferred to other kinds of objects for use as a method. Whether the concat function can be applied 
successfully to a host object is implementation-dependent. 

15.4.4.5 Array.prototype.join (separator) 
The elements of the array are converted to Strings, and these Strings are then concatenated, separated by 
occurrences of the separator. If no separator is provided, a single comma is used as the separator. 

The join method takes one argument, separator, and performs the following steps: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length". 
3. 
Let len be ToUint32(lenVal). 
4. 
If separator is undefined, let separator be the single-character String ",". 
5. 
Let sep be ToString(separator). 
6. 
If len is zero, return the empty String. 
7. 
Let element0 be the result of calling the [[Get]] internal method of O with argument "0". 
8. 
If element0 is undefined or null, let R be the empty String; otherwise, Let R be ToString(element0). 
9. 
Let k be 1. 
10. 
Repeat, while k < len 
a. 
Let S be the String value produced by concatenating R and sep. 
b. 
Let element be the result of calling the [[Get]] internal method of O with argument ToString(k). 
c. 
If element is undefined or null, Let next be the empty String; otherwise, let next be 
ToString(element). 
d. 
Let R be a String value produced by concatenating S and next. 
e. 
Increase k by 1. 
11. 
Return R. 
The length property of the join method is 1. 

NOTE The join function is intentionally generic; it does not require that its this value be an Array object. Therefore, 
it can be transferred to other kinds of objects for use as a method. Whether the join function can be applied successfully 
to a host object is implementation-dependent. 

15.4.4.6 Array.prototype.pop ( ) 
The last element of the array is removed from the array and returned. 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length". 
3. 
Let len be ToUint32(lenVal). 
4. 
If len is zero, 
a. 
Call the [[Put]] internal method of O with arguments "length", 0, and true. 
b. 
Return undefined. 
5. 
Else, len > 0 
a. 
Let indx be ToString(len.1). 
b. 
Let element be the result of calling the [[Get]] internal method of O with argument indx. 
c. 
Call the [[Delete]] internal method of O with arguments indx and true. 
d. 
Call the [[Put]] internal method of O with arguments "length", indx, and true. 

e. 
Return element. 
NOTE The pop function is intentionally generic; it does not require that its this value be an Array object. Therefore it 
can be transferred to other kinds of objects for use as a method. Whether the pop function can be applied successfully to 
a host object is implementation-dependent. 

15.4.4.7 Array.prototype.push ( [ item1 [ , item2 [ , … ] ] ] ) 
The arguments are appended to the end of the array, in the order in which they appear. The new length of the 
array is returned as the result of the call. 

When the push method is called with zero or more arguments item1, item2, etc., the following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length". 
3. 
Let n be ToUint32(lenVal). 
4. 
Let items be an internal List whose elements are, in left to right order, the arguments that were passed to this 
function invocation. 
5. 
Repeat, while items is not empty 
a. 
Remove the first element from items and let E be the value of the element. 
b. 
Call the [[Put]] internal method of O with arguments ToString(n), E, and true. 
c. 
Increase n by 1. 
6. 
Call the [[Put]] internal method of O with arguments "length", n, and true. 
7. 
Return n. 
The length property of the push method is 1. 

NOTE The push function is intentionally generic; it does not require that its this value be an Array object. Therefore 
it can be transferred to other kinds of objects for use as a method. Whether the push function can be applied successfully 
to a host object is implementation-dependent. 

15.4.4.8 Array.prototype.reverse ( ) 
The elements of the array are rearranged so as to reverse their order. The object is returned as the result of 
the call. 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length". 
3. 
Let len be ToUint32(lenVal). 
4. 
Let middle be floor(len/2). 
5. 
Let lower be 0. 
6. 
Repeat, while lower ≠ 
middle 
a. 
Let upper be len. lower -1. 
b. 
Let upperP be ToString(upper). 
c. 
Let lowerP be ToString(lower). 
d. 
Let lowerValue be the result of calling the [[Get]] internal method of O with argument lowerP. 
e. 
Let upperValue be the result of calling the [[Get]] internal method of O with argument upperP . 
f. 
Let lowerExists be the result of calling the [[HasProperty]] internal method of O with argument 
lowerP. 
g. 
Let upperExists be the result of calling the [[HasProperty]] internal method of O with argument 
upperP. 
h. 
If lowerExists is true and upperExists is true, then 
i. Call the [[Put]] internal method of O with arguments lowerP, upperValue, and true . 
ii. Call the [[Put]] internal method of O with arguments upperP, lowerValue, and true . 
i. 
Else if lowerExists is false and upperExists is true, then 
i. Call the [[Put]] internal method of O with arguments lowerP, upperValue, and true . 
ii. Call the [[Delete]] internal method of O, with arguments upperP and true. 
j. 
Else if lowerExists is true and upperExists is false, then 
i. Call the [[Delete]] internal method of O, with arguments lowerP and true . 

ii. Call the [[Put]] internal method of O with arguments upperP, lowerValue, and true . 
k. 
Else, both lowerExists and upperExists are false 
i. No action is required. 
l. 
Increase lower by 1. 
7. 
Return O . 
NOTE The reverse function is intentionally generic; it does not require that its this value be an Array object. 
Therefore, it can be transferred to other kinds of objects for use as a method. Whether the reverse function can be 
applied successfully to a host object is implementation-dependent. 

15.4.4.9 Array.prototype.shift ( ) 
The first element of the array is removed from the array and returned. 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length". 
3. 
Let len be ToUint32(lenVal). 
4. 
If len is zero, then 
a. 
Call the [[Put]] internal method of O with arguments "length", 0, and true. 
b. 
Return undefined. 
5. 
Let first be the result of calling the [[Get]] internal method of O with argument "0". 
6. 
Let k be 1. 
7. 
Repeat, while k < len 
a. 
Let from be ToString(k). 
b. 
Let to be ToString(k.1). 
c. 
Let fromPresent be the result of calling the [[HasProperty]] internal method of O with argument 
from. 
d. 
If fromPresent is true, then 
i. Let fromVal be the result of calling the [[Get]] internal method of O with argument from. 
ii. Call the [[Put]] internal method of O with arguments to, fromVal, and true. 
e. 
Else, fromPresent is false 
i. Call the [[Delete]] internal method of O with arguments to and true. 
f. 
Increase k by 1. 
8. 
Call the [[Delete]] internal method of O with arguments ToString(len.1) and true. 
9. 
Call the [[Put]] internal method of O with arguments "length", (len.1) , and true. 
10. 
Return first. 
NOTE The shift function is intentionally generic; it does not require that its this value be an Array object. Therefore 
it can be transferred to other kinds of objects for use as a method. Whether the shift function can be applied 
successfully to a host object is implementation-dependent. 

15.4.4.10 Array.prototype.slice (start, end) 
The slice method takes two arguments, start and end, and returns an array containing the elements of the 
array from element start up to, but not including, element end (or through the end of the array if end is 
undefined). If start is negative, it is treated as length+start where length is the length of the array. If end is 
negative, it is treated as length+end where length is the length of the array. The following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let A be a new array created as if by the expression new Array() where Array is the standard built-in 
constructor with that name. 
3. 
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length". 
4. 
Let len be ToUint32(lenVal). 
5. 
Let relativeStart be ToInteger(start). 
6. 
If relativeStart is negative, let k be max((len + relativeStart),0); else let k be min(relativeStart, len). 
7. 
If end is undefined, let relativeEnd be len; else let relativeEnd be ToInteger(end). 
8. 
If relativeEnd is negative, let final be max((len + relativeEnd),0); else let final be min(relativeEnd, len). 
9. 
Let n be 0. 
10. 
Repeat, while k < final 

a. 
Let Pk be ToString(k). 
b. 
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk. 
c. 
If kPresent is true, then 
i. Let kValue be the result of calling the [[Get]] internal method of O with argument Pk. 
ii. 
Call the [[DefineOwnProperty]] internal method of A with arguments ToString(n), Property 
Descriptor {[[Value]]: kValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: 
true}, and false. 
d. 
Increase k by 1. 
e. 
Increase n by 1. 
11. 
Return A. 
The length property of the slice method is 2. 

NOTE The slice function is intentionally generic; it does not require that its this value be an Array object. Therefore 
it can be transferred to other kinds of objects for use as a method. Whether the slice function can be applied 
successfully to a host object is implementation-dependent. 

15.4.4.11 Array.prototype.sort (comparefn) 
The elements of this array are sorted. The sort is not necessarily stable (that is, elements that compare equal 
do not necessarily remain in their original order). If comparefn is not undefined, it should be a function that 
accepts two arguments x and y and returns a negative value if x < y, zero if x = y, or a positive value if x > y. 

Let obj be the result of calling ToObject passing the this value as the argument. 

Let len be the result of applying Uint32 to the result of calling the [[Get]] internal method of obj with argument 
"length". 

If comparefn is not undefined and is not a consistent comparison function for the elements of this array (see 
below), the behaviour of sort is implementation-defined. 

Let proto be the value of the [[Prototype]] internal property of obj. If proto is not null and there exists an integer 
j such that all of the conditions below are satisfied then the behaviour of sort is implementation-defined: 

. 
obj is sparse (15.4) 

. 
0 . 
j < len 
. 
The result of calling the [[HasProperty]] internal method of proto with argument ToString(j) is true. 
The behaviour of sort is also implementation defined if obj is sparse and any of the following conditions are 
true: 

. 
The [[Extensible]] internal property of obj is false. 
. 
Any array index property of obj whose name is a nonnegative integer less than len is a data property 
whose [[Configurable]] attribute is false. 
The behaviour of sort is also implementation defined if any array index property of obj whose name is a 
nonnegative integer less than len is an accessor property or is a data property whose [[Writable]] attribute is 
false. 

Otherwise, the following steps are taken. 

1. 
Perform an implementation-dependent sequence of calls to the [[Get]] , [[Put]], and [[Delete]] internal 
methods of obj and to SortCompare (described below), where the first argument for each call to [[Get]], 
[[Put]], or [[Delete]] is a nonnegative integer less than len and where the arguments for calls to SortCompare 
are results of previous calls to the [[Get]] internal method. The throw argument to the [[Put]] and [[Delete]] 
internal methods will be the value true. If obj is not sparse then [[Delete]] must not be called. 
2. 
Return obj. 

The returned object must have the following two properties. 

. 
There must be some mathematical permutation π of the nonnegative integers less than len, such that 
for every nonnegative integer j less than len, if property old[j] existed, then new[π(j)] is exactly the 
same value as old[j],. But if property old[j] did not exist, then new[π(j)] does not exist. 
. 
Then for all nonnegative integers j and k, each less than len, if SortCompare(j,k) < 0 (see SortCompare 
below), then π(j) < π(k). 
Here the notation old[j] is used to refer to the hypothetical result of calling the [[Get]] internal method of obj 
with argument j before this function is executed, and the notation new[j] to refer to the hypothetical result of 
calling the [[Get]] internal method of obj with argument j after this function has been executed. 

A function comparefn is a consistent comparison function for a set of values S if all of the requirements below 
are met for all values a, b, and c (possibly the same value) in the set S: The notation a <CF b means 
comparefn(a,b) < 0; a =CF b means comparefn(a,b) = 0 (of either sign); and a >CF b means comparefn(a,b) > 0. 

. 
Calling comparefn(a,b) always returns the same value v when given a specific pair of values a and b as its two 
arguments. Furthermore, Type(v) is Number, and v is not NaN. Note that this implies that exactly one of a <CF b, 
a =CF b, and a >CF b will be true for a given pair of a and b. 
. 
Calling comparefn(a,b) does not modify the this object. 
. 
a =CF a (reflexivity) 
. 
If a =CF b, then b =CF a (symmetry) 
. 
If a =CF b and b =CF c, then a =CF c (transitivity of =CF) 
. 
If a <CF b and b <CF c, then a <CF c (transitivity of <CF) 
. 
If a >CF b and b >CF c, then a >CF c (transitivity of >CF) 
NOTE The above conditions are necessary and sufficient to ensure that comparefn divides the set S into equivalence 
classes and that these equivalence classes are totally ordered. 

When the SortCompare abstract operation is called with two arguments j and k, the following steps are taken: 

1. 
Let jString be ToString(j). 
2. 
Let kString be ToString(k). 
3. 
Let hasj be the result of calling the [[HasProperty]] internal method of obj with argument jString. 
4. 
Let hask be the result of calling the [[HasProperty]] internal method of obj with argument kString. 
5. 
If hasj and hask are both false, then return +0. 
6. 
If hasj is false, then return 1. 
7. 
If hask is false, then return -1. 
8. 
Let x be the result of calling the [[Get]] internal method of obj with argument jString. 
9. 
Let y be the result of calling the [[Get]] internal method of obj with argument kString. 
10. 
If x and y are both undefined, return +0. 
11. 
If x is undefined, return 1. 
12. 
If y is undefined, return -1. 
13. 
If the argument comparefn is not undefined, then 
a. 
If IsCallable(comparefn) is false, throw a TypeError exception. 
b. 
Return the result of calling the [[Call]] internal method of comparefn passing undefined as the this 
value and with arguments x and y. 
14. 
Let xString be ToString(x). 
15. 
Let yString be ToString(y). 
16. 
If xString < yString, return -1. 
17. 
If xString > yString, return 1. 
18. 
Return +0. 
NOTE 1 Because non-existent property values always compare greater than undefined property values, and 
undefined always compares greater than any other value, undefined property values always sort to the end of the result, 
followed by non-existent property values. 

NOTE 2 The sort function is intentionally generic; it does not require that its this value be an Array object. Therefore, 
it can be transferred to other kinds of objects for use as a method. Whether the sort function can be applied successfully 
to a host object is implementation-dependent. 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let A be a new array created as if by the expression new Array()where Array is the standard built-in 
constructor with that name. 
3. 
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length". 
4. 
Let len be ToUint32(lenVal). 
5. 
Let relativeStart be ToInteger(start). 
6. 
If relativeStart is negative, let actualStart be max((len + relativeStart),0); else let actualStart be 
min(relativeStart, len). 
7. 
Let actualDeleteCount be min(max(ToInteger(deleteCount),0), len . actualStart). 
8. 
Let k be 0. 
9. 
Repeat, while k < actualDeleteCount 
a. 
Let from be ToString(relativeStart+k). 
b. 
Let fromPresent be the result of calling the [[HasProperty]] internal method of O with argument 
from. 
c. 
If fromPresent is true, then 
i. Let fromValue be the result of calling the [[Get]] internal method of O with argument from. 
ii. 
Call the [[DefineOwnProperty]] internal method of A with arguments ToString(k), Property 
Descriptor {[[Value]]: fromValue, [[Writable]]: true, [[Enumerable]]: true, 
[[Configurable]]: true}, and false. 
d. 
Increment k by 1. 
10. 
Let items be an internal List whose elements are, in left to right order, the portion of the actual argument list 
starting with item1. The list will be empty if no such items are present. 
11. 
Let itemCount be the number of elements in items. 
12. 
If itemCount < actualDeleteCount, then 
a. 
Let k be actualStart. 
b. 
Repeat, while k < (len . actualDeleteCount) 
i. Let from be ToString(k+actualDeleteCount). 
ii. 
Let to be ToString(k+itemCount). 
iii. 
Let fromPresent be the result of calling the [[HasProperty]] internal method of O with 
argument from. 
iv. 
If fromPresent is true, then 
1. 
Let fromValue be the result of calling the [[Get]] internal method of O with 
argument from. 
2. 
Call the [[Put]] internal method of O with arguments to, fromValue, and true. 
v. 
Else, fromPresent is false 
1. 
Call the [[Delete]] internal method of O with arguments to and true. 
vi. 
Increase k by 1. 
c. 
Let k be len. 
d. 
Repeat, while k > (len . actualDeleteCount + itemCount) 
i. Call the [[Delete]] internal method of O with arguments ToString(k.1) and true. 
ii. 
Decrease k by 1. 
13. 
Else if itemCount > actualDeleteCount, then 
a. 
Let k be (len . actualDeleteCount). 
b. 
Repeat, while k > actualStart 
i. Let from be ToString(k + actualDeleteCount . 1). 
ii. 
Let to be ToString(k + itemCount . 1) 
iii. 
Let fromPresent be the result of calling the [[HasProperty]] internal method of O with 
argument from. 
iv. 
If fromPresent is true, then 
1. 
Let fromValue be the result of calling the [[Get]] internal method of O with 
argument from. 
2. 
Call the [[Put]] internal method of O with arguments to, fromValue, and true. 
v. 
Else, fromPresent is false 
1. 
Call the [[Delete]] internal method of O with argument to and true. 

vi. Decrease k by 1. 
14. 
Let k be actualStart. 
15. 
Repeat, while items is not empty 
a. 
Remove the first element from items and let E be the value of that element. 
b. 
Call the [[Put]] internal method of O with arguments ToString(k), E, and true. 
c. 
Increase k by 1. 
16. 
Call the [[Put]] internal method of O with arguments "length", (len . actualDeleteCount + itemCount), 
and true. 
17. 
Return A. 
The length property of the splice method is 2. 

NOTE The splice function is intentionally generic; it does not require that its this value be an Array object. 
Therefore it can be transferred to other kinds of objects for use as a method. Whether the splice function can be applied 
successfully to a host object is implementation-dependent. 

15.4.4.13 Array.prototype.unshift ( [ item1 [ , item2 [ , … ] ] ] ) 
The arguments are prepended to the start of the array, such that their order within the array is the same as the 
order in which they appear in the argument list. 

When the unshift method is called with zero or more arguments item1, item2, etc., the following steps are 
taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenVal be the result of calling the [[Get]] internal method of O with argument "length". 
3. 
Let len be ToUint32(lenVal). 
4. 
Let argCount be the number of actual arguments. 
5. 
Let k be len. 
6. 
Repeat, while k > 0, 
a. 
Let from be ToString(k.1). 
b. 
Let to be ToString(k+argCount -1). 
c. 
Let fromPresent be the result of calling the [[HasProperty]] internal method of O with argument 
from. 
d. 
If fromPresent is true, then 
i. Let fromValue be the result of calling the [[Get]] internal method of O with argument from. 
ii. Call the [[Put]] internal method of O with arguments to, fromValue, and true. 
e. 
Else, fromPresent is false 
i. Call the [[Delete]] internal method of O with arguments to, and true. 
f. 
Decrease k by 1. 
7. 
Let j be 0. 
8. 
Let items be an internal List whose elements are, in left to right order, the arguments that were passed to this 
function invocation. 
9. 
Repeat, while items is not empty 
a. 
Remove the first element from items and let E be the value of that element. 
b. 
Call the [[Put]] internal method of O with arguments ToString(j), E, and true. 
c. 
Increase j by 1. 
10. 
Call the [[Put]] internal method of O with arguments "length", len+argCount, and true. 
11. 
Return len+argCount. 
The length property of the unshift method is 1. 

NOTE The unshift function is intentionally generic; it does not require that its this value be an Array object. 
Therefore it can be transferred to other kinds of objects for use as a method. Whether the unshift function can be 
applied successfully to a host object is implementation-dependent. 


15.4.4.14 Array.prototype.indexOf ( searchElement [ , fromIndex ] ) 
indexOf compares searchElement to the elements of the array, in ascending order, using the internal Strict 
Equality Comparison Algorithm (11.9.6), and if found at one or more positions, returns the index of the first 
such position; otherwise, -1 is returned. 

The optional second argument fromIndex defaults to 0 (i.e. the whole array is searched). If it is greater than or 
equal to the length of the array, -1 is returned, i.e. the array will not be searched. If it is negative, it is used as 
the offset from the end of the array to compute fromIndex. If the computed index is less than 0, the whole array 
will be searched. 

When the indexOf method is called with one or two arguments, the following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length". 
3. 
Let len be ToUint32(lenValue). 
4. 
If len is 0, return -1. 
5. 
If argument fromIndex was passed let n be ToInteger(fromIndex); else let n be 0. 
6. 
If n . 
len, return -1. 
7. 
If n . 0, then 
a. 
Let k be n. 
8. 
Else, n<0 
a. 
Let k be len - abs(n). 
b. 
If k is less than 0, then let k be 0. 
9. 
Repeat, while k<len 
a. 
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument 
ToString(k). 
b. 
If kPresent is true, then 
i. 
Let elementK be the result of calling the [[Get]] internal method of O with the argument 
ToString(k). 
ii. 
Let same be the result of applying the Strict Equality Comparison Algorithm to 
searchElement and elementK. 
iii. If same is true, return k. 
c. 
Increase k by 1. 
10. 
Return -1. 
The length property of the indexOf method is 1. 

NOTE The indexOf function is intentionally generic; it does not require that its this value be an Array object. 
Therefore it can be transferred to other kinds of objects for use as a method. Whether the indexOf function can be 
applied successfully to a host object is implementation-dependent. 

15.4.4.15 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] ) 
lastIndexOf compares searchElement to the elements of the array in descending order using the internal 
Strict Equality Comparison Algorithm (11.9.6), and if found at one or more positions, returns the index of the 
last such position; otherwise, -1 is returned. 

The optional second argument fromIndex defaults to the array's length (i.e. the whole array is searched). If it is 
greater than or equal to the length of the array, the whole array will be searched. If it is negative, it is used as 
the offset from the end of the array to compute fromIndex. If the computed index is less than 0, -1 is returned. 

When the lastIndexOf method is called with one or two arguments, the following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length". 
3. 
Let len be ToUint32(lenValue). 
4. 
If len is 0, return -1. 
5. 
If argument fromIndex was passed let n be ToInteger(fromIndex); else let n be len. 

6. 
If n . 
0, then let k be min(n, len . 1). 
7. 
Else, n < 0 
a. 
Let k be len - abs(n). 
8. 
Repeat, while k. 
0 
a. 
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument 
ToString(k). 
b. 
If kPresent is true, then 
i. 
Let elementK be the result of calling the [[Get]] internal method of O with the argument 
ToString(k). 
ii. 
Let same be the result of applying the Strict Equality Comparision Algorithm to 
searchElement and elementK. 
iii. If same is true, return k. 
c. 
Decrease k by 1. 
9. 
Return -1. 
The length property of the lastIndexOf method is 1. 

NOTE The lastIndexOf function is intentionally generic; it does not require that its this value be an Array object. 
Therefore it can be transferred to other kinds of objects for use as a method. Whether the lastIndexOf function can be 
applied successfully to a host object is implementation-dependent. 

15.4.4.16 Array.prototype.every ( callbackfn [ , thisArg ] ) 
callbackfn should be a function that accepts three arguments and returns a value that is coercible to the 
Boolean value true or false. every calls callbackfn once for each element present in the array, in ascending 
order, until it finds one where callbackfn returns false. If such an element is found, every immediately returns 
false. Otherwise, if callbackfn returned true for all elements, every will return true. callbackfn is called only for 
elements of the array which actually exist; it is not called for missing elements of the array. 

If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not 
provided, undefined is used instead. 

callbackfn is called with three arguments: the value of the element, the index of the element, and the object 
being traversed. 

every does not directly mutate the object on which it is called but the object may be mutated by the calls to 
callbackfn. 

The range of elements processed by every is set before the first call to callbackfn. Elements which are 
appended to the array after the call to every begins will not be visited by callbackfn. If existing elements of the 
array are changed, their value as passed to callbackfn will be the value at the time every visits them; 
elements that are deleted after the call to every begins and before being visited are not visited. every acts 
like the "for all" quantifier in mathematics. In particular, for an empty array, it returns true. 

When the every method is called with one or two arguments, the following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length". 
3. 
Let len be ToUint32(lenValue). 
4. 
If IsCallable(callbackfn) is false, throw a TypeError exception. 
5. 
If thisArg was supplied, let T be thisArg; else let T be undefined. 
6. 
Let k be 0. 
7. 
Repeat, while k < len 
a. 
Let Pk be ToString(k). 
b. 
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk. 
c. 
If kPresent is true, then 
i. 
Let kValue be the result of calling the [[Get]] internal method of O with argument Pk. 
ii. 
Let testResult be the result of calling the [[Call]] internal method of callbackfn with T as the 
this value and argument list containing kValue, k, and O. 

iii. If ToBoolean(testResult) is false, return false. 
d. Increase k by 1. 
8. Return true. 
The length property of the every method is 1. 

NOTE The every function is intentionally generic; it does not require that its this value be an Array object. Therefore 
it can be transferred to other kinds of objects for use as a method. Whether the every function can be applied 
successfully to a host object is implementation-dependent. 

15.4.4.17 Array.prototype.some ( callbackfn [ , thisArg ] ) 
callbackfn should be a function that accepts three arguments and returns a value that is coercible to the 
Boolean value true or false. some calls callbackfn once for each element present in the array, in ascending 
order, until it finds one where callbackfn returns true. If such an element is found, some immediately returns 
true. Otherwise, some returns false. callbackfn is called only for elements of the array which actually exist; it is 
not called for missing elements of the array. 

If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not 
provided, undefined is used instead. 

callbackfn is called with three arguments: the value of the element, the index of the element, and the object 
being traversed. 

some does not directly mutate the object on which it is called but the object may be mutated by the calls to 
callbackfn. 

The range of elements processed by some is set before the first call to callbackfn. Elements that are appended 
to the array after the call to some begins will not be visited by callbackfn. If existing elements of the array are 
changed, their value as passed to callbackfn will be the value at the time that some visits them; elements that 
are deleted after the call to some begins and before being visited are not visited. some acts like the "exists" 
quantifier in mathematics. In particular, for an empty array, it returns false. 

When the some method is called with one or two arguments, the following steps are taken: 

1. Let O be the result of calling ToObject passing the this value as the argument. 
2. Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length". 
3. Let len be ToUint32(lenValue). 
4. If IsCallable(callbackfn) is false, throw a TypeError exception. 
5. If thisArg was supplied, let T be thisArg; else let T be undefined. 
6. Let k be 0. 
7. Repeat, while k < len 
a. Let Pk be ToString(k). 
b. Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk. 
c. If kPresent is true, then 
i. Let kValue be the result of calling the [[Get]] internal method of O with argument Pk. 
ii. 
Let testResult be the result of calling the [[Call]] internal method of callbackfn with T as the 
this value and argument list containing kValue, k, and O. 
iii. If ToBoolean(testResult) is true, return true. 
d. Increase k by 1. 
8. Return false. 
The length property of the some method is 1. 

NOTE The some function is intentionally generic; it does not require that its this value be an Array object. Therefore 
it can be transferred to other kinds of objects for use as a method. Whether the some function can be applied successfully 
to a host object is implementation-dependent. 


15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] ) 
callbackfn should be a function that accepts three arguments. forEach calls callbackfn once for each element 
present in the array, in ascending order. callbackfn is called only for elements of the array which actually exist; 
it is not called for missing elements of the array. 

If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not 
provided, undefined is used instead. 

callbackfn is called with three arguments: the value of the element, the index of the element, and the object 
being traversed. 

forEach does not directly mutate the object on which it is called but the object may be mutated by the calls to 
callbackfn. 

The range of elements processed by forEach is set before the first call to callbackfn. Elements which are 
appended to the array after the call to forEach begins will not be visited by callbackfn. If existing elements of 
the array are changed, their value as passed to callback will be the value at the time forEach visits them; 
elements that are deleted after the call to forEach begins and before being visited are not visited. 

When the forEach method is called with one or two arguments, the following steps are taken: 

1. Let O be the result of calling ToObject passing the this value as the argument. 
2. Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length". 
3. Let len be ToUint32(lenValue). 
4. If IsCallable(callbackfn) is false, throw a TypeError exception. 
5. If thisArg was supplied, let T be thisArg; else let T be undefined. 
6. Let k be 0. 
7. Repeat, while k < len 
a. Let Pk be ToString(k). 
b. Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk. 
c. If kPresent is true, then 
i. Let kValue be the result of calling the [[Get]] internal method of O with argument Pk. 
ii. 
Call the [[Call]] internal method of callbackfn with T as the this value and argument list 
containing kValue, k, and O. 
d. Increase k by 1. 
8. Return. 
The length property of the forEach method is 1. 

NOTE The forEach function is intentionally generic; it does not require that its this value be an Array object. 
Therefore it can be transferred to other kinds of objects for use as a method. Whether the forEach function can be 
applied successfully to a host object is implementation-dependent. 

15.4.4.19 Array.prototype.map ( callbackfn [ , thisArg ] ) 
callbackfn should be a function that accepts three arguments. map calls callbackfn once for each element in the 
array, in ascending order, and constructs a new Array from the results. callbackfn is called only for elements of 
the array which actually exist; it is not called for missing elements of the array. 

If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not 
provided, undefined is used instead. 

callbackfn is called with three arguments: the value of the element, the index of the element, and the object 
being traversed. 

map does not directly mutate the object on which it is called but the object may be mutated by the calls to 
callbackfn. 


The range of elements processed by map is set before the first call to callbackfn. Elements which are 
appended to the array after the call to map begins will not be visited by callbackfn. If existing elements of the 
array are changed, their value as passed to callbackfn will be the value at the time map visits them; elements 
that are deleted after the call to map begins and before being visited are not visited. 

When the map method is called with one or two arguments, the following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length". 
3. 
Let len be ToUint32(lenValue). 
4. 
If IsCallable(callbackfn) is false, throw a TypeError exception. 
5. 
If thisArg was supplied, let T be thisArg; else let T be undefined. 
6. 
Let A be a new array created as if by the expression new Array(len) where Array is the standard built-
in constructor with that name and len is the value of len. 
7. 
Let k be 0. 
8. 
Repeat, while k < len 
a. 
Let Pk be ToString(k). 
b. 
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk. 
c. 
If kPresent is true, then 
i. Let kValue be the result of calling the [[Get]] internal method of O with argument Pk. 
ii. 
Let mappedValue be the result of calling the [[Call]] internal method of callbackfn with T as 
the this value and argument list containing kValue, k, and O. 
iii. 
Call the [[DefineOwnProperty]] internal method of A with arguments Pk, Property 
Descriptor {[[Value]]: mappedValue, [[Writable]]: true, [[Enumerable]]: true, 
[[Configurable]]: true}, and false. 
d. 
Increase k by 1. 
9. 
Return A. 
The length property of the map method is 1. 

NOTE The map function is intentionally generic; it does not require that its this value be an Array object. Therefore it 
can be transferred to other kinds of objects for use as a method. Whether the map function can be applied successfully to 
a host object is implementation-dependent. 

15.4.4.20 Array.prototype.filter ( callbackfn [ , thisArg ] ) 
callbackfn should be a function that accepts three arguments and returns a value that is coercible to the 
Boolean value true or false. filter calls callbackfn once for each element in the array, in ascending order, 
and constructs a new array of all the values for which callbackfn returns true. callbackfn is called only for 
elements of the array which actually exist; it is not called for missing elements of the array. 

If a thisArg parameter is provided, it will be used as the this value for each invocation of callbackfn. If it is not 
provided, undefined is used instead. 

callbackfn is called with three arguments: the value of the element, the index of the element, and the object 
being traversed. 

filter does not directly mutate the object on which it is called but the object may be mutated by the calls to 
callbackfn. 

The range of elements processed by filter is set before the first call to callbackfn. Elements which are 
appended to the array after the call to filter begins will not be visited by callbackfn. If existing elements of 
the array are changed their value as passed to callbackfn will be the value at the time filter visits them; 
elements that are deleted after the call to filter begins and before being visited are not visited. 

When the filter method is called with one or two arguments, the following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length". 

3. 
Let len be ToUint32(lenValue). 
4. 
If IsCallable(callbackfn) is false, throw a TypeError exception. 
5. 
If thisArg was supplied, let T be thisArg; else let T be undefined. 
6. 
Let A be a new array created as if by the expression new Array() where Array is the standard built-in 
constructor with that name. 
7. 
Let k be 0. 
8. 
Let to be 0. 
9. 
Repeat, while k < len 
a. 
Let Pk be ToString(k). 
b. 
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk. 
c. 
If kPresent is true, then 
i. Let kValue be the result of calling the [[Get]] internal method of O with argument Pk. 
ii. 
Let selected be the result of calling the [[Call]] internal method of callbackfn with T as the 
this value and argument list containing kValue, k, and O. 
iii. If ToBoolean(selected) is true, then 
1. 
Call the [[DefineOwnProperty]] internal method of A with arguments ToString(to), 
Property Descriptor {[[Value]]: kValue, [[Writable]]: true, [[Enumerable]]: true, 
[[Configurable]]: true}, and false. 
2. 
Increase to by 1. 
d. 
Increase k by 1. 
10. 
Return A. 
The length property of the filter method is 1. 

NOTE The filter function is intentionally generic; it does not require that its this value be an Array object. 
Therefore it can be transferred to other kinds of objects for use as a method. Whether the filter function can be applied 
successfully to a host object is implementation-dependent. 

15.4.4.21 Array.prototype.reduce ( callbackfn [ , initialValue ] ) 
callbackfn should be a function that takes four arguments. reduce calls the callback, as a function, once for 
each element present in the array, in ascending order. 

callbackfn is called with four arguments: the previousValue (or value from the previous call to callbackfn), the 
currentValue (value of the current element), the currentIndex, and the object being traversed. The first time 
that callback is called, the previousValue and currentValue can be one of two values. If an initialValue was 
provided in the call to reduce, then previousValue will be equal to initialValue and currentValue will be equal 
to the first value in the array. If no initialValue was provided, then previousValue will be equal to the first value 
in the array and currentValue will be equal to the second. It is a TypeError if the array contains no elements 
and initialValue is not provided. 

reduce does not directly mutate the object on which it is called but the object may be mutated by the calls to 
callbackfn. 

The range of elements processed by reduce is set before the first call to callbackfn. Elements that are 
appended to the array after the call to reduce begins will not be visited by callbackfn. If existing elements of 
the array are changed, their value as passed to callbackfn will be the value at the time reduce visits them; 
elements that are deleted after the call to filter begins and before being visited are not visited. 

When the reduce method is called with one or two arguments, the following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length". 
3. 
Let len be ToUint32(lenValue ). 
4. 
If IsCallable(callbackfn) is false, throw a TypeError exception. 
5. 
If len is 0 and initialValue is not present, throw a TypeError exception. 
6. 
Let k be 0. 
7. 
If initialValue is present, then 
a. 
Set accumulator to initialValue. 
8. 
Else, initialValue is not present 

a. 
Let kPresent be false. 
b. 
Repeat, while kPresent is false and k < len 
i. Let Pk be ToString(k). 
ii. 
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument 
Pk. 
iii. If kPresent is true, then 
1. 
Let accumulator be the result of calling the [[Get]] internal method of O with 
argument Pk. 
iv. 
Increase k by 1. 
c. 
If kPresent is false, throw a TypeError exception. 
9. 
Repeat, while k < len 
a. 
Let Pk be ToString(k). 
b. 
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk. 
c. 
If kPresent is true, then 
i. Let kValue be the result of calling the [[Get]] internal method of O with argument Pk. 
ii. 
Let accumulator be the result of calling the [[Call]] internal method of callbackfn with 
undefined as the this value and argument list containing accumulator, kValue, k, and O. 
d. 
Increase k by 1. 
10. 
Return accumulator. 
The length property of the reduce method is 1. 

NOTE The reduce function is intentionally generic; it does not require that its this value be an Array object. 
Therefore it can be transferred to other kinds of objects for use as a method. Whether the reduce function can be applied 
successfully to a host object is implementation-dependent. 

15.4.4.22 Array.prototype.reduceRight ( callbackfn [ , initialValue ] ) 
callbackfn should be a function that takes four arguments. reduceRight calls the callback, as a function, 
once for each element present in the array, in descending order. 

callbackfn is called with four arguments: the previousValue (or value from the previous call to callbackfn), the 
currentValue (value of the current element), the currentIndex, and the object being traversed. The first time 
the function is called, the previousValue and currentValue can be one of two values. If an initialValue was 
provided in the call to reduceRight, then previousValue will be equal to initialValue and currentValue will be 
equal to the last value in the array. If no initialValue was provided, then previousValue will be equal to the last 
value in the array and currentValue will be equal to the second-to-last value. It is a TypeError if the array 
contains no elements and initialValue is not provided. 

reduceRight does not directly mutate the object on which it is called but the object may be mutated by the 
calls to callbackfn. 

The range of elements processed by reduceRight is set before the first call to callbackfn. Elements that are 
appended to the array after the call to reduceRight begins will not be visited by callbackfn. If existing 
elements of the array are changed by callbackfn, their value as passed to callbackfn will be the value at the 
time reduceRight visits them; elements that are deleted after the call to filter begins and before being 
visited are not visited. 

When the reduceRight method is called with one or two arguments, the following steps are taken: 

1. 
Let O be the result of calling ToObject passing the this value as the argument. 
2. 
Let lenValue be the result of calling the [[Get]] internal method of O with the argument "length". 
3. 
Let len be ToUint32(lenValue ). 
4. 
If IsCallable(callbackfn) is false, throw a TypeError exception. 
5. 
If len is 0 and initialValue is not present, throw a TypeError exception. 
6. 
Let k be len-1. 
7. 
If initialValue is present, then 
a. 
Set accumulator to initialValue. 
8. 
Else, initialValue is not present 
a. 
Let kPresent be false. 

b. 
Repeat, while kPresent is false and k . 0 
i. 
Let Pk be ToString(k). 
ii. 
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument 
Pk. 
iii. If kPresent is true, then 
1. 
Let accumulator be the result of calling the [[Get]] internal method of O with 
argument Pk. 
iv. 
Decrease k by 1. 
c. 
If kPresent is false, throw a TypeError exception. 
9. 
Repeat, while k . 0 
a. 
Let Pk be ToString(k). 
b. 
Let kPresent be the result of calling the [[HasProperty]] internal method of O with argument Pk. 
c. 
If kPresent is true, then 
i. 
Let kValue be the result of calling the [[Get]] internal method of O with argument Pk. 
ii. 
Let accumulator be the result of calling the [[Call]] internal method of callbackfn with null 
as the this value and argument list containing accumulator, kValue, k, and O. 
d. 
Decrease k by 1. 
10. 
Return accumulator. 
The length property of the reduceRight method is 1. 

NOTE The reduceRight function is intentionally generic; it does not require that its this value be an Array object. 
Therefore it can be transferred to other kinds of objects for use as a method. Whether the reduceRight function can be 
applied successfully to a host object is implementation-dependent. 

15.4.5 Properties of Array Instances 
Array instances inherit properties from the Array prototype object and their [[Class]] internal property value is"Array". Array instances also have the following properties. 

15.4.5.1 [[DefineOwnProperty]] ( P, Desc, Throw ) 
Array objects use a variation of the [[DefineOwnProperty]] internal method used for other native ECMAScript 
objects (8.12.9). 

Assume A is an Array object, Desc is a Property Descriptor, and Throw is a Boolean flag. 

In the following algorithm, the term “Reject” means “If Throw is true, then throw a TypeError exception, otherwise 
return false.” 

When the [[DefineOwnProperty]] internal method of A is called with property P, Property Descriptor Desc, and 
Boolean flag Throw, the following steps are taken: 

1. 
Let oldLenDesc be the result of calling the [[GetOwnProperty]] internal method of A passing "length" as 
the argument. The result will never be undefined or an accessor descriptor because Array objects are 
created with a length data property that cannot be deleted or reconfigured. 
2. 
Let oldLen be oldLenDesc.[[Value]]. 
3. 
If P is "length", then 
a. 
If the [[Value]] field of Desc is absent, then 
i. 
Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A 
passing "length", Desc, and Throw as arguments. 
b. 
Let newLenDesc be a copy of Desc. 
c. 
Let newLen be ToUint32(Desc.[[Value]]). 
d. 
If newLen is not equal to ToNumber( Desc.[[Value]]), throw a RangeError exception. 
e. 
Set newLenDesc.[[Value] to newLen. 
f. 
If newLen .oldLen, then 
i. 
Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A 
passing "length", newLenDesc, and Throw as arguments. 
g. 
Reject if oldLenDesc.[[Writable]] is false. 
h. 
If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true. 

i. 
Else, 
i. 
Need to defer setting the [[Writable]] attribute to false in case any elements cannot be 
deleted. 
ii. 
Let newWritable be false. 
iii. Set newLenDesc.[[Writable] to true. 
j. 
Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on 
A passing "length", newLenDesc, and Throw as arguments. 
k. 
If succeeded is false, return false.. 
l. 
While newLen < oldLen repeat, 
i. 
Set oldLen to oldLen . 1. 
ii. 
Let cannotDelete be the result of calling the [[Delete]] internal method of A passing 
ToString(oldLen) and false as arguments. 
iii. If cannotDelete is true, then 
1. 
Set newLenDesc.[[Value] to oldLen+1. 
2. 
If newWritable is false, set newLenDesc.[[Writable] to false. 
3. 
Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing 
"length", newLenDesc, and false as arguments. 
4. 
Reject. 
m. 
If newWritable is false, then 
i. 
Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing "length", 
Property Descriptor{[[Writable]]: false}, and false as arguments. This call will always 
return true. 
n. 
Return true. 
4. 
Else if P is an array index (15.4), then 
a. 
Let index be ToUint32(P). 
b. 
Reject if index . 
oldLen and oldLenDesc.[[Writable]] is false. 
c. 
Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on 
A passing P, Desc, and false as arguments. 
d. 
Reject if succeeded is false. 
e. 
If index . 
oldLen 
i. 
Set oldLenDesc.[[Value]] to index + 1. 
ii. 
Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing "length", 
oldLenDesc, and false as arguments. This call will always return true. 
f. 
Return true. 
5. 
Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, 
Desc, and Throw as arguments. 
15.4.5.2 length 
The length property of this Array object is a data property whose value is always numerically greater than 
the name of every deletable property whose name is an array index. 

The length property initially has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }. 

NOTE Attempting to set the length property of an Array object to a value that is numerically less than or equal to the 
largest numeric property name of an existing array indexed non-deletable property of the array will result in the length 
being set to a numeric value that is one greater than that largest numeric property name. See 15.4.5.1. 

15.5 String Objects 
15.5.1 The String Constructor Called as a Function 
When String is called as a function rather than as a constructor, it performs a type conversion. 

15.5.1.1 String ( [ value ] ) 
Returns a String value (not a String object) computed by ToString(value). If value is not supplied, the empty 
String "" is returned. 

15.5.2.1 new String ( [ value ] ) 
The [[Prototype]] internal property of the newly constructed object is set to the standard built-in String 
prototype object that is the initial value of String.prototype (15.5.3.1). 
The [[Class]] internal property of the newly constructed object is set to "String". 

The [[Extensible]] internal property of the newly constructed object is set to true. 
The [[PrimitiveValue]] internal property of the newly constructed object is set to ToString(value), or to the empty 
String if value is not supplied. 

15.5.3 Properties of the String Constructor 
The value of the [[Prototype]] internal property of the String constructor is the standard built-in Function 
prototype object (15.3.4). 

Besides the internal properties and the length property (whose value is 1), the String constructor has the 
following properties: 

15.5.3.1 String.prototype 
The initial value of String.prototype is the standard built-in String prototype object (15.5.4). 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.5.3.2 String.fromCharCode ( [ char0 [ , char1 [ , … ] ] ] ) 
Returns a String value containing as many characters as the number of arguments. Each argument specifies 
one character of the resulting String, with the first argument specifying the first character, and so on, from left 
to right. An argument is converted to a character by applying the operation ToUint16 (9.7) and regarding the 
resulting 16-bit integer as the code unit value of a character. If no arguments are supplied, the result is the 
empty String. 

The length property of the fromCharCode function is 1. 

15.5.4 Properties of the String Prototype Object 
The String prototype object is itself a String object (its [[Class]] is "String") whose value is an empty String. 

The value of the [[Prototype]] internal property of the String prototype object is the standard built-in Object 
prototype object (15.2.4). 

15.5.4.1 String.prototype.constructor 
The initial value of String.prototype.constructor is the built-in String constructor. 

15.5.4.2 String.prototype.toString ( ) 
Returns this String value. (Note that, for a String object, the toString method happens to return the same 
thing as the valueOf method.) 


The toString function is not generic; it throws a TypeError exception if its this value is not a String or a 
String object. Therefore, it cannot be transferred to other kinds of objects for use as a method. 

15.5.4.3 String.prototype.valueOf ( ) 
Returns this String value. 

The valueOf function is not generic; it throws a TypeError exception if its this value is not a String or String 
object. Therefore, it cannot be transferred to other kinds of objects for use as a method. 

15.5.4.4 String.prototype.charAt (pos) 
Returns a String containing the character at position pos in the String resulting from converting this object to a 
String. If there is no character at that position, the result is the empty String. The result is a String value, not a 
String object. 

If pos is a value of Number type that is an integer, then the result of x.charAt(pos) is equal to the result of 
x.substring(pos, pos+1). 

When the charAt method is called with one argument pos, the following steps are taken: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 
3. 
Let position be ToInteger(pos). 
4. 
Let size be the number of characters in S. 
5. 
If position < 0 or position . 
size, return the empty String. 
6. 
Return a String of length 1, containing one character from S, namely the character at position position, where 
the first (leftmost) character in S is considered to be at position 0, the next one at position 1, and so on. 
NOTE The charAt function is intentionally generic; it does not require that its this value be a String object. 
Therefore, it can be transferred to other kinds of objects for use as a method. 

15.5.4.5 String.prototype.charCodeAt (pos) 
Returns a Number (a nonnegative integer less than 2^16) representing the code unit value of the character at 
position pos in the String resulting from converting this object to a String. If there is no character at that 
position, the result is NaN. 

When the charCodeAt method is called with one argument pos, the following steps are taken: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 
3. 
Let position be ToInteger(pos). 
4. 
Let size be the number of characters in S. 
5. 
If position < 0 or position . 
size, return NaN. 
6. 
Return a value of Number type, whose value is the code unit value of the character at position position in the 
String S, where the first (leftmost) character in S is considered to be at position 0, the next one at position 1, 
and so on. 
NOTE The charCodeAt function is intentionally generic; it does not require that its this value be a String object. 
Therefore it can be transferred to other kinds of objects for use as a method. 

15.5.4.6 String.prototype.concat ( [ string1 [ , string2 [ , … ] ] ] ) 
When the concat method is called with zero or more arguments string1, string2, etc., it returns a String 
consisting of the characters of this object (converted to a String) followed by the characters of each of string1, 
string2, etc. (where each argument is converted to a String). The result is a String value, not a String object. 
The following steps are taken: 


1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 
3. 
Let args be an internal list that is a copy of the argument list passed to this function. 
4. 
Let R be S. 
5. 
Repeat, while args is not empty 
a. 
Remove the first element from args and let next be the value of that element. 
b. 
Let R be the String value consisting of the characters in the previous value of R followed by the 
characters of ToString(next). 
6. 
Return R. 
The length property of the concat method is 1. 

NOTE The concat function is intentionally generic; it does not require that its this value be a String object. 
Therefore it can be transferred to other kinds of objects for use as a method. 

15.5.4.7 String.prototype.indexOf (searchString, position) 
If searchString appears as a substring of the result of converting this object to a String, at one or more positions 
that are greater than or equal to position, then the index of the smallest such position is returned; otherwise, 1 
is returned. If position is undefined, 0 is assumed, so as to search all of the String. 

The indexOf method takes two arguments, searchString and position, and performs the following steps: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 
3. 
Let searchStr be ToString(searchString). 
4. 
Let pos be ToInteger(position). (If position is undefined, this step produces the value 0). 
5. 
Let len be the number of characters in S. 
6. 
Let start be min(max(pos, 0), len). 
7. 
Let searchLen be the number of characters in searchStr. 
8. 
Return the smallest possible integer k not smaller than start such that k+ searchLen is not greater than len, 
and for all nonnegative integers j less than searchLen, the character at position k+j of S is the same as the 
character at position j of searchStr); but if there is no such integer k, then return the value -1. 
The length property of the indexOf method is 1. 

NOTE The indexOf function is intentionally generic; it does not require that its this value be a String object. 
Therefore, it can be transferred to other kinds of objects for use as a method. 

15.5.4.8 String.prototype.lastIndexOf (searchString, position) 
If searchString appears as a substring of the result of converting this object to a String at one or more positions 
that are smaller than or equal to position, then the index of the greatest such position is returned; otherwise, 1 
is returned. If position is undefined, the length of the String value is assumed, so as to search all of the 
String. 

The lastIndexOf method takes two arguments, searchString and position, and performs the following steps: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 
3. 
Let searchStr be ToString(searchString). 
4. 
Let numPos be ToNumber(position). (If position is undefined, this step produces the value NaN). 
5. 
If numPos is NaN, let pos be +∞; otherwise, let pos be ToInteger(numPos). 
6. 
Let len be the number of characters in S. 
7. 
Let start min(max(pos, 0), len). 
8. 
Let searchLen be the number of characters in searchStr. 

9. 
Return the largest possible nonnegative integer k not larger than start such that k+ searchLen is not greater 
than len, and for all nonnegative integers j less than searchLen, the character at position k+j of S is the same 
as the character at position j of searchStr; but if there is no such integer k, then return the value -1. 
The length property of the lastIndexOf method is 1. 

NOTE The lastIndexOf function is intentionally generic; it does not require that its this value be a String object. 
Therefore, it can be transferred to other kinds of objects for use as a method. 

15.5.4.9 String.prototype.localeCompare (that) 
When the localeCompare method is called with one argument that, it returns a Number other than NaN that 
represents the result of a locale-sensitive String comparison of the this value (converted to a String) with that 
(converted to a String). The two Strings are S and That. The two Strings are compared in an implementation-
defined fashion. The result is intended to order String values in the sort order specified by the system default 
locale, and will be negative, zero, or positive, depending on whether S comes before That in the sort order, the 
Strings are equal, or S comes after That in the sort order, respectively. 

Before perform the comparisons the following steps are performed to prepare the Strings: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 
3. 
Let That be ToString(that). 
The localeCompare method, if considered as a function of two arguments this and that, is a consistent 
comparison function (as defined in 15.4.4.11) on the set of all Strings. Furthermore, localeCompare returns 
0 or -0 when comparing two Strings that are considered canonically equivalent by the Unicode standard. 

The actual return values are implementation-defined to permit implementers to encode additional information 
in the value, but the function is required to define a total ordering on all Strings and to return 0 when 
comparing Strings that are considered canonically equivalent by the Unicode standard. 

If no language-sensitive comparison at all is available from the host environment, this function may perform a 
bitwise comparison. 

NOTE 1 The localeCompare method itself is not directly suitable as an argument to Array.prototype.sort 
because the latter requires a function of two arguments. 

NOTE 2 This function is intended to rely on whatever language-sensitive comparison functionality is available to the 
ECMAScript environment from the host environment, and to compare according to the rules of the host environment’s 
current locale. It is strongly recommended that this function treat Strings that are canonically equivalent according to the 
Unicode standard as identical (in other words, compare the Strings as if they had both been converted to Normalised 
Form C or D first). It is also recommended that this function not honour Unicode compatibility equivalences or 
decompositions. 

NOTE 3 The second parameter to this function is likely to be used in a future version of this standard; it is 
recommended that implementations do not use this parameter position for anything else. 

NOTE 4 The localeCompare function is intentionally generic; it does not require that its this value be a String object. 
Therefore, it can be transferred to other kinds of objects for use as a method. 

15.5.4.10 String.prototype.match (regexp) 
When the match method is called with argument regexp, the following steps are taken: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 
3. 
If Type(regexp) is Object and the value of the [[Class]] internal property of regexp is "RegExp", then let rx 
be regexp; 
144 

4. 
Else, let rx be a new RegExp object created as if by the expression new RegExp(regexp) where RegExpis the standard built-in constructor with that name. 
5. 
Let global be the result of calling the [[Get]] internal method of rx with argument "global". 
6. 
Let exec be the standard built-in function RegExp.prototype.exec (see 15.10.6.2) 
7. 
If global is not true, then 
a. 
Return the result of calling the [[Call]] internal method of exec with rx as the this value and 
argument list containing S. 
8. 
Else, global is true 
a. 
Call the [[Put]] internal method of rx with arguments "lastIndex" and 0. 
b. 
Let A be a new array created as if by the expression new Array() where Array is the standard 
built-in constructor with that name. 
c. 
Let previousLastIndex be 0. 
d. 
Let n be 0. 
e. 
Let lastMatch be true. 
f. 
Repeat, while lastMatch is true 
i. 
Let result be the result of calling the [[Call]] internal method of exec with rx as the this 
value and argument list containing S. 
ii. If result is null, then set lastMatch to false. 
iii. Else, result is not null 
1. 
Let thisIndex be the result of calling the [[Get]] internal method of rx with 
argument "lastIndex". 
2. 
If thisIndex = previousLastIndex then 
a Call the [[Put]] internal method of rx with arguments "lastIndex" and 
thisIndex+1. 
b Set previousLastIndex to thisIndex+1. 

3. 
Else, set previousLastIndex to thisIndex. 
4. 
Let matchStr be the result of calling the [[Get]] internal method of result with 
argument "0". 
5. 
Call the [[DefineOwnProperty]] internal method of A with arguments ToString(n), 
the Property Descriptor {[[Value]]: matchStr, [[Writable]]: true, [[Enumerable]]: 
true, [[configurable]]: true}, and false. 
6. 
Increment n. 
g. 
If n = 0, then return null. 
h. 
Return A. 
NOTE The match function is intentionally generic; it does not require that its this value be a String object. Therefore, 
it can be transferred to other kinds of objects for use as a method. 

15.5.4.11 String.prototype.replace (searchValue, replaceValue) 
First set string according to the following steps: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let string be the result of calling ToString, giving it the this value as its argument. 
If searchValue is a regular expression (an object whose [[Class]] internal property is "RegExp"), do the 
following: If searchValue.global is false, then search string for the first match of the regular expression 
searchValue. If searchValue.global is true, then search string for all matches of the regular expression 
searchValue. Do the search in the same manner as in String.prototype.match, including the update of 
searchValue.lastIndex. Let m be the number of left capturing parentheses in searchValue (using 
NcapturingParens as specified in 15.10.2.1). 

If searchValue is not a regular expression, let searchString be ToString(searchValue) and search string for the first 
occurrence of searchString. Let m be 0. 

If replaceValue is a function, then for each matched substring, call the function with the following m + 3 
arguments. Argument 1 is the substring that matched. If searchValue is a regular expression, the next m 
arguments are all of the captures in the MatchResult (see 15.10.2.1). Argument m + 2 is the offset within string 
where the match occurred, and argument m + 3 is string. The result is a String value derived from the original 


input by replacing each matched substring with the corresponding return value of the function call, converted 
to a String if need be. 

Otherwise, let newstring denote the result of converting replaceValue to a String. The result is a String value 
derived from the original input String by replacing each matched substring with a String derived from newstring 
by replacing characters in newstring by replacement text as specified in Table 22. These $ replacements are 
done left-to-right, and, once such a replacement is performed, the new replacement text is not subject to 
further replacements. For example, "$1,$2".replace(/(\$(\d))/g, "$$1-$1$2") returns "$1$
11,$1-$22". A $ in newstring that does not match any of the forms below is left as is. 

Table 22 - Replacement Text Symbol Substitutions 

Characters Replacement text 
$$ $ 
$& The matched substring. 
$‘ The portion of string that precedes the matched substring. 
$’ The portion of string that follows the matched substring. 
$n The nth capture, where n is a single digit in the range 1 to 9 and $n is not followed 
by a decimal digit. If n.m and the nth capture is undefined, use the empty String 
instead. If n>m, the result is implementation-defined. 
$nn The nnth capture, where nn is a two-digit decimal number in the range 01 to 99. If 
nn.m and the nnth capture is undefined, use the empty String instead. If nn>m, the 
result is implementation-defined. 

NOTE The replace function is intentionally generic; it does not require that its this value be a String object. 
Therefore, it can be transferred to other kinds of objects for use as a method. 

15.5.4.12 String.prototype.search (regexp) 
When the search method is called with argument regexp, the following steps are taken: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let string be the result of calling ToString, giving it the this value as its argument. 
3. 
If Type(regexp) is Object and the value of the [[Class]] internal property of regexp is "RegExp", then let rx 
be regexp; 
4. 
Else, let rx be a new RegExp object created as if by the expression new RegExp(regexp) where RegExpis the standard built-in constructor with that name. 
5. 
Search the value string from its beginning for an occurrence of the regular expression pattern rx. Let result 
be a Number indicating the offset within string where the pattern matched, or -1 if there was no match. The 
lastIndex and global properties of regexp are ignored when performing the search. The lastIndex 
property of regexp is left unchanged. 
6. 
Return result. 
NOTE The search function is intentionally generic; it does not require that its this value be a String object. 
Therefore, it can be transferred to other kinds of objects for use as a method. 

15.5.4.13 String.prototype.slice (start, end) 
The slice method takes two arguments, start and end, and returns a substring of the result of converting this 
object to a String, starting from character position start and running to, but not including, character position end 
(or through the end of the String if end is undefined). If start is negative, it is treated as sourceLength+start 
where sourceLength is the length of the String. If end is negative, it is treated as sourceLength+end where 
sourceLength is the length of the String. The result is a String value, not a String object. The following steps are 
taken: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 

3. 
Let len be the number of characters in S. 
4. 
Let intStart be ToInteger(start). 
5. 
If end is undefined, let intEnd be len; else let intEnd be ToInteger(end). 
6. 
If intStart is negative, let from be max(len + intStart,0); else let from be min(intStart, len). 
7. 
If intEnd is negative, let to be max(len + intEnd,0); else let to be min(intEnd, len). 
8. 
Let span be max(to . from,0). 
9. 
Return a String containing span consecutive characters from S beginning with the character at position from. 
The length property of the slice method is 2. 

NOTE The slice function is intentionally generic; it does not require that its this value be a String object. Therefore 
it can be transferred to other kinds of objects for use as a method. 

15.5.4.14 String.prototype.split (separator, limit) 
Returns an Array object into which substrings of the result of converting this object to a String have been 
stored. The substrings are determined by searching from left to right for occurrences of separator; these 
occurrences are not part of any substring in the returned array, but serve to divide up the String value. The 
value of separator may be a String of any length or it may be a RegExp object (i.e., an object whose [[Class]] 
internal property is "RegExp"; see 15.10). 

The value of separator may be an empty String, an empty regular expression, or a regular expression that can 
match an empty String. In this case, separator does not match the empty substring at the beginning or end of 
the input String, nor does it match the empty substring at the end of the previous separator match. (For 
example, if separator is the empty String, the String is split up into individual characters; the length of the result 
array equals the length of the String, and each substring contains one character.) If separator is a regular 
expression, only the first match at a given position of the this String is considered, even if backtracking could 
yield a non-empty-substring match at that position. (For example, "ab".split(/a*?/) evaluates to the 
array ["a","b"], while "ab".split(/a*/) evaluates to the array["","b"].) 

If the this object is (or converts to) the empty String, the result depends on whether separator can match the 
empty String. If it can, the result array contains no elements. Otherwise, the result array contains one element, 
which is the empty String. 

If separator is a regular expression that contains capturing parentheses, then each time separator is matched 
the results (including any undefined results) of the capturing parentheses are spliced into the output array. 
For example, 

"A<B>bold</B>and<CODE>coded</CODE>".split(/<(\/)?([^<>]+)>/) 

evaluates to the array 

["A", undefined, "B", "bold", "/", "B", "and", undefined,
"CODE", "coded", "/", "CODE", ""] 

If separator is undefined, then the result array contains just one String, which is the this value (converted to a 
String). If limit is not undefined, then the output array is truncated so that it contains no more than limit 
elements. 

When the split method is called, the following steps are taken: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 
3. 
Let A be a new array created as if by the expression new Array()where Array is the standard built-in 
constructor with that name. 
4. 
Let lengthA be 0. 
5. 
If limit is undefined, let lim = 2^32-1; else let lim = ToUint32(limit). 
6. 
Let s be the number of characters in S. 
7. 
Let p = 0. 
8. 
If separator is a RegExp object (its [[Class]] is "RegExp"), let R = separator; otherwise let R = 
ToString(separator). 

9. 
If lim = 0, return A. 
10. 
If separator is undefined, then 
a. Call the [[DefineOwnProperty]] internal method of A with arguments "0", Property Descriptor 
{[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. 
b. 
Return A. 
11. 
If s = 0, then 
a. 
Call SplitMatch(R, S, 0) and let z be its MatchResult result. 
b. 
If z is not failure, return A. 
c. 
Call the [[DefineOwnProperty]] internal method of A with arguments "0", Property Descriptor 
{[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. 
d. 
Return A. 
12. 
Let q = p. 
13. 
Repeat, while q ≠ 
s 
a. 
Call SplitMatch(R, S, q) and let z be its MatchResult result. 
b. 
If z is failure, then let q = q+1. 
c. 
Else, z is not failure 
i. z must be a State. Let e be z's endIndex and let cap be z's captures array. 
ii. If e = p, then let q = q+1. 
iii. Else, e ≠ 
p 
1. 
Let T be a String value equal to the substring of S consisting of the characters at 
positions p (inclusive) through q (exclusive). 
2. 
Call the [[DefineOwnProperty]] internal method of A with arguments 
ToString(lengthA), Property Descriptor {[[Value]]: T, [[Writable]]: true, 
[[Enumerable]]: true, [[Configurable]]: true}, and false. 
3. 
Increment lengthA by 1. 
4. 
If lengthA = lim, return A. 
5. 
Let p = e. 
6. 
Let i = 0. 
7. 
Repeat, while i is not equal to the number of elements in cap. 
a Let i = i+1. 
b Call the [[DefineOwnProperty]] internal method of A with arguments 
ToString(lengthA), Property Descriptor {[[Value]]: cap[i], [[Writable]]: 

true, [[Enumerable]]: true, [[Configurable]]: true}, and false. 
c Increment lengthA by 1. 
d If A.length = lim, return A. 

8. 
Let q = p. 
14. 
Let T be a String value equal to the substring of S consisting of the characters at positions p (inclusive) 
through s (exclusive). 
15. 
Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA), Property Descriptor 
{[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. 
16. 
Return A. 
The abstract operation SplitMatch takes three parameters, a String S, an integer q, and a String or RegExp R, 
and performs the following in order to return a MatchResult (see 15.10.2.1): 

1. 
If R is a RegExp object (its [[Class]] is "RegExp"), then 
a. 
Call the [[Match]] internal method of R giving it the arguments S and q, and return the MatchResult 
result. 
2. 
Type(R) must be String. Let r be the number of characters in R. 
3. 
Let s be the number of characters in S. 
4. 
If q+r > s then return the MatchResult failure. 
5. 
If there exists an integer i between 0 (inclusive) and r (exclusive) such that the character at position q+i of S 
is different from the character at position i of R, then return failure. 
6. 
Let cap be an empty array of captures (see 15.10.2.1). 
7. 
Return the State (q+r, cap). (see 15.10.2.1) 
The length property of the split method is 2. 

NOTE 1 The split method ignores the value of separator.global for separators that are RegExp objects. 


NOTE 2 The split function is intentionally generic; it does not require that its this value be a String object. Therefore, 
it can be transferred to other kinds of objects for use as a method. 

15.5.4.15 String.prototype.substring (start, end) 
The substring method takes two arguments, start and end, and returns a substring of the result of converting 
this object to a String, starting from character position start and running to, but not including, character position 
end of the String (or through the end of the String is end is undefined). The result is a String value, not a String 
object. 

If either argument is NaN or negative, it is replaced with zero; if either argument is larger than the length of the 
String, it is replaced with the length of the String. 

If start is larger than end, they are swapped. 

The following steps are taken: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 
3. 
Let len be the number of characters in S. 
4. 
Let intStart be ToInteger(start). 
5. 
If end is undefined, let intEnd be len; else let intEnd be ToInteger(end). 
6. 
Let finalStart be min(max(intStart, 0), len). 
7. 
Let finalEnd be min(max(intEnd, 0), len). 
8. 
Let from be min(finalStart, finalEnd). 
9. 
Let to be max(finalStart, finalEnd). 
10. 
Return a String whose length is to -from, containing characters from S, namely the characters with indices 
from through to -1, in ascending order. 
The length property of the substring method is 2. 

NOTE The substring function is intentionally generic; it does not require that its this value be a String object. 
Therefore, it can be transferred to other kinds of objects for use as a method. 

15.5.4.16 String.prototype.toLowerCase ( ) 
The following steps are taken: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 
3. 
Let L be a String where each character of L is either the Unicode lowercase equivalent of the corresponding 
character of S or the actual corresponding character of S if no Unicode lowercase equivalent exists. 
4. 
Return L. 
For the purposes of this operation, the 16-bit code units of the Strings are treated as code points in the 
Unicode Basic Multilingual Plane. Surrogate code points are directly transferred from S to L without any 
mapping. 

The result must be derived according to the case mappings in the Unicode character database (this explicitly 
includes not only the UnicodeData.txt file, but also the SpecialCasings.txt file that accompanies it in Unicode 

2.1.8 and later). 
NOTE 1 The case mapping of some characters may produce multiple characters. In this case the result String may not 
be the same length as the source String. Because both toUpperCase and toLowerCase have context-sensitive 
behaviour, the functions are not symmetrical. In other words, s.toUpperCase().toLowerCase() is not necessarily 
equal to s.toLowerCase(). 

NOTE 2 The toLowerCase function is intentionally generic; it does not require that its this value be a String object. 
Therefore, it can be transferred to other kinds of objects for use as a method. 


15.5.4.17 String.prototype.toLocaleLowerCase ( ) 
This function works exactly the same as toLowerCase except that its result is intended to yield the correct 
result for the host environment’s current locale, rather than a locale-independent result. There will only be a 
difference in the few cases (such as Turkish) where the rules for that language conflict with the regular 
Unicode case mappings. 

NOTE 1 The first parameter to this function is likely to be used in a future version of this standard; it is recommended 
that implementations do not use this parameter position for anything else. 

NOTE 2 The toLocaleLowerCase function is intentionally generic; it does not require that its this value be a String 
object. Therefore, it can be transferred to other kinds of objects for use as a method. 

15.5.4.18 String.prototype.toUpperCase ( ) 
This function behaves in exactly the same way as String.prototype.toLowerCase, except that 
characters are mapped to their uppercase equivalents as specified in the Unicode Character Database. 

NOTE The toUpperCase function is intentionally generic; it does not require that its this value be a String object. 
Therefore, it can be transferred to other kinds of objects for use as a method. 

15.5.4.19 String.prototype.toLocaleUpperCase ( ) 
This function works exactly the same as toUpperCase except that its result is intended to yield the correct 
result for the host environment’s current locale, rather than a locale-independent result. There will only be a 
difference in the few cases (such as Turkish) where the rules for that language conflict with the regular 
Unicode case mappings. 

NOTE 1 The first parameter to this function is likely to be used in a future version of this standard; it is recommended 
that implementations do not use this parameter position for anything else. 

NOTE 2 The toLocaleUpperCase function is intentionally generic; it does not require that its this value be a String 
object. Therefore, it can be transferred to other kinds of objects for use as a method. 

15.5.4.20 String.prototype.trim ( ) 
The following steps are taken: 

1. 
Call CheckObjectCoercible passing the this value as its argument. 
2. 
Let S be the result of calling ToString, giving it the this value as its argument. 
3. 
Let T be a String value that is a copy of S with both leading and trailing white space removed. The definition 
of white space is the union of WhiteSpace and LineTerminator. 
4. 
Return T. 
NOTE The trim function is intentionally generic; it does not require that its this value be a String object. Therefore, it 
can be transferred to other kinds of objects for use as a method. 

15.5.5 Properties of String Instances 
String instances inherit properties from the String prototype object and their [[Class]] internal property value is 
"String". String instances also have a [[PrimitiveValue]] internal property, a length property, and a set of 
enumerable properties with array index names. 

The [[PrimitiveValue]] internal property is the String value represented by this String object. The array index 
named properties correspond to the individual characters of the String value. A special [[GetOwnProperty]] 
internal method is used to specify the number, values, and attributes of the array index named properties. 


15.5.5.1 length 
The number of characters in the String value represented by this String object. 

Once a String object is created, this property is unchanging. It has the attributes { [[Writable]]: false, 
[[Enumerable]]: false, [[Configurable]]: false }. 

15.5.5.2 [[GetOwnProperty]] ( P ) 
String objects use a variation of the [[GetOwnProperty]] internal method used for other native ECMAScript 
objects (8.12.1). This special internal method is used to specify the array index named properties of String 
objects. 

Assume S is a String object and P is a String. 

When the [[GetOwnProperty]] internal method of S is called with property name P, the following steps are 
taken: 

1. 
Let desc be the result of calling the default [[GetOwnProperty]] internal method (8.12.1) on S with argument 
P. 
2. 
If desc is not undefined return desc. 
3. 
If P is not an array index (15.4), return undefined. 
4. 
Let str be the String value of the [[PrimitiveValue]] internal property of S. 
5. 
Let index be ToUint32(P). 
6. 
Let len be the number of characters in str. 
7. 
If len . 
index, return undefined. 
8. 
Let resultStr be a String of length 1, containing one character from str, specifically the character at position 
index, where the first (leftmost) character in str is considered to be at position 0, the next one at position 1, 
and so on. 
9. 
Return a Property Descriptor { [[Value]]: resultStr, [[Enumerable]]: true, [[Writable]]: false, 
[[Configurable]]: false } 
15.6 Boolean Objects 
15.6.1 The Boolean Constructor Called as a Function 
When Boolean is called as a function rather than as a constructor, it performs a type conversion. 

15.6.1.1 Boolean (value) 
Returns a Boolean value (not a Boolean object) computed by ToBoolean(value). 

15.6.2 The Boolean Constructor 
When Boolean is called as part of a new expression it is a constructor: it initialises the newly created object. 

15.6.2.1 new Boolean (value) 
The [[Prototype]] internal property of the newly constructed object is set to the original Boolean prototype 
object, the one that is the initial value of Boolean.prototype (15.6.3.1). 

The [[Class]] internal property of the newly constructed Boolean object is set to "Boolean". 

The [[PrimitiveValue]] internal property of the newly constructed Boolean object is set to ToBoolean(value). 

The [[Extensible]] internal property of the newly constructed object is set to true. 


15.6.3 Properties of the Boolean Constructor 
The value of the [[Prototype]] internal property of the Boolean constructor is the Function prototype object 
(15.3.4). 

Besides the internal properties and the length property (whose value is 1), the Boolean constructor has the 
following property: 

15.6.3.1 Boolean.prototype 
The initial value of Boolean.prototype is the Boolean prototype object (15.6.4). 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.6.4 Properties of the Boolean Prototype Object 
The Boolean prototype object is itself a Boolean object (its [[Class]] is "Boolean") whose value is false. 
The value of the [[Prototype]] internal property of the Boolean prototype object is the standard built-in Object 
prototype object (15.2.4). 

15.6.4.1 Boolean.prototype.constructor 
The initial value of Boolean.prototype.constructor is the built-in Boolean constructor. 

15.6.4.2 Boolean.prototype.toString ( ) 
The following steps are taken: 

1. 
Let B be the this value. 
2. 
If Type(B) is Boolean, then let b be B. 
3. 
Else if Type(B) is Object and the value of the [[Class]] internal property of B is "Boolean", then let b be 
the value of the [[PrimitiveValue]] internal property of B. 
4. 
Else throw a TypeError exception. 
5. 
If b is true, then return "true"; else return "false". 
15.6.4.3 Boolean.prototype.valueOf ( ) 
The following steps are taken: 

1. 
Let B be the this value. 
2. 
If Type(B) is Boolean, then let b be B. 
3. 
Else if Type(B) is Object and the value of the [[Class]] internal property of B is "Boolean", then let b be 
the value of the [[PrimitiveValue]] internal property of B. 
4. 
Else throw a TypeError exception. 
5. 
Return b. 
15.6.5 Properties of Boolean Instances 
Boolean instances inherit properties from the Boolean prototype object and their [[Class]] internal property 
value is "Boolean". Boolean instances also have a [[PrimitiveValue]] internal property. 

The [[PrimitiveValue]] internal property is the Boolean value represented by this Boolean object. 


15.7 Number Objects 
15.7.1 The Number Constructor Called as a Function 
When Number is called as a function rather than as a constructor, it performs a type conversion. 

15.7.1.1 Number ( [ value ] ) 
Returns a Number value (not a Number object) computed by ToNumber(value) if value was supplied, else 
returns +0. 

15.7.2 The Number Constructor 
When Number is called as part of a new expression it is a constructor: it initialises the newly created object. 

15.7.2.1 new Number ( [ value ] ) 
The [[Prototype]] internal property of the newly constructed object is set to the original Number prototype 
object, the one that is the initial value of Number.prototype (15.7.3.1). 

The [[Class]] internal property of the newly constructed object is set to "Number". 
The [[PrimitiveValue]] internal property of the newly constructed object is set to ToNumber(value) if value was 
supplied, else to +0. 

The [[Extensible]] internal property of the newly constructed object is set to true. 

15.7.3 Properties of the Number Constructor 
The value of the [[Prototype]] internal property of the Number constructor is the Function prototype object 
(15.3.4). 

Besides the internal properties and the length property (whose value is 1), the Number constructor has the 
following property: 

15.7.3.1 Number.prototype 
The initial value of Number.prototype is the Number prototype object (15.7.4). 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.7.3.2 Number.MAX_VALUE 
The value of Number.MAX_VALUE is the largest positive finite value of the Number type, which is approximately 1.7976931348623157 * 10308 . 

This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.7.3.3 Number.MIN_VALUE 
The value of Number.MIN_VALUE is the smallest positive value of the Number type, which is approximately 

5 * 10-324 

. 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 


15.7.3.4 Number.NaN 
The value of Number.NaN is NaN. 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 
15.7.3.5 Number.NEGATIVE_INFINITY 
The value of Number.NEGATIVE_INFINITY is -∞. 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.7.3.6 Number.POSITIVE_INFINITY 
The value of Number.POSITIVE_INFINITY is +∞. 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.7.4 Properties of the Number Prototype Object 
The Number prototype object is itself a Number object (its [[Class]] is "Number") whose value is +0. 

The value of the [[Prototype]] internal property of the Number prototype object is the standard built-in Object 
prototype object (15.2.4). 

Unless explicitly stated otherwise, the methods of the Number prototype object defined below are not generic 
and the this value passed to them must be either a Number value or an Object for which the value of the 
[[Class]] internal property is "Number". 

In the following descriptions of functions that are properties of the Number prototype object, the phrase “this 
Number object” refers to either the object that is the this value for the invocation of the function or, if 
Type(this value) is Number, an object that is created as if by the expression new Number(this value)
where Number is the standard built-in constructor with that name. Also, the phrase “this Number value” refers 
to either the Number value represented by this Number object, that is, the value of the [[PrimitiveValue]] 
internal property of this Number object or the this value if its type is Number. A TypeError exception is 
thrown if the this value is neither an object for which the value of the [[Class]] internal property is "Number" 
or a value whose type is Number. 

15.7.4.1 Number.prototype.constructor 
The initial value of Number.prototype.constructor is the built-in Number constructor. 

15.7.4.2 Number.prototype.toString ( [ radix ] ) 
The optional radix should be an integer value in the inclusive range 2 to 36. If radix not present or is undefined 
the Number 10 is used as the value of radix. If ToInteger(radix) is the Number 10 then this Number value is 
given as an argument to the ToString abstract operation; the resulting String value is returned. 

If ToInteger(radix) is not an integer between 2 and 36 inclusive throw a RangeError exception. If 
ToInteger(radix) is an integer from 2 to 36, but not 10, the result is a String representation of this Number value 
using the specified radix. Letters a-z are used for digits with values 10 through 35. The precise algorithm is 
implementation-dependent if the radix is not 10, however the algorithm should be a generalization of that 
specified in 9.8.1. 

The toString function is not generic; it throws a TypeError exception if its this value is not a Number or a 
Number object. Therefore, it cannot be transferred to other kinds of objects for use as a method. 


15.7.4.3 Number.prototype.toLocaleString() 
Produces a String value that represents this Number value formatted according to the conventions of the host 
environment’s current locale. This function is implementation-dependent, and it is permissible, but not 
encouraged, for it to return the same thing as toString. 

NOTE The first parameter to this function is likely to be used in a future version of this standard; it is recommended 
that implementations do not use this parameter position for anything else. 

15.7.4.4 Number.prototype.valueOf ( ) 
Returns this Number value. 

The valueOf function is not generic; it throws a TypeError exception if its this value is not a Number or a 
Number object. Therefore, it cannot be transferred to other kinds of objects for use as a method. 

15.7.4.5 Number.prototype.toFixed (fractionDigits) 
Return a String containing this Number value represented in decimal fixed-point notation with fractionDigits 
digits after the decimal point. If fractionDigits is undefined, 0 is assumed. Specifically, perform the following 
steps: 

1. 
Let f be ToInteger(fractionDigits). (If fractionDigits is undefined, this step produces the value 0). 
2. 
If f < 0 or f > 20, throw a RangeError exception. 
3. 
Let x be this Number value. 
4. 
If x is NaN, return the String "NaN". 
5. 
Let s be the empty String. 
6. 
If x < 0, then 
a. 
Let s be "-". 
b. 
Let x = .x. 
7. 
If x . 1021, then 
a. 
Let m = ToString(x). 
8. 
Else, x < 1021 
a. 
Let n be an integer for which the exact mathematical value of n ÷ 10f . x is as close to zero as 
possible. If there are two such n, pick the larger n. 
b. 
If n = 0, let m be the String "0". Otherwise, let m be the String consisting of the digits of the 
decimal representation of n (in order, with no leading zeroes). 
c. 
If f ≠ 0, then 
i. Let k be the number of characters in m. 
ii. If k . 
f, then 
1. 
Let z be the String consisting of f+1.k occurrences of the character ‘0’. 
2. 
Let m be the concatenation of Strings z and m. 
3. 
Let k = f + 1. 
iii. Let a be the first k.f characters of m, and let b be the remaining f characters of m. 
iv. Let m be the concatenation of the three Strings a, ".", and b. 
9. 
Return the concatenation of the Strings s and m. 
The length property of the toFixed method is 1. 

If the toFixed method is called with more than one argument, then the behaviour is undefined (see 
clause 15). 

An implementation is permitted to extend the behaviour of toFixed for values of fractionDigits less than 0 or 
greater than 20. In this case toFixed would not necessarily throw RangeError for such values. 

NOTE The output of toFixed may be more precise than toString for some values because toString only prints 
enough significant digits to distinguish the number from adjacent number values. For example, 


(1000000000000000128).toString() returns "1000000000000000100", 
while (1000000000000000128).toFixed(0) returns "1000000000000000128". 

15.7.4.6 Number.prototype.toExponential (fractionDigits) 
Return a String containing this Number value represented in decmal exponential notation with one digit before 
the significand's decimal point and fractionDigits digits after the significand's decimal point. If fractionDigits is 
undefined, include as many significand digits as necessary to uniquely specify the Number (just like in 
ToString except that in this case the Number is always output in exponential notation). Specifically, perform 
the following steps: 

1. 
Let x be this Number value. 
2. 
Let f be ToInteger(fractionDigits). 
3. 
If x is NaN, return the String "NaN". 
4. 
Let s be the empty String. 
5. 
If x< 0, then 
a. 
Let s be "-". 
b. 
Let x = .x. 
6. 
If x = +∞, then 
a. 
Return the concatenation of the Strings s and "Infinity". 
7. 
If fractionDigits is not undefined and (f < 0 or f > 20), throw a RangeError exception. 
8. 
If x = 0, then 
a. 
Let f = 0. 
b. 
Let m be the String consisting of f+1 occurrences of the character ‘0’. 
c. 
Let e = 0. 
9. 
Else, x ≠ 0 
a. 
If fractionDigits is not undefined, then 
i. 
Let e and n be integers such that 10f . 
n < 10f+1 and for which the exact mathematical value 
of n * 10e.f . x is as close to zero as possible. If there are two such sets of e and n, pick the 
e and n for which n * 10e.f is larger. 
b. 
Else, fractionDigits is undefined 
i. 
Let e, n, and f be integers such that f . 0, 10f . 
n < 10f+1, the number value for n * 10e.f is x, 
and f is as small as possible. Note that the decimal representation of n has f+1 digits, n is 
not divisible by 10, and the least significant digit of n is not necessarily uniquely 
determined by these criteria. 
c. 
Let m be the String consisting of the digits of the decimal representation of n (in order, with no 
leading zeroes). 
10. 
If f ≠ 0, then 
a. 
Let a be the first character of m, and let b be the remaining f characters of m. 
b. 
Let m be the concatenation of the three Strings a, ".", and b. 
11. 
If e = 0, then 
a. 
Let c = "+". 
b. 
Let d = "0". 
12. 
Else 
a. 
If e > 0, then let c = "+". 
b. 
Else, e . 0 
i. 
Let c = "-". 
ii. Let e = .e. 
c. 
Let d be the String consisting of the digits of the decimal representation of e (in order, with no 
leading zeroes). 
13. 
Let m be the concatenation of the four Strings m, "e", c, and d. 
14. 
Return the concatenation of the Strings s and m. 
The length property of the toExponential method is 1. 

If the toExponential method is called with more than one argument, then the behaviour is undefined (see 
clause 15). 


An implementation is permitted to extend the behaviour of toExponential for values of fractionDigits less 
than 0 or greater than 20. In this case toExponential would not necessarily throw RangeError for such 
values. 

NOTE For implementations that provide more accurate conversions than required by the rules above, it is 
recommended that the following alternative version of step 9.b.i be used as a guideline: 

i. 
Let e, n, and f be integers such that f . 0, 10f . n < 10f+1, the number value for n * 10e.f is x, and f is as small 
as possible. If there are multiple possibilities for n, choose the value of n for which n * 10e.f is closest in value 
to x. If there are two such possible values of n, choose the one that is even. 
15.7.4.7 Number.prototype.toPrecision (precision) 
Return a String containing this Number value represented either in decimal exponential notation with one digit 
before the significand's decimal point and precision.1 digits after the significand's decimal point or in decimal 
fixed notation with precision significant digits. If precision is undefined, call ToString (9.8.1) instead. 
Specifically, perform the following steps: 

1. 
Let x be this Number value. 
2. 
If precision is undefined, return ToString(x). 
3. 
Let p be ToInteger(precision). 
4. 
If x is NaN, return the String "NaN". 
5. 
Let s be the empty String. 
6. 
If x < 0, then 
a. 
Let s be "-". 
b. 
Let x = .x. 
7. 
If x = +∞, then 
a. 
Return the concatenation of the Strings s and "Infinity". 
8. 
If p < 1 or p > 21, throw a RangeError exception. 
9. 
If x = 0, then 
a. 
Let m be the String consisting of p occurrences of the character ‘0’. 
b. 
Let e = 0. 
10. 
Else x ≠ 0, 
a. 
Let e and n be integers such that 10p.1 . 
n < 10p and for which the exact mathematical value of n * 
10e.p+1 . x is as close to zero as possible. If there are two such sets of e and n, pick the e and n for 
which n * 10e.p+1 is larger. 
b. 
Let m be the String consisting of the digits of the decimal representation of n (in order, with no 
leading zeroes). 
c. 
If e < .6 or e . 
p, then 
i. 
Let a be the first character of m, and let b be the remaining p.1 characters of m. 
ii. Let m be the concatenation of the three Strings a, ".", and b. 
iii. If e = 0, then 
1. 
Let c = "+" and d = "0". 
iv. Else e ≠ 0, 
1. 
If e > 0, then 
a Let c = "+". 
2. 
Else e < 0, 
a Let c = "-". 
b Let e = .e. 
3. 
Let d be the String consisting of the digits of the decimal representation of e (in 
order, with no leading zeroes). 
v. Let m be the concatenation of the five Strings s, m, "e", c, and d. 
11. 
If e = p.1, then return the concatenation of the Strings s and m. 
12. 
If e . 0, then 
a. 
Let m be the concatenation of the first e+1 characters of m, the character ‘.’, and the remaining p. 
(e+1) characters of m. 
13. 
Else e < 0, 
a. 
Let m be the concatenation of the String "0.", .(e+1) occurrences of the character ‘0’, and the 
String m. 

14. Return the concatenation of the Strings s and m. 
The length property of the toPrecision method is 1. 

If the toPrecision method is called with more than one argument, then the behaviour is undefined (see 
clause 15). 

An implementation is permitted to extend the behaviour of toPrecision for values of precision less than 1 or 
greater than 21. In this case toPrecision would not necessarily throw RangeError for such values. 

15.7.5 Properties of Number Instances 
Number instances inherit properties from the Number prototype object and their [[Class]] internal property 
value is "Number". Number instances also have a [[PrimitiveValue]] internal property. 

The [[PrimitiveValue]] internal property is the Number value represented by this Number object. 

15.8 The Math Object 
The Math object is a single object that has some named properties, some of which are functions. 

The value of the [[Prototype]] internal property of the Math object is the standard built-in Object prototype 
object (15.2.4). The value of the [[Class]] internal property of the Math object is "Math". 
The Math object does not have a [[Construct]] internal property; it is not possible to use the Math object as a 

constructor with the new operator. 
The Math object does not have a [[Call]] internal property; it is not possible to invoke the Math object as a 
function. 
NOTE In this specification, the phrase “the Number value for x” has a technical meaning defined in 8.5. 

15.8.1 Value Properties of the Math Object 
15.8.1.1 E 
The Number value for e, the base of the natural logarithms, which is approximately 2.7182818284590452354. 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.8.1.2 LN10 
The Number value for the natural logarithm of 10, which is approximately 2.302585092994046. 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.8.1.3 LN2 
The Number value for the natural logarithm of 2, which is approximately 0.6931471805599453. 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.8.1.4 LOG2E 
The Number value for the base-2 logarithm of e, the base of the natural logarithms; this value is approximately 
1.4426950408889634. 

15.8.1.5 LOG10E 
The Number value for the base-10 logarithm of e, the base of the natural logarithms; this value is 
approximately 0.4342944819032518. 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 
NOTE The value of Math.LOG10E is approximately the reciprocal of the value of Math.LN10. 

15.8.1.6 PI 
The Number value for π, the ratio of the circumference of a circle to its diameter, which is approximately 
3.1415926535897932. 

This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.8.1.7 SQRT1_2 
The Number value for the square root of ., which is approximately 0.7071067811865476. 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 
NOTE The value of Math.SQRT1_2 is approximately the reciprocal of the value of Math.SQRT2. 

15.8.1.8 SQRT2 
The Number value for the square root of 2, which is approximately 1.4142135623730951. 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.8.2 Function Properties of the Math Object 
Each of the following Math object functions applies the ToNumber abstract operator to each of its arguments 
(in left-to-right order if there is more than one) and then performs a computation on the resulting Number 
value(s). 

In the function descriptions below, the symbols NaN, -0, +0, -∞ and +∞ refer to the Number values described 
in 8.5. 

NOTE The behaviour of the functions acos, asin, atan, atan2, cos, exp, log, pow, sin, and sqrt is not 
precisely specified here except to require specific results for certain argument values that represent boundary cases of 
interest. For other argument values, these functions are intended to compute approximations to the results of familiar 
mathematical functions, but some latitude is allowed in the choice of approximation algorithms. The general intent is that 
an implementer should be able to use the same mathematical library for ECMAScript on a given hardware platform that is 
available to C programmers on that platform. 

Although the choice of algorithms is left to the implementation, it is recommended (but not specified by this standard) that 
implementations use the approximation algorithms for IEEE 754 arithmetic contained in fdlibm, the freely distributable 
mathematical library from Sun Microsystems (http://www.netlib.org/fdlibm). 

15.8.2.1 abs (x) 
Returns the absolute value of x; the result has the same magnitude as x but has positive sign. 


. 
If x is NaN, the result is NaN. 
. 
If x is -0, the result is +0. 
. 
If x is -∞, the result is +∞. 
15.8.2.2 acos (x) 
Returns an implementation-dependent approximation to the arc cosine of x. The result is expressed in radians 
and ranges from +0 to +π. 

. 
If x is NaN, the result is NaN. 
. 
If x is greater than 1, the result is NaN. 
. 
If x is less than -1, the result is NaN. 
. 
If x is exactly 1, the result is +0. 
15.8.2.3 asin (x) 
Returns an implementation-dependent approximation to the arc sine of x. The result is expressed in radians 
and ranges from .π/2 to +π/2. 

. 
If x is NaN, the result is NaN. 
. 
If x is greater than 1, the result is NaN. 
. 
If x is less than -1, the result is NaN. 
. 
If x is +0, the result is +0. 
. 
If x is -0, the result is -0. 
15.8.2.4 atan (x) 
Returns an implementation-dependent approximation to the arc tangent of x. The result is expressed in 
radians and ranges from .π/2 to +π/2. 

. 
If x is NaN, the result is NaN. 
. 
If x is +0, the result is +0. 
. 
If x is -0, the result is -0. 
. 
If x is +∞, the result is an implementation-dependent approximation to +π/2. 
. 
If x is -∞, the result is an implementation-dependent approximation to .π/2. 
15.8.2.5 atan2 (y, x) 
Returns an implementation-dependent approximation to the arc tangent of the quotient y/x of the arguments y 
and x, where the signs of y and x are used to determine the quadrant of the result. Note that it is intentional 
and traditional for the two-argument arc tangent function that the argument named y be first and the argument 
named x be second. The result is expressed in radians and ranges from .π to +π. 

. 
If either x or y is NaN, the result is NaN. 
. 
If y>0 and x is +0, the result is an implementation-dependent approximation to +π/2. 
. 
If y>0 and x is -0, the result is an implementation-dependent approximation to +π/2. 
. 
If y is +0 and x>0, the result is +0. 
. 
If y is +0 and x is +0, the result is +0. 
. 
If y is +0 and x is -0, the result is an implementation-dependent approximation to +π. 
. 
If y is +0 and x<0, the result is an implementation-dependent approximation to +π. 
. 
If y is -0 and x>0, the result is -0. 
. 
If y is -0 and x is +0, the result is -0. 
. 
If y is -0 and x is -0, the result is an implementation-dependent approximation to .π. 
. 
If y is -0 and x<0, the result is an implementation-dependent approximation to .π. 
. 
If y<0 and x is +0, the result is an implementation-dependent approximation to .π/2. 
. 
If y<0 and x is -0, the result is an implementation-dependent approximation to .π/2. 

. 
If y>0 and y is finite and x is +∞, the result is +0. 
. 
If y>0 and y is finite and x is -∞, the result if an implementation-dependent approximation to +π. 
. 
If y<0 and y is finite and x is +∞, the result is -0. 
. 
If y<0 and y is finite and x is -∞, the result is an implementation-dependent approximation to .π. 
. 
If y is +∞ and x is finite, the result is an implementation-dependent approximation to +π/2. 
. 
If y is -∞ and x is finite, the result is an implementation-dependent approximation to .π/2. 
. 
If y is +∞ and x is +∞, the result is an implementation-dependent approximation to +π/4. 
. 
If y is +∞ and x is -∞, the result is an implementation-dependent approximation to +3π/4. 
. 
If y is -∞ and x is +∞, the result is an implementation-dependent approximation to .π/4. 
. 
If y is -∞ and x is -∞, the result is an implementation-dependent approximation to .3π/4. 
15.8.2.6 ceil (x) 
Returns the smallest (closest to -∞) Number value that is not less than x and is equal to a mathematical 
integer. If x is already an integer, the result is x. 

. 
If x is NaN, the result is NaN. 
. 
If x is +0, the result is +0. 
. 
If x is -0, the result is -0. 
. 
If x is +∞, the result is +∞. 
. 
If x is -∞, the result is -∞. 
. 
If x is less than 0 but greater than -1, the result is -0. 
The value of Math.ceil(x) is the same as the value of -Math.floor(-x). 

15.8.2.7 cos (x) 
Returns an implementation-dependent approximation to the cosine of x. The argument is expressed in radians. 

. 
If x is NaN, the result is NaN. 
. 
If x is +0, the result is 1. 
. 
If x is -0, the result is 1. 
. 
If x is +∞, the result is NaN. 
. 
If x is -∞, the result is NaN. 
15.8.2.8 exp (x) 
Returns an implementation-dependent approximation to the exponential function of x (e raised to the power of 
x, where e is the base of the natural logarithms). 

. 
If x is NaN, the result is NaN. 
. 
If x is +0, the result is 1. 
. 
If x is -0, the result is 1. 
. 
If x is +∞, the result is +∞. 
. 
If x is -∞, the result is +0. 
15.8.2.9 floor (x) 
Returns the greatest (closest to +∞) Number value that is not greater than x and is equal to a mathematical 
integer. If x is already an integer, the result is x. 

. 
If x is NaN, the result is NaN. 
. 
If x is +0, the result is +0. 
. 
If x is -0, the result is -0. 
. 
If x is +∞, the result is +∞. 
. 
If x is -∞, the result is -∞. 

. 
If x is greater than 0 but less than 1, the result is +0. 
NOTE The value of Math.floor(x) is the same as the value of -Math.ceil(-x). 

15.8.2.10 log (x) 
. 
Returns an implementation-dependent approximation to the natural logarithm of x. 
. 
If x is NaN, the result is NaN. 
. 
If x is less than 0, the result is NaN. 
. 
If x is +0 or -0, the result is -∞. 
. 
If x is 1, the result is +0. 
. 
If x is +∞, the result is +∞. 
15.8.2.11 max ( [ value1 [ , value2 [ , … ] ] ] ) 
Given zero or more arguments, calls ToNumber on each of the arguments and returns the largest of the 
resulting values. 

. 
If no arguments are given, the result is -∞. 
. 
If any value is NaN, the result is NaN. 
. 
The comparison of values to determine the largest value is done as in 11.8.5 except that +0 is considered to 
be larger than -0. 
The length property of the max method is 2. 

15.8.2.12 min ( [ value1 [ , value2 [ , … ] ] ] ) 
Given zero or more arguments, calls ToNumber on each of the arguments and returns the smallest of the 
resulting values. 

. 
If no arguments are given, the result is +∞. 
. 
If any value is NaN, the result is NaN. 
. 
The comparison of values to determine the smallest value is done as in 11.8.5 except that +0 is considered 
to be larger than -0. 
The length property of the min method is 2. 

15.8.2.13 pow (x, y) 
Returns an implementation-dependent approximation to the result of raising x to the power y. 

. 
If y is NaN, the result is NaN. 
. 
If y is +0, the result is 1, even if x is NaN. 
. 
If y is -0, the result is 1, even if x is NaN. 
. 
If x is NaN and y is nonzero, the result is NaN. 
. 
If abs(x)>1 and y is +∞, the result is +∞. 
. 
If abs(x)>1 and y is -∞, the result is +0. 
. 
If abs(x)==1 and y is +∞, the result is NaN. 
. 
If abs(x)==1 and y is -∞, the result is NaN. 
. 
If abs(x)<1 and y is +∞, the result is +0. 
. 
If abs(x)<1 and y is -∞, the result is +∞. 
. 
If x is +∞ and y>0, the result is +∞. 
. 
If x is +∞ and y<0, the result is +0. 
. 
If x is -∞ and y>0 and y is an odd integer, the result is -∞. 
. 
If x is -∞ and y>0 and y is not an odd integer, the result is +∞. 
. 
If x is -∞ and y<0 and y is an odd integer, the result is -0. 

. 
If x is -∞ and y<0 and y is not an odd integer, the result is +0. 
. 
If x is +0 and y>0, the result is +0. 
. 
If x is +0 and y<0, the result is +∞. 
. 
If x is -0 and y>0 and y is an odd integer, the result is -0. 
. 
If x is -0 and y>0 and y is not an odd integer, the result is +0. 
. 
If x is -0 and y<0 and y is an odd integer, the result is -∞. 
. 
If x is -0 and y<0 and y is not an odd integer, the result is +∞. 
. 
If x<0 and x is finite and y is finite and y is not an integer, the result is NaN. 
15.8.2.14 random ( ) 
Returns a Number value with positive sign, greater than or equal to 0 but less than 1, chosen randomly or 
pseudo randomly with approximately uniform distribution over that range, using an implementation-dependent 
algorithm or strategy. This function takes no arguments. 

15.8.2.15 round (x) 
Returns the Number value that is closest to x and is equal to a mathematical integer. If two integer Number 
values are equally close to x, then the result is the Number value that is closer to +∞. If x is already an integer, 
the result is x. 

. 
If x is NaN, the result is NaN. 
. 
If x is +0, the result is +0. 
. 
If x is -0, the result is -0. 
. 
If x is +∞, the result is +∞. 
. 
If x is -∞, the result is -∞. 
. 
If x is greater than 0 but less than 0.5, the result is +0. 
. 
If x is less than 0 but greater than or equal to -0.5, the result is -0. 
NOTE 1 Math.round(3.5) returns 4, but Math.round(.3.5) returns .3. 

NOTE 2 The value of Math.round(x) is the same as the value of Math.floor(x+0.5), except when x is -0 or is 
less than 0 but greater than or equal to -0.5; for these cases Math.round(x) returns -0, but Math.floor(x+0.5) 
returns +0. 

15.8.2.16 sin (x) 
Returns an implementation-dependent approximation to the sine of x. The argument is expressed in radians. 

. 
If x is NaN, the result is NaN. 
. 
If x is +0, the result is +0. 
. 
If x is -0, the result is -0. 
. 
If x is +∞ or -∞, the result is NaN. 
15.8.2.17 sqrt (x) 
Returns an implementation-dependent approximation to the square root of x. 

. 
If x is NaN, the result is NaN. 
. 
If x is less than 0, the result is NaN. 
. 
If x is +0, the result is +0. 
. 
If x is -0, the result is -0. 
. 
If x is +∞, the result is +∞. 

15.8.2.18 tan (x) 
Returns an implementation-dependent approximation to the tangent of x. The argument is expressed in 
radians. 

. 
If x is NaN, the result is NaN. 
. 
If x is +0, the result is +0. 
. 
If x is -0, the result is -0. 
. 
If x is +∞ or -∞, the result is NaN. 
15.9 Date Objects 
15.9.1 Overview of Date Objects and Definitions of Abstract Operators 
The following functions are abstract operations that operate on time values (defined in 15.9.1.1). Note that, in 
every case, if any argument to one of these functions is NaN, the result will be NaN. 

15.9.1.1 Time Values and Time Range 
A Date object contains a Number indicating a particular instant in time to within a millisecond. Such a Number 
is called a time value. A time value may also be NaN, indicating that the Date object does not represent a 
specific instant of time. 

Time is measured in ECMAScript in milliseconds since 01 January, 1970 UTC. In time values leap seconds 
are ignored. It is assumed that there are exactly 86,400,000 milliseconds per day. ECMAScript Number values 
can represent all integers from .9,007,199,254,740,991 to 9,007,199,254,740,991; this range suffices to 
measure times to millisecond precision for any instant that is within approximately 285,616 years, either 
forward or backward, from 01 January, 1970 UTC. 

The actual range of times supported by ECMAScript Date objects is slightly smaller: exactly -100,000,000 
days to 100,000,000 days measured relative to midnight at the beginning of 01 January, 1970 UTC. This gives 
a range of 8,640,000,000,000,000 milliseconds to either side of 01 January, 1970 UTC. 

The exact moment of midnight at the beginning of 01 January, 1970 UTC is represented by the value +0. 

15.9.1.2 Day Number and Time within Day 
A given time value t belongs to day number 

Day(t) = floor(t / msPerDay) 

where the number of milliseconds per day is 

msPerDay = 86400000 

The remainder is called the time within the day: 

TimeWithinDay(t) = t modulo msPerDay 

15.9.1.3 Year Number 
ECMAScript uses an extrapolated Gregorian system to map a day number to a year number and to determine 
the month and date within that year. In this system, leap years are precisely those which are (divisible by 4) 
and ((not divisible by 100) or (divisible by 400)). The number of days in year number y is therefore defined by 

DaysInYear(y) = 365 if (y modulo 4) ≠ 0 

= 366 if (y modulo 4) = 0 and (y modulo 100) ≠ 0 

= 365 if (y modulo 100) = 0 and (y modulo 400) ≠ 0 

= 366 if (y modulo 400) = 0 


All non-leap years have 365 days with the usual number of days per month and leap years have an extra day 
in February. The day number of the first day of year y is given by: 

DayFromYear(y) = 365 * (y.1970) + floor((y.1969)/4) . floor((y.1901)/100) + floor((y.1601)/400) 

The time value of the start of a year is: 

TimeFromYear(y) = msPerDay * DayFromYear(y) 

A time value determines a year by: 

YearFromTime(t) 
= the largest integer y (closest to positive infinity) such that TimeFromYear(y) . 
t 

The leap-year function is 1 for a time within a leap year and otherwise is zero: 

InLeapYear(t) 
= 0 if DaysInYear(YearFromTime(t)) = 365 
= 1 if DaysInYear(YearFromTime(t)) = 366 

15.9.1.4 Month Number 
Months are identified by an integer in the range 0 to 11, inclusive. The mapping MonthFromTime(t) from a time 
value t to a month number is defined by: 

MonthFromTime(t) = 0 if0 . DayWithinYear(t) < 31 
= 1 if 31 . DayWithinYear (t) < 59+InLeapYear(t) 
= 2 if 59+InLeapYear(t) . DayWithinYear (t) < 90+InLeapYear(t) 
= 3 if 90+InLeapYear(t) . DayWithinYear (t) < 120+InLeapYear(t) 
= 4 if 120+InLeapYear(t) . DayWithinYear (t) < 151+InLeapYear(t) 
= 5 if 151+InLeapYear(t) . DayWithinYear (t) < 181+InLeapYear(t) 
= 6 if 181+InLeapYear(t) . DayWithinYear (t) < 212+InLeapYear(t) 
= 7 if 212+InLeapYear(t) . DayWithinYear (t) < 243+InLeapYear(t) 
= 8 if 243+InLeapYear(t) . DayWithinYear (t) < 273+InLeapYear(t) 
= 9 if 273+InLeapYear(t) . DayWithinYear (t) < 304+InLeapYear(t) 
= 10 if 304+InLeapYear(t) . DayWithinYear (t) < 334+InLeapYear(t) 
= 11 if 334+InLeapYear(t) . DayWithinYear (t) < 365+InLeapYear(t) 

where 

DayWithinYear(t) = Day(t).DayFromYear(YearFromTime(t)) 

A month value of 0 specifies January; 1 specifies February; 2 specifies March; 3 specifies April; 4 specifies 
May; 5 specifies June; 6 specifies July; 7 specifies August; 8 specifies September; 9 specifies October; 10 
specifies November; and 11 specifies December. Note that MonthFromTime(0) = 0, corresponding to Thursday, 
01 January, 1970. 

15.9.1.5 Date Number 
A date number is identified by an integer in the range 1 through 31, inclusive. The mapping DateFromTime(t) 
from a time value t to a month number is defined by: 

DateFromTime(t) = DayWithinYear(t)+1 if MonthFromTime(t)=0 
= DayWithinYear(t).30 if MonthFromTime(t)=1 
= DayWithinYear(t).58.InLeapYear(t) if MonthFromTime(t)=2 
= DayWithinYear(t).89.InLeapYear(t) if MonthFromTime(t)=3 
= DayWithinYear(t).119.InLeapYear(t) if MonthFromTime(t)=4 
= DayWithinYear(t).150.InLeapYear(t) if MonthFromTime(t)=5 
= DayWithinYear(t).180.InLeapYear(t) if MonthFromTime(t)=6 
= DayWithinYear(t).211.InLeapYear(t) if MonthFromTime(t)=7 
= DayWithinYear(t).242.InLeapYear(t) if MonthFromTime(t)=8 
= DayWithinYear(t).272.InLeapYear(t) if MonthFromTime(t)=9 
= DayWithinYear(t).303.InLeapYear(t) if MonthFromTime(t)=10 
= DayWithinYear(t).333.InLeapYear(t) if MonthFromTime(t)=11 


15.9.1.6 Week Day 
The weekday for a particular time value t is defined as 

WeekDay(t) = (Day(t) + 4) modulo 7 

A weekday value of 0 specifies Sunday; 1 specifies Monday; 2 specifies Tuesday; 3 specifies Wednesday; 
4 specifies Thursday; 5 specifies Friday; and 6 specifies Saturday. Note that WeekDay(0) = 4, corresponding to 
Thursday, 01 January, 1970. 

15.9.1.7 Local Time Zone Adjustment 
An implementation of ECMAScript is expected to determine the local time zone adjustment. The local time 
zone adjustment is a value LocalTZA measured in milliseconds which when added to UTC represents the 
local standard time. Daylight saving time is not reflected by LocalTZA. The value LocalTZA does not vary with 
time but depends only on the geographic location. 

15.9.1.8 Daylight Saving Time Adjustment 
An implementation of ECMAScript is expected to determine the daylight saving time algorithm. The algorithm 
to determine the daylight saving time adjustment DaylightSavingTA(t), measured in milliseconds, must depend 
only on four things: 

(1) the time since the beginning of the year 
t . TimeFromYear(YearFromTime(t)) 

(2) whether t is in a leap year 
InLeapYear(t) 
(3) the week day of the beginning of the year 
WeekDay(TimeFromYear(YearFromTime(t)) 

and (4) the geographic location. 

The implementation of ECMAScript should not try to determine whether the exact time was subject to daylight 
saving time, but just whether daylight saving time would have been in effect if the current daylight saving time 
algorithm had been used at the time. This avoids complications such as taking into account the years that the 
locale observed daylight saving time year round. 

If the host environment provides functionality for determining daylight saving time, the implementation of 
ECMAScript is free to map the year in question to an equivalent year (same leap-year-ness and same starting 
week day for the year) for which the host environment provides daylight saving time information. The only 
restriction is that all equivalent years should produce the same result. 

15.9.1.9 Local Time 
Conversion from UTC to local time is defined by 

LocalTime(t) = t + LocalTZA + DaylightSavingTA(t) 

Conversion from local time to UTC is defined by 

UTC(t) = t . LocalTZA . DaylightSavingTA(t . LocalTZA) 
Note that UTC(LocalTime(t)) is not necessarily always equal to t. 

15.9.1.10 Hours, Minutes, Second, and Milliseconds 
The following functions are useful in decomposing time values: 

HourFromTime(t) = floor(t / msPerHour) modulo HoursPerDay 


MinFromTime(t) = floor(t / msPerMinute) modulo MinutesPerHour 

SecFromTime(t) = floor(t / msPerSecond) modulo SecondsPerMinute 

msFromTime(t) = t modulo msPerSecond 

where 

HoursPerDay = 24 

MinutesPerHour = 60 

SecondsPerMinute = 60 

msPerSecond = 1000 

msPerMinute = 60000 = msPerSecond * SecondsPerMinute 

msPerHour = 3600000 = msPerMinute * MinutesPerHour 

15.9.1.11 MakeTime (hour, min, sec, ms) 
The operator MakeTime calculates a number of milliseconds from its four arguments, which must be 
ECMAScript Number values. This operator functions as follows: 

1. 
If hour is not finite or min is not finite or sec is not finite or ms is not finite, return NaN. 
2. 
Let h be ToInteger(hour). 
3. 
Let m be ToInteger(min). 
4. 
Let s be ToInteger(sec). 
5. 
Let milli be ToInteger(ms). 
6. 
Let t be h * msPerHour + m * msPerMinute + s * msPerSecond + milli, performing the arithmetic according 
to IEEE 754 rules (that is, as if using the ECMAScript operators * and +). 
7. 
Return t. 
15.9.1.12 MakeDay (year, month, date) 
The operator MakeDay calculates a number of days from its three arguments, which must be ECMAScript 
Number values. This operator functions as follows: 

1. 
If year is not finite or month is not finite or date is not finite, return NaN. 
2. 
Let y be ToInteger(year). 
3. 
Let m be ToInteger(month). 
4. 
Let dt be ToInteger(date). 
5. 
Let ym be y + floor(m /12). 
6. 
Let mn be m modulo 12. 
7. 
Find a value t such that YearFromTime(t) == ym and MonthFromTime(t) == mn) and DateFromTime(t) == 
1; but if this is not possible (because some argument is out of range), return NaN. 
8. 
Return Day(t) + dt . 1. 
15.9.1.13 MakeDate (day, time) 
The operator MakeDate calculates a number of milliseconds from its two arguments, which must be 
ECMAScript Number values. This operator functions as follows: 

1. 
If day is not finite or time is not finite, return NaN. 
2. 
Return day * msPerDay + time. 
15.9.1.14 TimeClip (time) 
The operator TimeClip calculates a number of milliseconds from its argument, which must be an ECMAScript 
Number value. This operator functions as follows: 

1. 
If time is not finite, return NaN. 

2. 
If abs(time) > 8.64 x 1015, return NaN. 
3. 
Return an implementation-dependent choice of either ToInteger(time) or ToInteger(time) + (+0). (Adding a 
positive zero converts -0 to +0.) 
NOTE The point of step 3 is that an implementation is permitted a choice of internal representations of time values, 
for example as a 64-bit signed integer or as a 64-bit floating-point value. Depending on the implementation, this internal 
representation may or may not distinguish -0 and +0. 

15.9.1.15 Date Time String Format 
ECMAScript defines a string interchange format for date-times based upon a simplification of the ISO 8601 
Extended Format. The format is as follows: YYYY-MM-DDTHH:mm:ss.sssZ 

Where the fields are as follows: 

YYYY is the decimal digits of the year in the Gregorian calendar. 

-“:” (hyphon) appears literally twice in the string. 

MM is the month of the year from 01 (January) to 12 (December). 

DD is the day of the month from 01 to 31. 

T “T” appears literally in the string, to indicate the beginning of the time element. 

HH is the number of complete hours that have passed since midnight as two decimal digits. 

: “:” (colon) appears literally twice in the string. 

mm is the number of complete minutes since the start of the hour as two decimal digits. 

ss is the number of complete seconds since the start of the minute as two decimal digits. 

. “.” (dot) appears literally in the string. 

sss is the number of complete milliseconds since the start of the second as three decimal digits. 

Both the “.” and the milliseconds field may be omitted. 

Z is the time zone offset specified as “Z” (for UTC) or either “+” or “-” followed by a time 

expression hh:mm 

This format includes date-only forms: 

YYYY 
YYYY-MM 
YYYY-MM-DD 

It also includes time-only forms with an optional time zone offset appended: 

THH:mm 
THH:mm:ss 
THH:mm:ss.sss 

Also included are “date-times” which may be any combination of the above. 

All numbers must be base 10. 

Illegal values (out-of-bounds as well as syntax errors) in a format string means that the format string is not a 
valid instance of this format. 

NOTE 1 As every day both starts and ends with midnight, the two notations 00:00 and 24:00 are available to 
distinguish the two midnights that can be associated with one date. This means that the following two notations refer to 
exactly the same point in time: 1995-02-04T24:00 and 1995-02-05T00:00 

NOTE 2 There exists no international standard that specifies abbreviations for civil time zones like CET, EST, etc. and 
sometimes the same abbreviation is even used for two very different time zones. For this reason, ISO 8601 and this 
format specifies numeric representations of date and time. 


15.9.1.15.1 Extended years 
ECMAScript requires the ability to specify 6 digit years (extended years); approximately 285,616 years, either 
forward or backward, from 01 January, 1970 UTC. To represent years before 0 or after 9999, ISO 8601 
permits the expansion of the year representation, but only by prior agreement between the sender and the 
receiver. In the simplified ECMAScript format such an expanded year representation shall have 2 extra year 
digits and is always prefixed with a + or . sign. The year 0 is considered positive and hence prefixed with a + 
sign. 

15.9.2 The Date Constructor Called as a Function 
When Date is called as a function rather than as a constructor, it returns a String representing the current 
time (UTC). 

NOTE The function call Date(…) is not equivalent to the object creation expression new Date(…) with the same 
arguments. 

15.9.2.1 Date ( [ year [, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] ] ] ) 
All of the arguments are optional; any arguments supplied are accepted but are completely ignored. A String 
is created and returned as if by the expression (new Date()).toString() where Date is the standard 
built-in constructor with that name and toString is the standard built-in method 
Date.prototype.toString. 

15.9.3 The Date Constructor 
When Date is called as part of a new expression, it is a constructor: it initialises the newly created object. 

15.9.3.1 new Date (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] ) 
When Date is called with two to seven arguments, it computes the date from year, month, and (optionally) 
date, hours, minutes, seconds and ms. 

The [[Prototype]] internal property of the newly constructed object is set to the original Date prototype object, 
the one that is the initial value of Date.prototype (15.9.4.1). 

The [[Class]] internal property of the newly constructed object is set to "Date". 

The [[Extensible]] internal property of the newly constructed object is set to true. 

The [[PrimitiveValue]] internal property of the newly constructed object is set as follows: 

1. Let y be ToNumber(year). 
2. Let m be ToNumber(month). 
3. If date is supplied then let dt be ToNumber(date); else let dt be 1. 
4. If hours is supplied then let h be ToNumber(hours); else let h be 0. 
5. If minutes is supplied then let min be ToNumber(minutes); else let min be 0. 
6. If seconds is supplied then let s be ToNumber(seconds); else let s be 0. 
7. If ms is supplied then let milli be ToNumber(ms); else let milli be 0. 
8. If y is not NaN and 0 . ToInteger(y) . 99, then let yr be 1900+ToInteger(y); otherwise, let yr be y. 
9. Let finalDate be MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)). 
10. Set the [[PrimitiveValue]] internal property of the newly constructed object to TimeClip(UTC(finalDate)). 
15.9.3.2 new Date (value) 
The [[Prototype]] internal property of the newly constructed object is set to the original Date prototype object, 
the one that is the initial value of Date.prototype (15.9.4.1). 


The [[Class]] internal property of the newly constructed object is set to "Date". 

The [[Extensible]] internal property of the newly constructed object is set to true. 

The [[PrimitiveValue]] internal property of the newly constructed object is set as follows: 

1. 
Let v be ToPrimitive(value). 
2. 
If Type(v) is String, then 
a. 
Parse v as a date, in exactly the same manner as for the parse method (15.9.4.2); let V be the time 
value for this date. 
3. 
Else, let V be ToNumber(v). 
4. 
Set the [[PrimitiveValue]] internal property of the newly constructed object to TimeClip(V) and return. 
15.9.3.3 new Date ( ) 
The [[Prototype]] internal property of the newly constructed object is set to the original Date prototype object, 
the one that is the initial value of Date.prototype (15.9.4.1). 

The [[Class]] internal property of the newly constructed object is set to "Date". 

The [[Extensible]] internal property of the newly constructed object is set to true. 

The [[PrimitiveValue]] internal property of the newly constructed object is set to the time value (UTC) 
identifying the current time. 

15.9.4 Properties of the Date Constructor 
The value of the [[Prototype]] internal property of the Date constructor is the Function prototype object (15.3.4). 

Besides the internal properties and the length property (whose value is 7), the Date constructor has the 
following properties: 

15.9.4.1 Date.prototype 
The initial value of Date.prototype is the built-in Date prototype object (15.9.5). 

This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.9.4.2 Date.parse (string) 
The parse function applies the ToString operator to its argument and interprets the resulting String as a date 
and time; it returns a Number, the UTC time value corresponding to the date and time. The String may be 
interpreted as a local time, a UTC time, or a time in some other time zone, depending on the contents of the 
String. The function first attempts to parse the format of the String according to the rules called out in Date 
Time String Format (15.9.1.15). If the String does not conform to that format the function may fall back to any 
implementation-specific heuristics or implementation-specific date formats. Unrecognizable Strings or dates 
containing illegal element values in the format String shall cause Date.parse to return NaN. 

If x is any Date object whose milliseconds amount is zero within a particular implementation of ECMAScript, 
then all of the following expressions should produce the same numeric value in that implementation, if all the 
properties referenced have their initial values: 

x.valueOf()

Date.parse(x.toString())

Date.parse(x.toUTCString())

Date.parse(x.toISOString()) 

However, the expression 

Date.parse(x.toLocaleString()) 


is not required to produce the same Number value as the preceding three expressions and, in general, the 
value produced by Date.parse is implementation-dependent when given any String value that does not 
conform to the Date Time String Format (15.9.1.15) and that could not be produced in that implementation by 
the toString or toUTCString method. 

15.9.4.3 Date.UTC (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] ) 
When the UTC function is called with fewer than two arguments, the behaviour is implementation-dependent. 
When the UTC function is called with two to seven arguments, it computes the date from year, month and 
(optionally) date, hours, minutes, seconds and ms. The following steps are taken: 

1. Let y be ToNumber(year). 
2. Let m be ToNumber(month). 
3. If date is supplied then let dt be ToNumber(date); else let dt be 1. 
4. If hours is supplied then let h be ToNumber(hours); else let h be 0. 
5. If minutes is supplied then let min be ToNumber(minutes); else let min be 0. 
6. If seconds is supplied then let s be ToNumber(seconds); else let s be 0. 
7. If ms is supplied then let milli be ToNumber(ms); else let milli be 0. 
8. If y is not NaN and 0 . ToInteger(y) . 99, then let yr be 1900+ToInteger(y); otherwise, let yr be y. 
9. Return TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli))). 
The length property of the UTC function is 7. 

NOTE The UTC function differs from the Date constructor in two ways: it returns a time value as a Number, rather 
than creating a Date object, and it interprets the arguments in UTC rather than as local time. 

15.9.4.4 Date.now ( ) 
The now function return a Number value that is the time value designating the UTC date and time of the 
occurrence of the call to now. 

15.9.5 Properties of the Date Prototype Object 
The Date prototype object is itself a Date object (its [[Class]] is "Date") whose [[PrimitiveValue]] is NaN. 

The value of the [[Prototype]] internal property of the Date prototype object is the standard built-in Object 
prototype object (15.2.4). 

In following descriptions of functions that are properties of the Date prototype object, the phrase “this Date 
object” refers to the object that is the this value for the invocation of the function. Unless explicitly noted 
otherwise, none of these functions are generic; a TypeError exception is thrown if the this value is not an 
object for which the value of the [[Class]] internal property is "Date". Also, the phrase “this time value” refers 
to the Number value for the time represented by this Date object, that is, the value of the [[PrimitiveValue]] 
internal property of this Date object. 

15.9.5.1 Date.prototype.constructor 
The initial value of Date.prototype.constructor is the built-in Date constructor. 

15.9.5.2 Date.prototype.toString ( ) 
This function returns a String value. The contents of the String are implementation-dependent, but are 
intended to represent the Date in the current time zone in a convenient, human-readable form. 

NOTE For any Date value d whose milliseconds amount is zero, the result of Date.parse(d.toString()) is 
equal to d.valueOf(). See 15.9.4.2. 


15.9.5.3 Date.prototype.toDateString ( ) 
This function returns a String value. The contents of the String are implementation-dependent, but are 
intended to represent the “date” portion of the Date in the current time zone in a convenient, human-readable 
form. 

15.9.5.4 Date.prototype.toTimeString ( ) 
This function returns a String value. The contents of the String are implementation-dependent, but are 
intended to represent the “time” portion of the Date in the current time zone in a convenient, human-readable 
form. 

15.9.5.5 Date.prototype.toLocaleString ( ) 
This function returns a String value. The contents of the String are implementation-dependent, but are 
intended to represent the Date in the current time zone in a convenient, human-readable form that 
corresponds to the conventions of the host environment’s current locale. 

NOTE The first parameter to this function is likely to be used in a future version of this standard; it is recommended 
that implementations do not use this parameter position for anything else. 

15.9.5.6 Date.prototype.toLocaleDateString ( ) 
This function returns a String value. The contents of the String are implementation-dependent, but are 
intended to represent the “date” portion of the Date in the current time zone in a convenient, human-readable 
form that corresponds to the conventions of the host environment’s current locale. 

NOTE The first parameter to this function is likely to be used in a future version of this standard; it is recommended 
that implementations do not use this parameter position for anything else. 

15.9.5.7 Date.prototype.toLocaleTimeString ( ) 
This function returns a String value. The contents of the String are implementation-dependent, but are 
intended to represent the “time” portion of the Date in the current time zone in a convenient, human-readable 
form that corresponds to the conventions of the host environment’s current locale. 

NOTE The first parameter to this function is likely to be used in a future version of this standard; it is recommended 
that implementations do not use this parameter position for anything else. 

15.9.5.8 Date.prototype.valueOf ( ) 
The valueOf function returns a Number, which is this time value. 

15.9.5.9 Date.prototype.getTime ( ) 
1. Return this time value. 
15.9.5.10 Date.prototype.getFullYear ( ) 
1. Let t be this time value. 
2. If t is NaN, return NaN. 
3. Return YearFromTime(LocalTime(t)). 
15.9.5.11 Date.prototype.getUTCFullYear ( ) 
1. Let t be this time value. 
2. If t is NaN, return NaN. 

3. Return YearFromTime(t). 
15.9.5.12 Date.prototype.getMonth ( ) 
1. Let t be this time value. 
2. If t is NaN, return NaN. 
3. Return MonthFromTime(LocalTime(t)). 
15.9.5.13 Date.prototype.getUTCMonth ( ) 
1. Let t be this time value. 
2. If t is NaN, return NaN. 
3. Return MonthFromTime(t). 
15.9.5.14 Date.prototype.getDate ( ) 
1. Let t be this time value. 
2. If t is NaN, return NaN. 
3. Return DateFromTime(LocalTime(t)). 
15.9.5.15 Date.prototype.getUTCDate ( ) 
1. Let t be this time value. 
2. If t is NaN, return NaN. 
3. Return DateFromTime(t). 
15.9.5.16 Date.prototype.getDay ( ) 
1. Let t be this time value. 
2. If t is NaN, return NaN. 
3. Return WeekDay(LocalTime(t)). 
15.9.5.17 Date.prototype.getUTCDay ( ) 
1. Let t be this time value. 
2. If t is NaN, return NaN. 
3. Return WeekDay(t). 
15.9.5.18 Date.prototype.getHours ( ) 
1. Let t be this time value. 
2. If t is NaN, return NaN. 
3. Return HourFromTime(LocalTime(t)). 
15.9.5.19 Date.prototype.getUTCHours ( ) 
1. Let t be this time value. 
2. If t is NaN, return NaN. 
3. Return HourFromTime(t). 
15.9.5.20 Date.prototype.getMinutes ( ) 
1. Let t be this time value. 
2. If t is NaN, return NaN. 
3. Return MinFromTime(LocalTime(t)). 

1. Let t be this time value. 
2. If t is NaN, return NaN. 
3. Return (t . LocalTime(t)) / msPerMinute. 
15.9.5.27 Date.prototype.setTime (time) 
1. Let v be TimeClip(ToNumber(time)). 
2. Set the [[PrimitiveValue]] internal property of this Date object to v. 
3. Return v. 
15.9.5.28 Date.prototype.setMilliseconds (ms) 
1. Let t be the result of LocalTime(this time value). 
2. Let time be MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ToNumber(ms)). 
3. Let u be TimeClip(UTC(MakeDate(Day(t), time))). 
4. Set the [[PrimitiveValue]] internal property of this Date object to u. 
5. Return u. 
15.9.5.29 Date.prototype.setUTCMilliseconds (ms) 
1. Let t be this time value. 
2. Let time be MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ToNumber(ms)). 
3. Let v be TimeClip(MakeDate(Day(t), time)). 
4. Set the [[PrimitiveValue]] internal property of this Date object to v. 

5. Return v. 
15.9.5.30 Date.prototype.setSeconds (sec [, ms ] ) 
If ms is not specified, this behaves as if ms were specified with the value getMilliseconds(). 

1. Let t be the result of LocalTime(this time value). 
2. Let s be ToNumber(sec). 
3. If ms is not specified, then let milli be msFromTime(t); otherwise, let milli be ToNumber(ms). 
4. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)). 
5. Let u be TimeClip(UTC(date)). 
6. Set the [[PrimitiveValue]] internal property of this Date object to u. 
7. Return u. 
The length property of the setSeconds method is 2. 

15.9.5.31 Date.prototype.setUTCSeconds (sec [, ms ] ) 
If ms is not specified, this behaves as if ms were specified with the value getUTCMilliseconds(). 

1. Let t be this time value. 
2. Let s be ToNumber(sec). 
3. If ms is not specified, then let milli be msFromTime(t); otherwise, let milli be ToNumber(ms). 
4. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)). 
5. Let v be TimeClip(date). 
6. Set the [[PrimitiveValue]] internal property of this Date object to v. 
7. Return v. 
The length property of the setUTCSeconds method is 2. 

15.9.5.32 Date.prototype.setMinutes (min [, sec [, ms ] ] ) 
If sec is not specified, this behaves as if sec were specified with the value getSeconds(). 

If ms is not specified, this behaves as if ms were specified with the value getMilliseconds(). 

1. Let t be the result of LocalTime(this time value). 
2. Let m be ToNumber(min). 
3. If sec is not specified, then let s be SecFromTime(t); otherwise, let s be ToNumber(sec). 
4. If ms is not specified, then let milli be msFromTime(t); otherwise, let milli be ToNumber(ms). 
5. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)). 
6. Let u be TimeClip(UTC(date)). 
7. Set the [[PrimitiveValue]] internal property of this Date object to u. 
8. Return u. 
The length property of the setMinutes method is 3. 

15.9.5.33 Date.prototype.setUTCMinutes (min [, sec [, ms ] ] ) 
If sec is not specified, this behaves as if sec were specified with the value getUTCSeconds(). 

If ms is not specified, this function behaves as if ms were specified with the value return bygetUTCMilliseconds(). 

1. Let t be this time value. 
2. Let m be ToNumber(min). 
3. If sec is not specified, then let s be SecFromTime(t); otherwise, let s be ToNumber(sec). 
4. If ms is not specified, then let milli be msFromTime(t); otherwise, let milli be ToNumber(ms). 

5. Let date be MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)). 
6. Let v be TimeClip(date). 
7. Set the [[PrimitiveValue]] internal property of this Date object to v. 
8. Return v. 
The length property of the setUTCMinutes method is 3. 

15.9.5.34 Date.prototype.setHours (hour [, min [, sec [, ms ] ] ] ) 
If min is not specified, this behaves as if min were specified with the value getMinutes(). 

If sec is not specified, this behaves as if sec were specified with the value getSeconds(). 

If ms is not specified, this behaves as if ms were specified with the value getMilliseconds(). 

1. Let t be the result of LocalTime(this time value). 
2. Let h be ToNumber(hour). 
3. If min is not specified, then let m be MinFromTime(t); otherwise, let m be ToNumber(min). 
4. If If sec is not specified, then let s be SecFromTime(t); otherwise, let s be ToNumber(sec). 
5. If ms is not specified, then let milli be msFromTime(t); otherwise, let milli be ToNumber(ms). 
6. Let date be MakeDate(Day(t), MakeTime(h, m, s, milli)). 
7. Let u be TimeClip(UTC(date)). 
8. Set the [[PrimitiveValue]] internal property of this Date object to u. 
9. Return u. 
The length property of the setHours method is 4. 

15.9.5.35 Date.prototype.setUTCHours (hour [, min [, sec [, ms ] ] ] ) 
If min is not specified, this behaves as if min were specified with the value getUTCMinutes(). 

If sec is not specified, this behaves as if sec were specified with the value getUTCSeconds(). 

If ms is not specified, this behaves as if ms were specified with the value getUTCMilliseconds(). 

1. Let t be this time value. 
2. Let h be ToNumber(hour). 
3. If min is not specified, then let m be MinFromTime(t); otherwise, let m be ToNumber(min). 
4. If sec is not specified, then let s be SecFromTime(t); otherwise, let s be ToNumber(sec). 
5. If ms is not specified, then let milli be msFromTime(t); otherwise, let milli be ToNumber(ms). 
6. Let newDate be MakeDate(Day(t), MakeTime(h, m, s, milli)). 
7. Let v be TimeClip(newDate). 
8. Set the [[PrimitiveValue]] internal property of this Date object to v. 
9. Return v. 
The length property of the setUTCHours method is 4. 

15.9.5.36 Date.prototype.setDate (date) 
1. Let t be the result of LocalTime(this time value). 
2. Let dt be ToNumber(date). 
3. Let newDate be MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)). 
4. Let u be TimeClip(UTC(newDate)). 
5. Set the [[PrimitiveValue]] internal property of this Date object to u. 
6. Return u. 

15.9.5.37 Date.prototype.setUTCDate (date) 
1. Let t be this time value. 
2. Let dt be ToNumber(date). 
3. Let newDate be MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)). 
4. Let v be TimeClip(newDate). 
5. Set the [[PrimitiveValue]] internal property of this Date object to v. 
6. Return v. 
15.9.5.38 Date.prototype.setMonth (month [, date ] ) 
If date is not specified, this behaves as if date were specified with the value getDate(). 

1. Let t be the result of LocalTime(this time value). 
2. Let m be ToNumber(month). 
3. If date is not specified, then let dt be DateFromTime(t); otherwise, let dt be ToNumber(date). 
4. Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)). 
5. Let u be TimeClip(UTC(newDate)). 
6. Set the [[PrimitiveValue]] internal property of this Date object to u. 
7. Return u. 
The length property of the setMonth method is 2. 

15.9.5.39 Date.prototype.setUTCMonth (month [, date ] ) 
If date is not specified, this behaves as if date were specified with the value getUTCDate(). 

1. Let t be this time value. 
2. Let m be ToNumber(month). 
3. If date is not specified, then let dt be DateFromTime(t); otherwise, let dt be ToNumber(date). 
4. Let newDate be MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)). 
5. Let v be TimeClip(newDate). 
6. Set the [[PrimitiveValue]] internal property of this Date object to v. 
7. Return v. 
The length property of the setUTCMonth method is 2. 

15.9.5.40 Date.prototype.setFullYear (year [, month [, date ] ] ) 
If month is not specified, this behaves as if month were specified with the value getMonth(). 

If date is not specified, this behaves as if date were specified with the value getDate(). 

1. Let t be the result of LocalTime(this time value); but if this time value is NaN, let t be +0. 
2. Let y be ToNumber(year). 
3. If month is not specified, then let m be MonthFromTime(t); otherwise, let m be ToNumber(month). 
4. If date is not specified, then let dt be DateFromTime(t); otherwise, let dt be ToNumber(date). 
5. Let newDate be MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)). 
6. Let u be TimeClip(UTC(newDate)). 
7. Set the [[PrimitiveValue]] internal property of this Date object to u. 
8. Return u. 
The length property of the setFullYear method is 3. 

15.9.5.41 Date.prototype.setUTCFullYear (year [, month [, date ] ] ) 
If month is not specified, this behaves as if month were specified with the value getUTCMonth(). 


If date is not specified, this behaves as if date were specified with the value getUTCDate(). 

1. 
Let t be this time value; but if this time value is NaN, let t be +0. 
2. 
Let y be ToNumber(year). 
3. 
If month is not specified, then let m be MonthFromTime(t); otherwise, let m be ToNumber(month). 
4. 
If date is not specified, then let dt be DateFromTime(t); otherwise, let dt be ToNumber(date). 
5. 
Let newDate be MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)). 
6. 
Let v be TimeClip(newDate). 
7. 
Set the [[PrimitiveValue]] internal property of this Date object to v. 
8. 
Return v. 
The length property of the setUTCFullYear method is 3. 

15.9.5.42 Date.prototype.toUTCString ( ) 
This function returns a String value. The contents of the String are implementation-dependent, but are 
intended to represent the Date in a convenient, human-readable form in UTC. 

NOTE The intent is to produce a String representation of a date that is more readable than the format specified in 

15.9.1.15. It is not essential that the chosen format be unambiguous or easily machine parsable. If an implementation 
does not have a preferred human-readable format it is recommended to use the format defined in 15.9.1.15 but with a 
space rather than a “T” used to separate the date and time elements. 
15.9.5.43 Date.prototype.toISOString ( ) 
This function returns a String value represent the instance in time represented by this Date object. The format 
of the String is the Date Time string format defined in 15.9.1.15. All fields are present in the String. The time 
zone is always UTC, denoted by the suffix Z. If the time value of this object is not a finite Number a 
RangeError exception is thrown. 

15.9.5.44 Date.prototype.toJSON ( key ) 
This function provides a String representation of a Date object for use by JSON.stringify (15.12.3). 

When the toJSON method is called with argument key, the following steps are taken: 

1. 
Let O be the result of calling ToObject, giving it the this value as its argument. 
2. 
Let tv be ToPrimitive(O, hint Number). 
3. 
If tv is a Number and is not finite, return null. 
4. 
Let toISO be the result of calling the [[Get]] internal method of O with argument "toISOString". 
5. 
If IsCallable(toISO) is false, throw a TypeError exception. 
6. 
Return the result of calling the [[Call]] internal method of toISO with O as the this value and an empty 
argument list. 
NOTE 1 The argument is ignored. 

NOTE 2 The toJSON function is intentionally generic; it does not require that its this value be a Date object. Therefore, 
it can be transferred to other kinds of objects for use as a method. However, it does require that any such object have a 
toISOString method. An object is free to use the argument key to filter its stringification. 

15.9.6 Properties of Date Instances 
Date instances inherit properties from the Date prototype object and their [[Class]] internal property value is 
"Date". Date instances also have a [[PrimitiveValue]] internal property. 

The [[PrimitiveValue]] internal property is time value represented by this Date object. 


15.10 RegExp (Regular Expression) Objects 
A RegExp object contains a regular expression and the associated flags. 

NOTE The form and functionality of regular expressions is modelled after the regular expression facility in the Perl 5 
programming language. 

15.10.1 Patterns 
The RegExp constructor applies the following grammar to the input pattern String. An error occurs if the 
grammar cannot interpret the String as an expansion of Pattern. 

Syntax

構文 

Pattern :: 
Disjunction 

Disjunction :: 
Alternative 
Alternative | Disjunction 

Alternative :: 

[empty] 

Alternative Term 

Term :: 
Assertion 
Atom 
Atom Quantifier 

Assertion :: 

^ 
$ 
\ b 
\ B 
(?=Disjunction )
(?! Disjunction ) 

  QuantifierPrefix :: 
    * 
    + 
    ? 
    { DecimalDigits }
    { DecimalDigits ,} 
    { DecimalDigits , DecimalDigits } 

Atom :: 
PatternCharacter 

. 

\ AtomEscape 
CharacterClass 
(Disjunction )
(?:Disjunction ) 



PatternCharacter :: SourceCharacter but not any of: 
^ $ \ . * + ? ( ) [ ] { } | 

AtomEscape :: 
DecimalEscape 
CharacterEscape 
CharacterClassEscape 

CharacterEscape :: 
ControlEscape 
c ControlLetter 
HexEscapeSequence 
UnicodeEscapeSequence 
IdentityEscape 

ControlEscape :: one of 

f n r t v 

ControlLetter :: one of 

a b c d e f g h i j k l m n o p q r s t u v w x y zA B C D E F G H I J K L M N O P Q R S T U V W X Y Z 

IdentityEscape :: 
SourceCharacter but not IdentifierPart 
<ZWJ> 
<ZWNJ> 

DecimalEscape :: 
DecimalIntegerLiteral [lookahead not_a_member_of 
DecimalDigit] 

CharacterClassEscape :: one of 

d D s S w W 

CharacterClass :: 
[ [lookahead not_a_member_of {^}] ClassRanges ]
[ ^ ClassRanges ] 

ClassRanges :: 

[empty] 

NonemptyClassRanges 

NonemptyClassRanges :: 
ClassAtom 
ClassAtom NonemptyClassRangesNoDash 
ClassAtom -ClassAtom ClassRanges 

NonemptyClassRangesNoDash :: 
ClassAtom 
ClassAtomNoDash NonemptyClassRangesNoDash 
ClassAtomNoDash -ClassAtom ClassRanges 

ClassAtom :: 

-

ClassAtomNoDash 

ClassAtomNoDash :: 
SourceCharacter but not one of \ or ] or \ 
ClassEscape 


ClassEscape :: 
DecimalEscape

b 

CharacterEscape 

CharacterClassEscape 

15.10.2 Pattern Semantics 
A regular expression pattern is converted into an internal procedure using the process described below. An 
implementation is encouraged to use more efficient algorithms than the ones listed below, as long as the 
results are the same. The internal procedure is used as the value of a RegExp object’s [[Match]] internal 
property. 

15.10.2.1 Notation 
The descriptions below use the following variables: 

. 
Input is the String being matched by the regular expression pattern. The notation input[n] means 
the nth character of input, where n can range between 0 (inclusive) and InputLength (exclusive). 
. 
InputLength is the number of characters in the Input String. 
. 
NcapturingParens is the total number of left capturing parentheses (i.e. the total number of times 
the Atom :: ( Disjunction ) production is expanded) in the pattern. A left capturing parenthesis is 
any ( pattern character that is matched by the (terminal of the Atom :: ( Disjunction ) production. 
. 
IgnoreCase is the setting of the RegExp object's ignoreCase property. 
. 
Multiline is the setting of the RegExp object’s multiline property. 
Furthermore, the descriptions below use the following internal data structures: 

. 
A CharSet is a mathematical set of characters. 
. 
A State is an ordered pair (endIndex, captures) where endIndex is an integer and captures is an 
internal array of NcapturingParens values. States are used to represent partial match states in the 
regular expression matching algorithms. The endIndex is one plus the index of the last input 
character matched so far by the pattern, while captures holds the results of capturing parentheses. 
The nth element of captures is either a String that represents the value obtained by the nth set of 
capturing parentheses or undefined if the nth set of capturing parentheses hasn’t been reached 
yet. Due to backtracking, many States may be in use at any time during the matching process. 
. 
A MatchResult is either a State or the special token failure that indicates that the match failed. 
. 
A Continuation procedure is an internal closure (i.e. an internal procedure with some arguments 
already bound to values) that takes one State argument and returns a MatchResult result. If an 
internal closure references variables bound in the function that creates the closure, the closure 
uses the values that these variables had at the time the closure was created. The Continuation 
attempts to match the remaining portion (specified by the closure's already-bound arguments) of 
the pattern against the input String, starting at the intermediate state given by its State argument. If 
the match succeeds, the Continuation returns the final State that it reached; if the match fails, the 
Continuation returns failure. 
. 
A Matcher procedure is an internal closure that takes two arguments -- a State and a Continuation -and 
returns a MatchResult result. A Matcher attempts to match a middle subpattern (specified by 
the closure's already-bound arguments) of the pattern against the input String, starting at the 
intermediate state given by its State argument. The Continuation argument should be a closure that 
matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new State, 
the Matcher then calls Continuation on that new State to test if the rest of the pattern can match as 
well. If it can, the matcher returns the State returned by Continuation; if not, the Matcher may try 
different choices at its choice points, repeatedly calling Continuation until it either succeeds or all 
possibilities have been exhausted. 
. 
An AssertionTester procedure is an internal closure that takes a State argument and returns a 
Boolean result. The assertion tester tests a specific condition (specified by the closure's alreadyc 
Ecma International 2009 

bound arguments) against the current place in the input String and returns true if the condition 
matched or false if not. 

. 
An EscapeValue is either a character or an integer. An EscapeValue is used to denote the 
interpretation of a DecimalEscape escape sequence: a character ch means that the escape 
sequence is interpreted as the character ch, while an integer n means that the escape sequence 
is interpreted as a backreference to the nth set of capturing parentheses. 
15.10.2.2 Pattern 
The production Pattern :: Disjunction evaluates as follows: 

1. 
Evaluate Disjunction to obtain a Matcher m. 
2. 
Return an internal closure that takes two arguments, a String str and an integer index, and performs the 
following: 
3. 
Let Input be the given String str. This variable will be used throughout the algorithms in 15.10.2. 
4. 
Let InputLength be the length of Input. This variable will be used throughout the algorithms in 15.10.2. 
5. 
Let c be a Continuation that always returns its State argument as a successful MatchResult. 
6. 
Let cap be an internal array of NcapturingParens undefined values, indexed 1 through NcapturingParens. 
7. 
Let x be the State (index, cap). 
8. 
Call m(x, c) and return its result. 
NOTE A Pattern evaluates ("compiles") to an internal procedure value. RegExp.prototype.exec can then apply 
this procedure to a String and an offset within the String to determine whether the pattern would match starting at exactly 
that offset within the String, and, if it does match, what the values of the capturing parentheses would be. The algorithms 
in 15.10.2 are designed so that compiling a pattern may throw a SyntaxError exception; on the other hand, once the 
pattern is successfully compiled, applying its result internal procedure to find a match in a String cannot throw an 
exception (except for any host-defined exceptions that can occur anywhere such as out-of-memory). 

15.10.2.3 Disjunction 
The production Disjunction :: Alternative evaluates by evaluating Alternative to obtain a Matcher and returning 
that Matcher. 

The production Disjunction :: Alternative |Disjunction evaluates as follows: 

1. 
Evaluate Alternative to obtain a Matcher m1. 
2. 
Evaluate Disjunction to obtain a Matcher m2. 
3. 
Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs 
the following: 
1. 
Call m1(x, c) and let r be its result. 
2. 
If r isn't failure, return r. 
3. 
Call m2(x, c) and return its result. 
NOTE The | regular expression operator separates two alternatives. The pattern first tries to match the left Alternative 
(followed by the sequel of the regular expression); if it fails, it tries to match the right Disjunction (followed by the sequel of 
the regular expression). If the left Alternative, the right Disjunction, and the sequel all have choice points, all choices in the 
sequel are tried before moving on to the next choice in the left Alternative. If choices in the left Alternative are exhausted, 
the right Disjunction is tried instead of the left Alternative. Any capturing parentheses inside a portion of the pattern skipped 
by | produce undefined values instead of Strings. Thus, for example, 

/a|ab/.exec("abc") 

returns the result "a" and not "ab". Moreover, 
/((a)|(ab))((c)|(bc))/.exec("abc") 

returns the array 

["abc", "a", "a", undefined, "bc", undefined, "bc"] 

and not 

["abc", "ab", undefined, "ab", "c", "c", undefined] 


15.10.2.4 Alternative 
The production Alternative :: [empty] evaluates by returning a Matcher that takes two arguments, a State x and a 
Continuation c, and returns the result of calling c(x). 

The production Alternative :: Alternative Term evaluates as follows: 

1. 
Evaluate Alternative to obtain a Matcher m1. 
2. 
Evaluate Term to obtain a Matcher m2. 
3. 
Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs 
the following: 
1. 
Create a Continuation d that takes a State argument y and returns the result of calling m2(y, 
c). 
2. 
Call m1(x, d) and return its result. 
NOTE Consecutive Terms try to simultaneously match consecutive portions of the input String. If the left Alternative, 
the right Term, and the sequel of the regular expression all have choice points, all choices in the sequel are tried before 
moving on to the next choice in the right Term, and all choices in the right Term are tried before moving on to the next 
choice in the left Alternative. 

15.10.2.5 Term 
The production Term :: Assertion evaluates by returning an internal Matcher closure that takes two arguments, 
a State x and a Continuation c, and performs the following: 

1. 
Evaluate Assertion to obtain an AssertionTester t. 
2. 
Call t(x) and let r be the resulting Boolean value. 
3. 
If r is false, return failure. 
4. 
Call c(x) and return its result. 
The production Term :: Atom evaluates by evaluating Atom to obtain a Matcher and returning that Matcher. 

The production Term :: Atom Quantifier evaluates as follows: 

1. 
Evaluate Atom to obtain a Matcher m. 
2. 
Evaluate Quantifier to obtain the three results: an integer min, an integer (or ∞) max, and Boolean greedy. 
3. 
If max is finite and less than min, then throw a SyntaxError exception. 
4. 
Let parenIndex be the number of left capturing parentheses in the entire regular expression that occur to the 
left of this production expansion's Term. This is the total number of times the Atom :: ( Disjunction )
production is expanded prior to this production's Term plus the total number of Atom :: ( Disjunction )
productions enclosing this Term. 
5. 
Let parenCount be the number of left capturing parentheses in the expansion of this production's Atom. This 
is the total number of Atom :: ( Disjunction ) productions enclosed by this production's Atom. 
6. 
Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs 
the following: 
1. 
Call RepeatMatcher(m, min, max, greedy, x, c, parenIndex, parenCount) and return its 
result. 
The abstract operation RepeatMatcher takes eight parameters, a Matcher m, an integer min, an integer (or ∞) 
max, a Boolean greedy, a State x, a Continuation c, an integer parenIndex, and an integer parenCount, and 
performs the following: 

1. 
If max is zero, then call c(x) and return its result. 
2. 
Create an internal Continuation closure d that takes one State argument y and performs the following: 
1. 
If min is zero and y's endIndex is equal to x's endIndex, then return failure. 
2. 
If min is zero then let min2 be zero; otherwise let min2 be min.1. 
3. 
If max is ∞, then let max2 be ∞; otherwise let max2 be max.1. 

4. 
Call RepeatMatcher(m, min2, max2, greedy, y, c, parenIndex, parenCount) and return its 
result. 
3. 
Let cap be a fresh copy of x's captures internal array. 
4. 
For every integer k that satisfies parenIndex < k and k . 
parenIndex+parenCount, set cap[k] to undefined. 
5. 
Let e be x's endIndex. 
6. 
Let xr be the State (e, cap). 
7. 
If min is not zero, then call m(xr, d) and return its result. 
8. 
If greedy is false, then 
a. 
Call c(x) and let z be its result. 
b. 
If z is not failure, return z. 
c. 
Call m(xr, d) and return its result. 
9. 
Call m(xr, d) and let z be its result. 
10. 
If z is not failure, return z. 
11. 
Call c(x) and return its result. 
NOTE An Atom followed by a Quantifier is repeated the number of times specified by the Quantifier. A Quantifier can 
be non-greedy, in which case the Atom pattern is repeated as few times as possible while still matching the sequel, or it 
can be greedy, in which case the Atom pattern is repeated as many times as possible while still matching the sequel. The 
Atom pattern is repeated rather than the input String that it matches, so different repetitions of the Atom can match different 
input substrings. 

NOTE 2 If the Atom and the sequel of the regular expression all have choice points, the Atom is first matched as many 
(or as few, if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the 
last repetition of Atom. All choices in the last (nth) repetition of Atom are tried before moving on to the next choice in the 
next-to-last (n.1)st repetition of Atom; at which point it may turn out that more or fewer repetitions of Atom are now possible; 
these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the 
(n-1)st repetition of Atom and so on. 

Compare 

/a[a-z]{2,4}/.exec("abcdefghi") 
which returns "abcde" with 

/a[a-z]{2,4}?/.exec("abcdefghi") 
which returns "abc". 

Consider also 

/(aa|aabaac|ba|b|c)*/.exec("aabaac") 

which, by the choice point ordering above, returns the array 

["aaba", "ba"] 

and not any of: 

["aabaac", "aabaac"]
["aabaac", "c"] 

The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor 
of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15: 

"aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1") 

which returns the gcd in unary notation "aaaaa". 

NOTE 3 Step 4 of the RepeatMatcher clears Atom's captures each time Atom is repeated. We can see its behaviour in 
the regular expression 

/(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac") 

which returns the array 

["zaacbbbcac", "z", "ac", "a", undefined, "c"] 

and not 

["zaacbbbcac", "z", "ac", "a", "bbb", "c"] 

because each iteration of the outermost * clears all captured Strings contained in the quantified Atom, which in this case 
includes capture Strings numbered 2, 3, and 4. 


NOTE 4 Step 1 of the RepeatMatcher's d closure states that, once the minimum number of repetitions has been 
satisfied, any more expansions of Atom that match the empty String are not considered for further repetitions. This 
prevents the regular expression engine from falling into an infinite loop on patterns such as: 

/(a*)*/.exec("b") 

or the slightly more complicated: 

/(a*)b\1+/.exec("baaaac") 

which returns the array 

["b", ""] 

15.10.2.6 Assertion 
The production Assertion :: ^ evaluates by returning an internal AssertionTester closure that takes a State 
argument x and performs the following: 

1. 
Let e be x's endIndex. 
2. 
If e is zero, return true. 
3. 
If Multiline is false, return false. 
4. 
If the character Input[e.1] is one of LineTerminator, return true. 
5. 
Return false. 
The production Assertion :: $ evaluates by returning an internal AssertionTester closure that takes a State 
argument x and performs the following: 

1. 
Let e be x's endIndex. 
2. 
If e is equal to InputLength, return true. 
3. 
If multiline is false, return false. 
4. 
If the character Input[e] is one of LineTerminator, return true. 
5. 
Return false. 
The production Assertion :: \ b evaluates by returning an internal AssertionTester closure that takes a State 
argument x and performs the following: 

1. 
Let e be x's endIndex. 
2. 
Call IsWordChar(e.1) and let a be the Boolean result. 
3. 
Call IsWordChar(e) and let b be the Boolean result. 
4. 
If a is true and b is false, return true. 
5. 
If a is false and b is true, return true. 
6. 
Return false. 
The production Assertion :: \ B evaluates by returning an internal AssertionTester closure that takes a State 
argument x and performs the following: 

1. 
Let e be x's endIndex. 
2. 
Call IsWordChar(e.1) and let a be the Boolean result. 
3. 
Call IsWordChar(e) and let b be the Boolean result. 
4. 
If a is true and b is false, return false. 
5. 
If a is false and b is true, return false. 
6. 
Return true. 
The production Assertion :: ( ? = Disjunction ) evaluates as follows: 

1. 
Evaluate Disjunction to obtain a Matcher m. 
2. 
Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs 
the following steps: 
1. 
Let d be a Continuation that always returns its State argument as a successful MatchResult. 
2. 
Call m(x, d) and let r be its result. 
3. 
If r is failure, return failure. 
4. 
Let y be r's State. 
5. 
Let cap be y's captures internal array. 

6. 
Let xe be x's endIndex. 
7. 
Let z be the State (xe, cap). 
8. Call c(z) and return its result. 
The production Assertion :: ( ? ! Disjunction ) evaluates as follows: 
1. 
Evaluate Disjunction to obtain a Matcher m. 
2. 
Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs 
the following steps: 
1. 
Let d be a Continuation that always returns its State argument as a successful MatchResult. 
2. 
Call m(x, d) and let r be its result. 
3. 
If r isn't failure, return failure. 
4. Call c(x) and return its result. 
The abstract operation IsWordChar takes an integer parameter e and performs the following: 
1. 
If e == -1 or e == InputLength, return false. 
2. 
Let c be the character Input[e]. 
3. If c is one of the sixty-three characters below, return true. 
Abc de f g hi j k l mnopqrstuvwxy z 
AB C D E F G HI JKLMNOPQRSTUVWXY Z 
0 1 2 3 4 5 6 78 9 _ 

4. 
Return false. 
15.10.2.7 Quantifier 
The production Quantifier :: QuantifierPrefix evaluates as follows: 

1. 
Evaluate QuantifierPrefix to obtain the two results: an integer min and an integer (or ∞) max. 
2. Return the three results min , max, and true. 
The production Quantifier :: QuantifierPrefix ? evaluates as follows: 
1. 
Evaluate QuantifierPrefix to obtain the two results: an integer min and an integer (or ∞) max. 
2. 
Return the three results min , max, and false. 
The production QuantifierPrefix :: * evaluates by returning the two results 0 and ∞. 
The production QuantifierPrefix :: + evaluates by returning the two results 1 and ∞. 
The production QuantifierPrefix :: ? evaluates by returning the two results 0 and 1. 
The production QuantifierPrefix :: { DecimalDigits } evaluates as follows: 

1. 
Let i be the MVof DecimalDigits (see 7.8.3). 
2. Return the two results i and i. 
The production QuantifierPrefix :: { DecimalDigits , } evaluates as follows: 
1. 
Let i be the MVof DecimalDigits. 
2. Return the two results i and ∞. 
The production QuantifierPrefix :: { DecimalDigits , DecimalDigits } evaluates as follows: 
1. 
Let i be the MV of the first DecimalDigits. 
2. 
Let j be the MV of the second DecimalDigits. 
3. 
Return the two results i and j. 

15.10.2.8 Atom 
The production Atom :: PatternCharacter evaluates as follows: 

1. 
Let ch be the character represented by PatternCharacter. 
2. 
Let A be a one-element CharSet containing the character ch. 
3. 
Call CharacterSetMatcher(A, false) and return its Matcher result. 
The production Atom :: . evaluates as follows: 

1. 
Let A be the set of all characters except LineTerminator. 
2. 
Call CharacterSetMatcher(A, false) and return its Matcher result. 
The production Atom :: \ AtomEscape evaluates by evaluating AtomEscape to obtain a Matcher and returning 
that Matcher. 

The production Atom :: CharacterClass evaluates as follows: 

1. 
Evaluate CharacterClass to obtain a CharSet A and a Boolean invert. 
2. 
Call CharacterSetMatcher(A, invert) and return its Matcher result. 
The production Atom :: ( Disjunction ) evaluates as follows: 

1. 
Evaluate Disjunction to obtain a Matcher m. 
2. 
Let parenIndex be the number of left capturing parentheses in the entire regular expression that occur to the 
left of this production expansion's initial left parenthesis. This is the total number of times the 
Atom :: ( Disjunction ) production is expanded prior to this production's Atom plus the total number of 
Atom :: ( Disjunction ) productions enclosing this Atom. 
3. 
Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs 
the following steps: 
1. 
Create an internal Continuation closure d that takes one State argument y and performs the 
following steps: 
1. 
Let cap be a fresh copy of y's captures internal array. 
2. 
Let xe be x's endIndex. 
3. 
Let ye be y's endIndex. 
4. 
Let s be a fresh String whose characters are the characters of Input at 
positions xe (inclusive) through ye (exclusive). 
5. 
Set cap[parenIndex+1] to s. 
6. 
Let z be the State (ye, cap). 
7. 
Call c(z) and return its result. 
2. 
Call m(x, d) and return its result. 
The production Atom :: ( ? : Disjunction ) evaluates by evaluating Disjunction to obtain a Matcher and 
returning that Matcher. 

The abstract operation CharacterSetMatcher takes two arguments, a CharSet A and a Boolean flag invert, and 
performs the following: 

1. 
Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs 
the following steps: 
1. 
Let e be x's endIndex. 
2. 
If e == InputLength, return failure. 
3. 
Let c be the character Input[e]. 
4. 
Let cc be the result of Canonicalize(c). 
5. 
If invert is false, then 
a 
If there does not exist a member a of set A such that Canonicalize(a) == cc, return 
failure. 

6. 
Else invert is true, 
a If there exists a member a of set A such that Canonicalize(a) == cc, return failure. 

7. 
Let cap be x's captures internal array. 
8. 
Let y be the State (e+1, cap). 
9. 
Call c(y) and return its result. 
The abstract operation Canonicalize takes a character parameter ch and performs the following steps: 

1. 
If IgnoreCase is false, return ch. 
2. 
Let u be ch converted to upper case as if by calling the standard built-in method 
String.prototype.toUpperCase on the one-character String ch. 
3. 
If u does not consist of a single character, return ch. 
4. 
Let cu be u's character. 
5. 
If ch's code unit value is greater than or equal to decimal 128 and cu's code unit value is less than decimal 
128, then return ch. 
6. 
Return cu. 
NOTE 1 Parentheses of the form ( Disjunction ) serve both to group the components of the Disjunction pattern 
together and to save the result of the match. The result can be used either in a backreference (\ followed by a nonzero 
decimal number), referenced in a replace String, or returned as part of an array from the regular expression matching 
internal procedure. To inhibit the capturing behaviour of parentheses, use the form (?: Disjunction )instead. 

NOTE 2 The form (?= Disjunction ) specifies a zero-width positive lookahead. In order for it to succeed, the pattern 
inside Disjunction must match at the current position, but the current position is not advanced before matching the sequel. 
If Disjunction can match at the current position in several ways, only the first one is tried. Unlike other regular expression 
operators, there is no backtracking into a (?= form (this unusual behaviour is inherited from Perl). This only matters when 
the Disjunction contains capturing parentheses and the sequel of the pattern contains backreferences to those captures. 

For example, 

/(?=(a+))/.exec("baaabac") 

matches the empty String immediately after the first b and therefore returns the array: 
["", "aaa"] 

To illustrate the lack of backtracking into the lookahead, consider: 

/(?=(a+))a*b\1/.exec("baaabac") 

This expression returns 

["aba", "a"] 

and not: 

["aaaba", "a"] 

NOTE 3 The form (?! Disjunction ) specifies a zero-width negative lookahead. In order for it to succeed, the pattern 
inside Disjunction must fail to match at the current position. The current position is not advanced before matching the 
sequel. Disjunction can contain capturing parentheses, but backreferences to them only make sense from within 
Disjunction itself. Backreferences to these capturing parentheses from elsewhere in the pattern always return undefined 
because the negative lookahead must fail for the pattern to succeed. For example, 

/(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac") 

looks for an a not immediately followed by some positive number n of a's, a b, another n a's (specified by the first \2) and 
a c. The second \2 is outside the negative lookahead, so it matches against undefined and therefore always succeeds. 
The whole expression returns the array: 

["baaabaac", "ba", undefined, "abaac"] 

In case-insignificant matches all characters are implicitly converted to upper case immediately before they are compared. 
However, if converting a character to upper case would expand that character into more than one character (such as 
converting "s" (\u00DF) into "SS"), then the character is left as-is instead. The character is also left as-is if it is not an 
ASCII character but converting it to upper case would make it into an ASCII character. This prevents Unicode characters 
such as \u0131 and \u017F from matching regular expressions such as /[a-z]/i, which are only intended to match 
ASCII letters. Furthermore, if these conversions were allowed, then /[^\W]/i would match each of a, b, …, h, but not i 
or s. 


15.10.2.9 AtomEscape 
The production AtomEscape :: DecimalEscape evaluates as follows: 

1. 
Evaluate DecimalEscape to obtain an EscapeValue E. 
2. 
If E is a character, then 
a. 
Let ch be E's character. 
b. 
Let A be a one-element CharSet containing the character ch. 
c. 
Call CharacterSetMatcher(A, false) and return its Matcher result. 
3. 
E must be an integer. Let n be that integer. 
4. 
If n=0 or n>NCapturingParens then throw a SyntaxError exception. 
5. 
Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and performs 
the following: 
1. 
Let cap be x's captures internal array. 
2. 
Let s be cap[n]. 
3. 
If s is undefined, then call c(x) and return its result. 
4. 
Let e be x's endIndex. 
5. 
Let len be s's length. 
6. 
Let f be e+len. 
7. 
If f>InputLength, return failure. 
8. 
If there exists an integer i between 0 (inclusive) and len (exclusive) such that 
Canonicalize(s[i]) is not the same character as Canonicalize(Input [e+i]), then return 
failure. 
9. 
Let y be the State (f, cap). 
10. 
Call c(y) and return its result. 
The production AtomEscape :: CharacterEscape evaluates as follows: 

1. 
Evaluate CharacterEscape to obtain a character ch. 
2. 
Let A be a one-element CharSet containing the character ch. 
3. 
Call CharacterSetMatcher(A, false) and return its Matcher result. 
The production AtomEscape :: CharacterClassEscape evaluates as follows: 

1. 
Evaluate CharacterClassEscape to obtain a CharSet A. 
2. 
Call CharacterSetMatcher(A, false) and return its Matcher result. 
NOTE An escape sequence of the form \ followed by a nonzero decimal number n matches the result of the nth set 
of capturing parentheses (see 15.10.2.11). It is an error if the regular expression has fewer than n capturing parentheses. 
If the regular expression has n or more capturing parentheses but the nth one is undefined because it has not captured 
anything, then the backreference always succeeds. 

15.10.2.10 CharacterEscape 
The production CharacterEscape :: ControlEscape evaluates by returning the character according to Table 23 

Table 23 - ControlEscape Character Values 

ControlEscape Code Unit Name Symbol 
t \u0009 horizontal tab <HT> 
n 
v 
\u000A 
\u000B 
line feed (new line) 
vertical tab 
<LF> 
<VT> 
f \u000C form feed <FF> 
r \u000D carriage return <CR> 

The production CharacterEscape :: c ControlLetter evaluates as follows: 


1. Let ch be the character represented by ControlLetter. 
2. Let i be ch's code unit value. 
3. Let j be the remainder of dividing i by 32. 
4. Return the code unit numbered j. 
The production CharacterEscape :: HexEscapeSequence evaluates by evaluating the CV of the 
HexEscapeSequence (see 7.8.4) and returning its character result. 

The production CharacterEscape :: UnicodeEscapeSequence evaluates by evaluating the CV of the 
UnicodeEscapeSequence (see 7.8.4) and returning its character result. 

The production CharacterEscape :: IdentityEscape evaluates by returning the character represented by 
IdentityEscape. 

15.10.2.11 DecimalEscape 
The production DecimalEscape :: DecimalIntegerLiteral [lookahead not_a_member_of 
DecimalDigit] evaluates as follows. 
1. Let i be the MV of DecimalIntegerLiteral. 
2. If i is zero, return the EscapeValue consisting of a <NUL> character (Unicode value 0000). 
3. Return the EscapeValue consisting of the integer i. 
The definition of “the MV of DecimalIntegerLiteral” is in 7.8.3. 

NOTE If \ is followed by a decimal number n whose first digit is not 0, then the escape sequence is considered to be 
a backreference. It is an error if n is greater than the total number of left capturing parentheses in the entire regular 
expression. \0 represents the <NUL> character and cannot be followed by a decimal digit. 

15.10.2.12 CharacterClassEscape 
The production CharacterClassEscape :: d evaluates by returning the ten-element set of characters containing 
the characters 0through 9inclusive. 

The production CharacterClassEscape :: D evaluates by returning the set of all characters not included in the set 
returned by CharacterClassEscape :: d. 

The production CharacterClassEscape :: s evaluates by returning the set of characters containing the 
characters that are on the right-hand side of the WhiteSpace (7.2) or LineTerminator (7.3) productions. 

The production CharacterClassEscape :: S evaluates by returning the set of all characters not included in the set 
returned by CharacterClassEscape :: s. 

The production CharacterClassEscape :: w evaluates by returning the set of characters containing the sixty-
three characters: 

a bc def g h i jklmnopqrstuvwx y z 
AB C D EF G H I JKLMNOPQRSTUVWX Y Z 
0 1 2 3 45 6 7 8 9_ 

The production CharacterClassEscape :: W evaluates by returning the set of all characters not included in the set 
returned by CharacterClassEscape :: w. 

15.10.2.13 CharacterClass 
The production CharacterClass :: [ [lookahead not_a_member_of {^}] ClassRanges ] evaluates by evaluating ClassRanges to 
obtain a CharSet and returning that CharSet and the Boolean false. 


The production CharacterClass :: [ ^ ClassRanges ] evaluates by evaluating ClassRanges to obtain a CharSet 
and returning that CharSet and the Boolean true. 

15.10.2.14 ClassRanges 
The production ClassRanges :: [empty] evaluates by returning the empty CharSet. 

The production ClassRanges :: NonemptyClassRanges evaluates by evaluating NonemptyClassRanges to obtain a 
CharSet and returning that CharSet. 

15.10.2.15 NonemptyClassRanges 
The production NonemptyClassRanges :: ClassAtom evaluates by evaluating ClassAtom to obtain a CharSet and 
returning that CharSet. 

The production NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash evaluates as follows: 

1. 
Evaluate ClassAtom to obtain a CharSet A. 
2. 
Evaluate NonemptyClassRangesNoDash to obtain a CharSet B. 
3. 
Return the union of CharSets A and B. 
The production NonemptyClassRanges :: ClassAtom -ClassAtom ClassRanges evaluates as follows: 

1. 
Evaluate the first ClassAtom to obtain a CharSet A. 
2. 
Evaluate the second ClassAtom to obtain a CharSet B. 
3. 
Evaluate ClassRanges to obtain a CharSet C. 
4. 
Call CharacterRange(A, B) and let D be the resulting CharSet. 
5. 
Return the union of CharSets D and C. 
The abstract operation CharacterRange takes two CharSet parameters A and B and performs the following: 

1. 
If A does not contain exactly one character or B does not contain exactly one character then throw a 
SyntaxError exception. 
2. 
Let a be the one character in CharSet A. 
3. 
Let b be the one character in CharSet B. 
4. 
Let i be the code unit value of character a. 
5. 
Let j be the code unit value of character b. 
6. 
If i > j then throw a SyntaxError exception. 
7. 
Return the set containing all characters numbered i through j, inclusive. 
15.10.2.16 NonemptyClassRangesNoDash 
The production NonemptyClassRangesNoDash :: ClassAtom evaluates by evaluating ClassAtom to obtain a 
CharSet and returning that CharSet. 

The production NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash evaluates as 
follows: 

1. 
Evaluate ClassAtomNoDash to obtain a CharSet A. 
2. 
Evaluate NonemptyClassRangesNoDash to obtain a CharSet B. 
3. 
Return the union of CharSets A and B. 
The production NonemptyClassRangesNoDash :: ClassAtomNoDash -ClassAtom ClassRanges evaluates as 
follows: 

1. 
Evaluate ClassAtomNoDash to obtain a CharSet A. 
2. 
Evaluate ClassAtom to obtain a CharSet B. 
3. 
Evaluate ClassRanges to obtain a CharSet C. 

4. Call CharacterRange(A, B) and let D be the resulting CharSet. 
5. Return the union of CharSets D and C. 
NOTE 1 ClassRanges can expand into single ClassAtoms and/or ranges of two ClassAtoms separated by dashes. In the 
latter case the ClassRanges includes all characters between the first ClassAtom and the second ClassAtom, inclusive; an 
error occurs if either ClassAtom does not represent a single character (for example, if one is \w) or if the first ClassAtom's 
code unit value is greater than the second ClassAtom's code unit value. 

NOTE 2 Even if the pattern ignores case, the case of the two ends of a range is significant in determining which 
characters belong to the range. Thus, for example, the pattern /[E-F]/i matches only the letters E, F, e, and f, while the 
pattern /[E-f]/i matches all upper and lower-case ASCII letters as well as the symbols [, \, ], ^, _, and `. 

NOTE 3 A - character can be treated literally or it can denote a range. It is treated literally if it is the first or last character 
of ClassRanges, the beginning or end limit of a range specification, or immediately follows a range specification. 

15.10.2.17 ClassAtom 
The production ClassAtom :: - evaluates by returning the CharSet containing the one character -. 
The production ClassAtom :: ClassAtomNoDash evaluates by evaluating ClassAtomNoDash to obtain a CharSet 
and returning that CharSet. 

15.10.2.18 ClassAtomNoDash 
The production ClassAtomNoDash :: SourceCharacter but not one of \ or ] or -evaluates by returning a one-
element CharSet containing the character represented by SourceCharacter. 

The production ClassAtomNoDash :: \ ClassEscape evaluates by evaluating ClassEscape to obtain a CharSet 
and returning that CharSet. 

15.10.2.19 ClassEscape 
The production ClassEscape :: DecimalEscape evaluates as follows: 
1. Evaluate DecimalEscape to obtain an EscapeValue E. 
2. If E is not a character then throw a SyntaxError exception. 
3. Let ch be E's character. 
4. Return the one-element CharSet containing the character ch. 
The production ClassEscape :: b evaluates by returning the CharSet containing the one character <BS> 
(Unicode value 0008). 

The production ClassEscape :: CharacterEscape evaluates by evaluating CharacterEscape to obtain a character 
and returning a one-element CharSet containing that character. 

The production ClassEscape :: CharacterClassEscape evaluates by evaluating CharacterClassEscape to obtain a 
CharSet and returning that CharSet. 

NOTE A ClassAtom can use any of the escape sequences that are allowed in the rest of the regular expression 
except for \b, \B, and backreferences. Inside a CharacterClass, \b means the backspace character, while \B and 
backreferences raise errors. Using a backreference inside a ClassAtom causes an error. 


15.10.3 The RegExp Constructor Called as a Function 
15.10.3.1 RegExp(pattern, flags) 
If pattern is an object R whose [[Class]] internal property is "RegExp" and flags is undefined, then return R 
unchanged. Otherwise call the standard built-in RegExp constructor (15.10.4.1) as if by the expression new 
RegExp(pattern, flags) and return the object constructed by that constructor. 

15.10.4 The RegExp Constructor 
When RegExp is called as part of a new expression, it is a constructor: it initialises the newly created object. 

15.10.4.1 new RegExp(pattern, flags) 
If pattern is an object R whose [[Class]] internal property is "RegExp" and flags is undefined, then let P be the 
pattern used to construct R and let F be the flags used to construct R. If pattern is an object R whose [[Class]] 
internal property is "RegExp" and flags is not undefined, then throw a TypeError exception. Otherwise, let P 
be the empty String if pattern is undefined and ToString(pattern) otherwise, and let F be the empty String if 
flags is undefined and ToString(flags) otherwise. 

If the characters of P do not have the syntactic form Pattern, then throw a SyntaxError exception. Otherwise 
let the newly constructed object have a [[Match]] internal property obtained by evaluating ("compiling") the 
characters of P as a Pattern as described in 15.10.2. 

If F contains any character other than "g", "i", or "m", or if it contains the same character more than once, 
then throw a SyntaxError exception. 

If a SyntaxError exception is not thrown, then: 

Let S be a String in the form of a Pattern equivalent to P, in which certain characters are escaped as described 
below. S may or may not be identical to P or pattern; however, the internal procedure that would result from 
evaluating S as a Pattern must behave identically to the internal procedure given by the constructed object's 
[[Match]] internal property. 

The characters / or backslash \ occurring in the pattern shall be escaped in S as necessary to ensure that the 
String value formed by concatenating the Strings "/", S, "/", and F can be parsed (in an appropriate lexical 
context) as a RegularExpressionLiteral that behaves identically to the constructed regular expression. For 
example, if P is "/", then S could be "\/" or "\u002F", among other possibilities, but not "/", because /// 
followed by F would be parsed as a SingleLineComment rather than a RegularExpressionLiteral. If P is the empty 
String, this specification can be met by letting S be "(?:)". 

The following properties of the newly constructed object are data properties with the attributes that are 
specified in 15.10.7. The [[Value]] of each property is set as follows: 

The source property of the newly constructed object is set to S. 

The global property of the newly constructed object is set to a Boolean value that is true if F contains the 
character "g" and false otherwise. 

The ignoreCase property of the newly constructed object is set to a Boolean value that is true if F contains 
the character "i" and false otherwise. 

The multiline property of the newly constructed object is set to a Boolean value that is true if F contains 
the character "m" and false otherwise. 

The lastIndex property of the newly constructed object is set to 0. 


The [[Prototype]] internal property of the newly constructed object is set to the standard built-in RegExp 
prototype object as specified in 15.10.6. 

The [[Class]] internal property of the newly constructed object is set to "RegExp". 

NOTE If pattern is a StringLiteral, the usual escape sequence substitutions are performed before the String is 
processed by RegExp. If pattern must contain an escape sequence to be recognised by RegExp, any backslash 
\ characters must be escaped within the StringLiteral to prevent them being removed when the contents of the StringLiteral 
are formed. 

15.10.5 Properties of the RegExp Constructor 
The value of the [[Prototype]] internal property of the RegExp constructor is the standard built-in Function 
prototype object (15.3.4). 

Besides the internal properties and the length property (whose value is 2), the RegExp constructor has the 
following properties: 

15.10.5.1 RegExp.prototype 
The initial value of RegExp.prototype is the RegExp prototype object (15.10.6). 
This property shall have the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.10.6 Properties of the RegExp Prototype Object 
The value of the [[Prototype]] internal property of the RegExp prototype object is the standard built-in Object 
prototype object (15.2.4). The RegExp prototype object is itself a regular expression object; its [[Class]] is 
"RegExp". The initial values of the RegExp prototype object’s data properties (15.10.7) are set as if the 
object was created by the expression new RegExp() where RegExp is that standard built-in constructor with 
that name. 

The RegExp prototype object does not have a valueOf property of its own; however, it inherits the valueOf 
property from the Object prototype object. 

In the following descriptions of functions that are properties of the RegExp prototype object, the phrase “this 
RegExp object” refers to the object that is the this value for the invocation of the function; a TypeError 
exception is thrown if the this value is not an object or an object for which the value of the [[Class]] internal 
property is not "RegExp". 

15.10.6.1 RegExp.prototype.constructor 
The initial value of RegExp.prototype.constructor is the standard built-in RegExp constructor. 

15.10.6.2 RegExp.prototype.exec(string) 
Performs a regular expression match of string against the regular expression and returns an Array object 
containing the results of the match, or null if string did not match. 

The String ToString(string) is searched for an occurrence of the regular expression pattern as follows: 

1. Let R be this RegExp object. 
2. Let S be the value of ToString(string). 
3. Let length be the length of S. 
4. Let lastIndex be the result of calling the [[Get]] internal method of R with argument "lastIndex".. 
5. Let i be the value of ToInteger(lastIndex). 
6. Let global be the result of calling the [[Get]] internal method of R with argument "global". 

7. 
If global is false, then let i = 0. 
8. 
Let matchSucceeded be false. 
9. 
Repeat, while matchSucceeded is false 
a. 
If i < 0 or i > length, then 
i. Call the [[Put]] internal method of R with arguments "lastIndex", 0, and true. 
ii. Return null. 
b. 
Call the [[Match]] internal method of R with arguments S and i. 
c. 
If [[Match]] returned failure, then 
i. Let i = i+1. 
d. 
else 
i. Let r be the State result of the call to [[Match]]. 
ii. Set matchSucceeded to true. 
e. 
Let i = i+1. 
10. 
Let e be r's endIndex value. 
11. 
If global is true, 
a. 
Call the [[Put]] internal method of R with arguments "lastIndex", e, and true. 
12. 
Let n be the length of r's captures array. (This is the same value as 15.10.2.1's NCapturingParens.) 
13. 
Let A be a new array created as if by the expression new Array() where Array is the standard built-in 
constructor with that name. 
14. 
Let matchIndex be the position of the matched substring within the complete String S. 
15. 
Call the [[DefineOwnProperty]] internal method of A with arguments "index", Property Descriptor 
{[[Value]]: matchIndex, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true. 
16. 
Call the [[DefineOwnProperty]] internal method of A with arguments "input", Property Descriptor 
{[[Value]]: S, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true. 
17. 
Call the [[DefineOwnProperty]] internal method of A with arguments "length", Property Descriptor 
{[[Value]]: n + 1}, and true. 
18. 
Let matchedSubstr be the matched substring (i.e. the portion of S between offset i inclusive and offset e 
exclusive). 
19. 
Call the [[DefineOwnProperty]] internal method of A with arguments "0", Property Descriptor {[[Value]]: 
matchedSubstr, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true. 
20. 
For each integer i such that I > 0 and I . 
n 
a. 
Let captureI be ith element of r's captures array. 
b. 
Call the [[DefineOwnProperty]] internal method of A with arguments ToString(i), Property 
Descriptor {[[Value]]: captureI, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}, 
and true. 
21. 
Return A. 
15.10.6.3 RegExp.prototype.test(string) 
The following steps are taken: 

1. 
Let match be the result of evaluating the RegExp.prototype.exec (15.10.6.3) algorithm upon this 
RegExp object using string as the argument. 
2. 
If match is not null, then return true; else return false. 
15.10.6.4 RegExp.prototype.toString() 
Return the String value formed by concatenating the Strings "/", the String value of the source property of 
this RegExp object, and "/"; plus "g" if the global property is true, "i" if the ignoreCase property is true, 
and "m" if the multiline property is true. 

NOTE The returned String has the form of a RegularExpressionLiteral that evaluates to another RegExp object with 
the same behaviour as this object. 

15.10.7 Properties of RegExp Instances 
RegExp instances inherit properties from the RegExp prototype object and their [[Class]] internal property 
value is "RegExp". RegExp instances also have a [[Match]] internal property and a length property. 


The value of the [[Match]] internal property is an implementation dependent representation of the Pattern of the 
RegExp object. 

RegExp instances also have the following properties. 

15.10.7.1 source 
The value of the source property is a String in the form of a Pattern representing the current regular 
expression. This property shall have the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: 
false }. 

15.10.7.2 global 
The value of the global property is a Boolean value indicating whether the flags contained the character “g”. 
This property shall have the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.10.7.3 ignoreCase 
The value of the ignoreCase property is a Boolean value indicating whether the flags contained the 
character “i”. This property shall have the attributes { [[Writable]]: false, [[Enumerable]]: false, 
[[Configurable]]: false }. 

15.10.7.4 multiline 
The value of the multiline property is a Boolean value indicating whether the flags contained the character 
“m”. This property shall have the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.10.7.5 lastIndex 
The value of the lastIndex property specifies the String position at which to start the next match. It is 
coerced to an integer when used (see 15.10.6.2). This property shall have the attributes { [[Writable]]: true, 
[[Enumerable]]: false, [[Configurable]]: false }. 

NOTE Unlike the other standard built-in properties of RegExp instances, lastIndex is writable. 

15.11 Error Objects 
Instances of Error objects are thrown as exceptions when runtime errors occur. The Error objects may also 
serve as base objects for user-defined exception classes. 

15.11.1 The Error Constructor Called as a Function 
When Error is called as a function rather than as a constructor, it creates and initialises a new Error object. 
Thus the function call Error(…) is equivalent to the object creation expression new Error(…) with the 
same arguments. 

15.11.1.1 Error (message) 
The [[Prototype]] internal property of the newly constructed object is set to the original Error prototype object, 
the one that is the initial value of Error.prototype (15.11.3.1). 
The [[Class]] internal property of the newly constructed object is set to "Error". 
The [[Extensible]] internal property of the newly constructed object is set to true. 



If the argument message is not undefined, the message own property of the newly constructed object is set to 
ToString(message). Otherwise, the message own property is set to the empty String. 

15.11.2 The Error Constructor 
When Error is called as part of a new expression, it is a constructor: it initialises the newly created object. 

15.11.2.1 new Error (message) 
The [[Prototype]] internal property of the newly constructed object is set to the original Error prototype object, 
the one that is the initial value of Error.prototype (15.11.3.1). 
The [[Class]] internal property of the newly constructed Error object is set to "Error". 

The [[Extensible]] internal property of the newly constructed object is set to true. 
If the argument message is not undefined, the message own property of the newly constructed object is set to 
ToString(message). Otherwise, the message own property is set to the empty String. 

15.11.3 Properties of the Error Constructor 
The value of the [[Prototype]] internal property of the Error constructor is the Function prototype object (15.3.4). 

Besides the internal properties and the length property (whose value is 1), the Error constructor has the 
following property: 

15.11.3.1 Error.prototype 
The initial value of Error.prototype is the Error prototype object (15.11.4). 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 

15.11.4 Properties of the Error Prototype Object 
The Error prototype object is itself an Error object (its [[Class]] is "Error"). 

The value of the [[Prototype]] internal property of the Error prototype object is the standard built-in Object 
prototype object (15.2.4). 

15.11.4.1 Error.prototype.constructor 
The initial value of Error.prototype.constructor is the built-in Error constructor. 

15.11.4.2 Error.prototype.name 
The initial value of Error.prototype.name is "Error". 

15.11.4.3 Error.prototype.message 
The initial value of Error.prototype.message is the empty String. 

15.11.4.4 Error.prototype.toString ( ) 
The following steps are taken: 


1. Let O be the this value. 
2. If Type(O) is not Object, throw a TypeError exception. 
3. Let name be the result of calling the [[Get]] internal method of O with argument "name". 
4. If name is undefined, then let name be "Error"; else let name be ToString(name). 
5. Let msg be the result of calling the [[Get]] internal method of O with argument "message". 
6. If msg is undefined, then let R be msg. 
7. Else, let R be the result of concatenating name, ":", a single space character, and ToString(msg). 
8. Return R. 
15.11.5 Properties of Error Instances 
Error instances inherit properties from the Error prototype object and their [[Class]] internal property value is 
"Error". Error instances have no special properties. 

15.11.6 Native Error Types Used in This Standard 
One of the NativeError objects below is thrown when a runtime error is detected. All of these objects share the 
same structure, as described in 15.11.7. 

15.11.6.1 EvalError 
This exception is not currently used within this specification. This object remains for compatibility with previous 
editions of this specification. 

15.11.6.2 RangeError 
Indicates a numeric value has exceeded the allowable range. See 15.4.2.2, 15.4.5.1, 15.7.4.2, 15.7.4.5, 
15.7.4.6, and 15.7.4.7, 15.9.5.43. 

15.11.6.3 ReferenceError 
Indicate that an invalid reference value has been detected. See 8.7.1, 8.7.2, 10.2.1, 10.2.1.1.4, 10.2.1.2.4, 
and 11.13.1. 

15.11.6.4 SyntaxError 
Indicates that a parsing error has occurred. See 11.1.5, 11.3.1, 11.3.2, 11.4.1, 11.4.4, 11.4.5, 11.13.1, 11.13.2, 
12.2.1, 12.10.1, 12.14.1, 13.1, 15.1.2.1, 15.3.2.1, 15.10.2.2, 15.10.2.5, 15.10.2.9, 15.10.2.15, 15.10.2.19, 
15.10.4.1, and 15.12.2. 

15.11.6.5 TypeError 
Indicates the actual type of an operand is different than the expected type. See 8.6.2, 8.7.2, 8.10.5, 8.12.5, 
8.12.7, 8.12.8, 8.12.9, 9.9, 9.10, 10.2.1, 10.2.1.1.3, 10.6, 11.2.2, 11.2.3, 11.4.1, 11.8.6, 11.8.7, 11.3.1, 13.2, 
13.2.3, 15, 15.2.3.2, 15.2.3.3, 15.2.3.4, 15.2.3.5, 15.2.3.6, 15.2.3.7, 15.2.3.8, 15.2.3.9, 15.2.3.10, 15.2.3.11, 
15.2.3.12, 15.2.3.13, 15.2.3.14, 15.2.4.3, 15.3.4.2, 15.3.4.3, 15.3.4.4, 15.3.4.5, 15.3.4.5.2, 15.3.4.5.3, 15.3.5, 
15.3.5.3, 15.3.5.4, 15.4.4.3, 15.4.4.11, 15.4.4.16, 15.4.4.17, 15.4.4.18, 15.4.4.19, 15.4.4.20, 15.4.4.21, 
15.4.4.22, 15.4.5.1, 15.5.4.2, 15.5.4.3, 15.6.4.2, 15.6.4.3, 15.7.4, 15.7.4.2, 15.7.4.4, 15.7.4.8, 15.9.5, 
15.9.5.44, 15.10.4.1, 15.10.6, 15.11.4.4 and 15.12.3. 

15.11.6.6 URIError 
Indicates that one of the global URI handling functions was used in a way that is incompatible with its 
definition. See 15.1.3. 


15.11.7 NativeError Object Structure 
When an ECMAScript implementation detects a runtime error, it throws an instance of one of the NativeError 
objects defined in 15.11.6. Each of these objects has the structure described below, differing only in the name 
used as the constructor name instead of NativeError, in the name property of the prototype object, and in the 
implementation-defined message property of the prototype object. 

For each error object, references to NativeError in the definition should be replaced with the appropriate error 
object name from 15.11.6. 

15.11.7.1 NativeError Constructors Called as Functions 
When a NativeError constructor is called as a function rather than as a constructor, it creates and initialises a 
new object. A call of the object as a function is equivalent to calling it as a constructor with the same 
arguments. 

15.11.7.2 NativeError (message) 
The [[Prototype]] internal property of the newly constructed object is set to the prototype object for this error 
constructor. The [[Class]] internal property of the newly constructed object is set to "Error". The 
[[Extensible]] internal property of the newly constructed object is set to true. 

If the argument message is not undefined, the message own property of the newly constructed object is set to 
ToString(message). 

15.11.7.3 The NativeError Constructors 
When a NativeError constructor is called as part of a new expression, it is a constructor: it initialises the newly 
created object. 

15.11.7.4 New NativeError (message) 
The [[Prototype]] internal property of the newly constructed object is set to the prototype object for this 
NativeError constructor. The [[Class]] internal property of the newly constructed object is set to "Error". The 
[[Extensible]] internal property of the newly constructed object is set to true. 

If the argument message is not undefined, the message property of the newly constructed object is set to 
ToString(message). Otherwise, the message own property is set to the empty String. 

15.11.7.5 Properties of the NativeError Constructors 
The value of the [[Prototype]] internal property of a NativeError constructor is the Function prototype object 
(15.3.4). 

Besides the internal properties and the length property (whose value is 1), each NativeError constructor has 
the following property: 

15.11.7.6 NativeError.prototype 
The initial value of NativeError.prototype is a NativeError prototype object (15.11.7.7). Each NativeError 
constructor has a separate prototype object. 
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 



15.11.7.7 Properties of the NativeError Prototype Objects 
Each NativeError prototype object is an Error object (its [[Class]] is "Error"). 

The value of the [[Prototype]] internal property of each NativeError prototype object is the standard built-in 
Error prototype object (15.11.4). 

15.11.7.8 NativeError.prototype.constructor 
The initial value of the constructor property of the prototype for a given NativeError constructor is the 
NativeError constructor function itself (15.11.7). 

15.11.7.9 NativeError.prototype.name 
The initial value of the name property of the prototype for a given NativeError constructor is the name of the 
constructor (the name used instead of NativeError). 

15.11.7.10 NativeError.prototype.message 
The initial value of the message property of the prototype for a given NativeError constructor is the empty 
String. 

NOTE The prototypes for the NativeError constructors do not themselves provide a toString function, but 
instances of errors will inherit it from the Error prototype object. 

15.11.7.11 Properties of NativeError Instances 
NativeError instances inherit properties from their NativeError prototype object and their [[Class]] internal 
property value is "Error". NativeError instances have no special properties. 

15.12 The JSON Object 
The JSON object is a single object that contains two functions, parse and stringify, that are used to parse 
and construct JSON texts. The JSON Data Interchange Format is described in RFC 4627 
<http://www.ietf.org/rfc/rfc4627.txt>. The JSON interchange format used in this specification is exactly that 
described by RFC 4627 with two exceptions: 

. 
The top level JSONText production of the ECMAScript JSON grammar may consist of any JSONValue 
rather than being restricted to being a JSONObject or a JSONArray as specified by RFC 4627. 
. 
Conforming implementations of JSON.parse and JSON.stringify must support the exact interchange 
format described in this specification without any deletions or extensions to the format. This differs 
from RFC 4627 which permits a JSON parser to accept non-JSON forms and extensions. 
The value of the [[Prototype]] internal property of the JSON object is the standard built-in Object prototype 
object (15.2.4). The value of the [[Class]] internal property of the JSON object is "JSON". The value of the 
[[Extensible]] internal property of the JSON object is set to true. 

The JSON object does not have a [[Construct]] internal property; it is not possible to use the JSON object as a 
constructor with the new operator. 

The JSON object does not have a [[Call]] internal property; it is not possible to invoke the JSON object as a 
function. 


15.12.1 The JSON Grammar 
JSON.stringify produces a String that conforms to the following JSON grammar. JSON.parse accepts a String 
that conforms to the JSON grammar. 

15.12.1.1 The JSON Lexical Grammar 
JSON is similar to ECMAScript source text in that it consists of a sequence of characters conforming to the 
rules of SourceCharacter. The JSON Lexical Grammar defines the tokens that make up a JSON text similar to 
the manner that the ECMAScript lexical grammar defines the tokens of an ECMAScript source test. The 
JSON Lexical grammar only recognizes the white space character specified by the production JSONWhiteSpace. 
The JSON lexical grammar shares some productions with the ECMAScript lexical grammar. All nonterminal 
symbols of the grammar that do not begin with the characters “JSON” are defined by productions of the 
ECMAScript lexical grammar. 

Syntax

構文 

JSONWhiteSpace :: 

<TAB> 
<CR> 
<LF> 
<SP> 

JSONString :: 
"JSONStringCharacters[opt] " 

JSONStringCharacters :: 
JSONStringCharacter JSONStringCharacters[opt] 

JSONStringCharacter :: 
SourceCharacter but not double-quote "or backslash \ or U+0000 thru U+001F 
\ JSONEscapeSequence 

JSONEscapeSequence :: 
JSONEscapeCharacter 
UnicodeEscapeSequence 

JSONEscapeCharacter :: one of 

" / \ b f n r t 

JSONNumber :: 
-[opt] DecimalIntegerLiteral JSONFraction[opt] ExponentPart[opt] 

JSONFraction :: 
. DecimalDigits 

JSONNullLiteral :: 
NullLiteral 

JSONBooleanLiteral :: 
BooleanLiteral 

15.12.1.2 The JSON Syntactic Grammar 
The JSON Syntactic Grammar defines a valid JSON text in terms of tokens defined by the JSON lexical 
grammar. The goal symbol of the grammar is JSONText. 


Syntax

構文 

JSONText : 
JSONValue 

JSONValue : 
JSONNullLiteral 
JSONBooleanLiteral 
JSONObject 
JSONArray 
JSONString 
JSONNumber 

JSONObject : 

{ }
{ JSONMemberList } 

JSONMember : 
JSONString : JSONValue 

JSONMemberList : 
JSONMember 
JSONMemberList ,JSONMember 

JSONArray : 

[ ]
[ JSONElementList ] 

JSONElementList : 
JSONValue 
JSONElementList , JSONValue 

15.12.2 parse ( text [ , reviver ] ) 
The parse function parses a JSON text (a JSON-formatted String) and produces an ECMAScript value. The 
JSON format is a restricted form of ECMAScript literal. JSON objects are realized as ECMAScript objects. 
JSON arrays are realized as ECMAScript arrays. JSON strings, numbers, booleans, and null are realized as 
ECMAScript Strings, Numbers, Booleans, and null. JSON uses a more limited set of white space characters 
than WhiteSpace and allows Unicode code points U+2028 and U+2029 to directly appear in JSONString literals 
without using an escape sequence. The process of parsing is similar to 11.1.4 and 11.1.5 as constrained by 
the JSON grammar. 

The optional reviver parameter is a function that takes two parameters, (key and value). It can filter and 
transform the results. It is called with each of the key/value pairs produced by the parse, and its return value is 
used instead of the original value. If it returns what it received, the structure is not modified. If it returns 
undefined then the property is deleted from the result. 

1. 
Let JText be ToString(text). 
2. 
Parse JText using the grammars in 15.12.1. Throw a SyntaxError exception if JText did not conform to the 
JSON grammar for the goal symbol JSONText. 
3. 
Let unfiltered be the result of parsing and evaluating JText as if it was the source text of an ECMAScript 
program but using JSONString in place of StringLiteral. Note that since JText conforms to the JSON 
grammar this result will be either a primitive value or an object that is defined by either an ArrayLiteral or 
an ObjectLiteral. 
4. 
If IsCallable(reviver) is true, then 
a. 
Let root be a new object created as if by the expression new Object(), where Object is the 
standard built-in constructor with that name. 
b. 
Call the [[DefineOwnProperty]] internal method of root with the empty String, the 
PropertyDescriptor {[[Value]]: unfiltered, [[Writable]]: true, [[Enumerable]]: true, 
[[Configurable]]: true}, and false as arguments. 

c. 
Return the result of calling the abstract operation Walk, passing root and the empty String. The 
abstract operation Walk is described below. 
5. 
Else 
a. 
Return unfiltered. 
The abstract operation Walk is a recursive abstract operation that takes two parameters: a holder object and 
the String name of a property in that object. Walk uses the value of reviver that was originally passed to the 
above parse function. 

1. 
Let val be the result of calling the [[Get]] internal method of holder with argument name. 
2. 
If val is an object, then 
a. 
If the [[Class]] internal property of val is "Array"
i. 
Set I to 0. 
ii. Let len be the result of calling the [[Get]] internal method of val with argument "length". 
iii. Repeat while I < len, 
1. 
Let newElement be the result of calling the abstract operation Walk, passing val and 
ToString(I). 
2. 
If newElement is undefined, then 
a 
Call the [[Delete]] internal method of val with ToString(I) and false as 
arguments. 

3. 
Else 
a 
Call the [[DefineOwnProperty]] internal method of val with arguments 
ToString(I), the Property Descriptor {[[Value]]: newElement, [[Writable]]: 
true, [[Enumerable]]: true, [[Configurable]]: true}, and false. 

4. 
Add 1 to I. 
b. 
Else 
i. 
Let keys be an internal List of String values consisting of the names of all the own 
properties of val whose [[Enumerable]] attribute is true. The ordering of the Strings should 
be the same as that used by the Object.keys standard built-in function. 
ii. For each String P in keys do, 
1. 
Let newElement be the result of calling the abstract operation Walk, passing val and 
P. 
2. 
If newElement is undefined, then 
a Call the [[Delete]] internal method of val with P and false as arguments. 
3. 
Else 
a 
Call the [[DefineOwnProperty]] internal method of val with arguments P, 
the Property Descriptor {[[Value]]: newElement, [[Writable]]: true, 
[[Enumerable]]: true, [[Configurable]]: true}, and false. 

3. 
Return the result of calling the [[Call]] internal method of reviver passing holder as the this value and with 
an argument list consisting of name and val. 
It is not permitted for a conforming implementation of JSON.parse to extend the JSON grammars. If an 
implementation wishes to support a modified or extended JSON interchange format it must do so by defining a 
different parse function. 

NOTE In the case where there are duplicate name Strings within an object, lexically preceding values for the same 
key shall be overwritten. 

15.12.3 stringify ( value [ , replacer [ , space ] ] ) 
The stringify function returns a String in JSON format representing an ECMAScript value. It can take three 
parameters. The first parameter is required. The value parameter is an ECMAScript value, which is usually an 
object or array, although it can also be a String, Boolean, Number or null. The optional replacer parameter is 
either a function that alters the way objects and arrays are stringified, or an array of Strings and Numbers that 
acts as a white list for selecting the object properties that will be stringified. The optional space parameter is a 
String or Number that allows the result to have white space injected into it to improve human readability. 


These are the steps in stringifying an object: 

1. 
Let stack be an empty List. 
2. 
Let indent be the empty String. 
3. 
Let PropertyList and ReplacerFunction be undefined. 
4. 
If Type(replacer) is Object, then 
a. 
If IsCallable(replacer) is true, then 
i. 
Let ReplacerFunction be replacer. 
b. 
Else if the [[Class]] internal property of replacer is "Array", then 
i. 
Let PropertyList be an empty internal List 
ii. 
For each value v of a property of replacer that has an array index property name. The 
properties are enumerated in the ascending array index order of their names. 
1. 
Let item be undefined. 
2. 
If Type(v) is String then let item be v. 
3. 
Else if Type(v) is Number then let item be ToString(v). 
4. 
Else if Type(v) is Object then, 
a 
If the [[Class]] internal property of v is "String" or "Number" then let 
item be ToString(v). 

5. 
If item is not undefined and item is not currently an element of PropertyList then, 
a Append item to the end of PropertyList. 
5. 
If Type(space) is Object then, 
a. 
If the [[Class]] internal property of space is "Number" then, 
i. 
Let space be ToNumber(space). 
b. 
Else if the [[Class]] internal property of space is "String" then, 
i. 
Let space be ToString(space). 
6. 
If Type(space) is Number 
a. 
Let space be min(10, ToInteger(space)). 
b. 
Set gap to a String containing space space characters. This will be the empty String if space is less 
than 1. 
7. 
Else if Type(space) is String 
a. 
If the number of characters in space is 10 or less, set gap to space otherwise set gap to a String 
consisting of the first 10 characters of space. 
8. 
Else 
a. 
Set gap to the empty String. 
9. 
Let wrapper be a new object created as if by the expression new Object(), where Object is the 
standard built-in constructor with that name. 
10. 
Call the [[DefineOwnProperty]] internal method of wrapper with arguments the empty String, the Property 
Descriptor {[[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false. 
11. 
Return the result of calling the abstract operation Str with the empty String and wrapper. 
The abstract operation Str(key, holder) has access to ReplacerFunction from the invocation of the stringifymethod. Its algorithm is as follows: 

1. 
Let value be the result of calling the [[Get]] internal method of holder with argument key. 
2. 
If Type(value) is Object, then 
a. 
Let toJSON be the result of calling the [[Get]] internal method of value with argument "toJSON". 
b. 
If IsCallable(toJSON) is true 
i. 
Let value be the result of calling the [[Call]] internal method of toJSON passing value as the 
this value and with an argument list consisting of key. 
3. 
If ReplacerFunction is not undefined, then 
a. 
Let value be the result of calling the [[Call]] internal method of ReplacerFunction passing holder as 
the this value and with an argument list consisting of key and value. 
4. 
If Type(value) is Object then, 
a. 
If the [[Class]] internal property of value is "Number" then, 
i. 
Let value be ToNumber(value). 
b. 
Else if the [[Class]] internal property of value is "String" then, 
i. 
Let value be ToString(value). 
c. 
Else if the [[Class]] internal property of value is "Boolean" then, 
i. Let value be the value of the [[PrimitiveValue]] internal property of value. 

5. 
If value is null then return "null". 
6. 
If value is true then return "true". 
7. 
If value is false then return "false". 
8. 
If Type(value) is String, then return the result of calling the abstract operation Quote with argument value. 
9. 
If Type(value) is Number 
a. 
If value is finite then return ToString(value). 
b. 
Else, return "null". 
10. 
If Type(value) is Object, and IsCallable(value) is false 
a. 
If the [[Class]] internal property of value is "Array" then 
i. Return the result of calling the abstract operation JA with argument value. 
b. 
Else, return the result of calling the abstract operation JO with argument value. 
11. 
Return undefined. 
The abstract operation Quote(value) wraps a String value in double quotes and escapes characters within it. 

1. 
Let product be the double quote character. 
2. 
For each character C in value 
a. 
If C is the double quote character or the backslash character 
i. Let product be the concatenation of product and the backslash character. 
ii. Let product be the concatenation of product and C. 
b. 
Else if C is backspace, formfeed, newline, carriage return, or tab 
i. Let product be the concatenation of product and the backslash character. 
ii. 
Let abbrev be the character corresponding to the value of C as follows: 
backspace "b" 
formfeed "f" 
newline "n" 
carriage return "r" 
tab "t" 
iii. 
Let product be the concatenation of product and abbrev. 
c. 
Else if C is a control character having a code unit value less than the space character 
i. Let product be the concatenation of product and the backslash character. 
ii. Let product be the concatenation of product and "u". 
iii. 
Let hex be the result of converting the numeric code unit value of C to a String of four 
hexadecimal digits. 
iv. 
Let product be the concatenation of product and hex. 
d. 
Else 
i. Let product be the concatenation of product and C. 
3. 
Let product be the concatenation of product and the double quote character. 
4. 
Return product. 
The abstract operation JO(value) serializes an object. It has access to the stack, indent, gap, PropertyList, 
ReplacerFunction, and space of the invocation of the stringify method. 

1. 
If stack contains value then throw a TypeError exception because the structure is cyclical. 
2. 
Append value to stack. 
3. 
Let stepback be indent. 
4. 
Let indent be the concatenation of indent and gap. 
5. 
If PropertyList is not undefined, then 
a. 
Let K be PropertyList. 
6. 
Else 
a. 
Let K be an internal List of Strings consisting of the names of all the own properties of value whose 
[[Enumerable]] attribute is true. The ordering of the Strings should be the same as that used by the 
Object.keys standard built-in function. 
7. 
Let partial be an empty List. 
8. 
For each element P of K. 
a. 
Let strP be the result of calling the abstract operation Str with arguments P and value. 
b. 
If strP is not undefined 
i. Let member be the result of calling the abstract operation Quote with argument P. 
ii. Let member be the concatenation of member and the colon character. 
iii. 
If gap is not the empty String 

1. If stack contains value then throw a TypeError exception because the structure is cyclical. 
2. Append value to stack. 
3. Let stepback be indent. 
4. Let indent be the concatenation of indent and gap. 
5. Let partial be an empty List. 
6. Let len be the result of calling the [[Get]] internal method of value with argument "length". 
7. Let index be 0. 
8. Repeat while index < len 
a. Let strP be the result of calling the abstract operation Str with arguments ToString(index) and value. 
b. If strP is undefined 
i. 
Append "null" to partial. 
c. Else 
i. 
Append strP to partial. 
d. Increment index by 1. 
9. If partial is empty ,then 
a. Let final be "[]". 
10. Else 
a. If gap is the empty String 
i. 
Let properties be a String formed by concatenating all the element Strings of partial with 
each adjacent pair of Strings separated with the comma character. A comma is not inserted 
either before the first String or after the last String. 
ii. 
Let final be the result of concatenating "[", properties, and "]". 
b. Else 
i. 
Let separator be the result of concatenating the comma character, the line feed character, 
and indent. 
ii. 
Let properties be a String formed by concatenating all the element Strings of partial with 
each adjacent pair of Strings separated with separator. The separator String is not inserted 
either before the first String or after the last String. 
iii. 
Let final be the result of concatenating "[", the line feed character, indent, properties, the 
line feed character, stepback, and "[". 
11. Remove the last element of stack. 

a = [];
a[0] = a;
my_text = JSON.stringify(a); // This must throw an TypeError. 

NOTE 2 Symbolic primitive values are rendered as follows: 

. The null value is rendered in JSON text as the String null. 
. The undefined value is not rendered. 
. The true value is rendered in JSON text as the String true. 
. The false value is rendered in JSON text as the String false. 
NOTE 3 String values are wrapped in double quotes. The characters " and \ are escaped with \ prefixes. Control 
characters are replaced with escape sequences \uHHHH, or with the shorter forms, \b (backspace), \f (formfeed), \n 
(newline), \r (carriage return), \t (tab). 

NOTE 4 Finite numbers are stringified as if by calling ToString(number). NaN and Infinity regardless of sign are 
represented as the String null. 

NOTE 5 Values that do not have a JSON representation (such as undefined and functions) do not produce a String. 
Instead they produce the undefined value. In arrays these values are represented as the String null. In objects an 
unrepresentable value causes the property to be excluded from stringification. 

NOTE 6 An object is rendered as an opening left brace followed by zero or more properties, separated with commas, 
closed with a right brace. A property is a quoted String representing the key or property name, a colon, and then the 
stringified property value. An array is rendered as an opening left bracket followed by zero or more values, separated with 
commas, closed with a right bracket. 
